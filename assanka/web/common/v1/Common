<?php
/*
########################################################
Library of very useful functions

Accepted Inputs:
none

23rd October 2004
Andrew Betts
Assanka Ltd
########################################################
*/



/**
 * TODO:RB:20120912: This file is still in use by at least the rankings-admin-trunk and the
 * rankings-pubic-trunk projects.  Before deprecation, those projects need to be updated, or
 * we need to support some form of per-project core for older projects before we upgrade them.
 */





class AssankaCommonV1 {

	public static function getUrlParams($delim = "/") {
		if (!$delim) $delim = " ";
		$params = trim(substr($_SERVER["REQUEST_URI"], strlen($_SERVER["SCRIPT_NAME"])), $delim);
		if (($qmarkpos = strpos($params, "?")) !== false) $params = substr($params, 0, $qmarkpos);
		$array = explode($delim, $params);
		for ($i=(sizeof($array)-1); $i>=0; --$i) {
			$array[$i] = urldecode($array[$i]);
		}
		return $array;
	}

	public static function localdate($datetime, $includetime=false) {
		$time = ($includetime)?" H:i":"";
		$datestr = ($_SERVER["PHPDATE"]) ? $_SERVER["PHPDATE"] : "d/m/Y";
		$timestr = ($_SERVER["PHPTIME"]) ? $_SERVER["PHPTIME"] : "H:i";
		return ($includetime) ? date($datestr." ".$timestr, $datetime) : date($datestr, $datetime);
	}

	// Now simply an alias of the function below
	public static function uniquefile($path, $name) {
		return Common::uniqueFilename($path, $name);
	}

	public static function uniqueFilename($path, $name) {
		if (preg_match("/^(.*)(\([0-9]+\))?(\.[^\.]+)?$/Ui", $name, $matches)) {
			$extension = ((isset($matches[3]))?$matches[3]:"");
			$newname = $matches[1].$extension;
			for ($i=1; file_exists($path."/".$newname); $i++) {
				$newname = $matches[1]."(".$i.")".$extension;
			}
			return $newname;
		} else {
			return false;
		}
	}

	public static function dispBytes($num) {
		if ($num > 1099511627776) {
			if ($num/1099511627776 >= 100) {
				return number_format($num/1099511627776)." TB";
			} else {
				return number_format($num/1099511627776, 1)." TB";
			}
		} elseif ($num > 1073741824) {
			if ($num/1073741824 >= 100) {
				return number_format($num/1073741824)." GB";
			} else {
				return number_format($num/1073741824, 1)." GB";
			}
		} elseif ($num > 1048576) {
			if ($num/1048576 >= 100) {
				return number_format($num/1048576)." MB";
			} else {
				return number_format($num/1048576, 1)." MB";
			}
		} elseif ($num > 1024) {
			return number_format($num/1024)." KB";
		} else {
			return $num." B";
		}
	}

	public static function timepaststring($datetime) {
		$elapsed = time() - $datetime;
		$exact = date("j M Y H:i", $datetime);
		if ($elapsed < 60) {
			if ($elapsed == 1) {
				return "<acronym title='$exact'>1 second ago</acronym>";
			} else {
				return "<acronym title='$exact'>".$elapsed." seconds ago</acronym>";
			}
		} elseif ($elapsed < 3600) {
			if ($elapsed < 120) {
				return "<acronym title='$exact'>1 minute ago</acronym>";
			} else {
				return "<acronym title='$exact'>".round($elapsed/60)." minutes ago</acronym>";
			}
		} elseif ($elapsed < 86400) {
			if ($elapsed < 7200) {
				return "<acronym title='$exact'>1 hour ago</acronym>";
			} else {
				return "<acronym title='$exact'>".round($elapsed/3600)." hours ago</acronym>";
			}
		} elseif ($elapsed < (14*86400)) {
			if ($elapsed < (2*86400)) {
				return "<acronym title='$exact'>1 day ago</acronym>";
			} else {
				return "<acronym title='$exact'>".round($elapsed/86400)." days ago</acronym>";
			}
		} elseif ($elapsed < (8*(7*86400))) {
			return "<acronym title='$exact'>".round($elapsed/(7*86400))." weeks ago</acronym>";
		} elseif ($elapsed < (52*(7*86400))) {
			return "<acronym title='$exact'>".round($elapsed/(30.5*86400))." months ago</acronym>";
		} else {
			if ($elapsed < (2*(365*86400))) {
				return "<acronym title='$exact'>1 year ago</acronym>";
			} else {
				return "<acronym title='$exact'>".round($elapsed/(365.24*86400))." years ago</acronym>";
			}
		}
	}

	public static function timestring($seconds) {
		return getTimeDifference(0, $seconds);
	}

	public static function getTimeDifference($time1, $time2) {
		$elapsed = $time2-$time1;
		if ($elapsed == 0) {
			return "0";
		} else if ($elapsed < 60) {
			return ($elapsed == 1)?"1 second":$elapsed." seconds";
		} else if ($elapsed < (60*60)) {
			return ($elapsed < (60*2))?"1 minute":round($elapsed/60)." minutes";
		} else if ($elapsed < (60*60*24)) {
			return ($elapsed < (60*60*2))?"1 hour":round($elapsed/3600)." hours";
		} else if ($elapsed < (60*60*24*7)) {
			return ($elapsed < (60*60*24*2))?"1 day":round($elapsed/86400)." days";
		} else if ($elapsed < (60*60*24*30)) {
			return ($elapsed < (60*60*24*14))?"1 week":round($elapsed/604800)." weeks";
		} else if ($elapsed < (60*60*24*365)) {
			return ($elapsed < (60*60*24*60.83))?"1 month":round($elapsed/2628000)." months";
		} else {
			return round($elapsed/31536000)." years";
		}
	}

	public static function truncate($str, $len, $style="start", $collapsestr="...") {
		if (strlen($str) > $len) {
			if ($style=="start") {
				return substr($str, 0, $len-strlen($collapsestr)).$collapsestr;
			} elseif ($style=="middle") {
				return substr($str, 0, floor(($len-strlen($collapsestr))/2)) . $collapsestr . substr($str, 
(strlen($str)-floor(($len-strlen($collapsestr))/2)));
			} else {
				return $collapsestr . substr($str, $len-strlen($collapsestr));
			}
		} else {
			return $str;
		}
	}

	public static function searchhighlight($str, $keywords, $startstr="<span class=\"srhhl\">", $endstr="</span>") {
		if (is_array($keywords)) {
			foreach($keywords as $keyword) {
				$str = str_replace($keyword, $startstr.$keyword.$endstr, $str);
			}
		} else {
			$str = str_replace($keywords, $startstr.$keywords.$endstr, $str);
		}
		return $str;
	}

	public static function generatePassword() {
		$words = array('able', 'about', 'account', 'acid', 'across', 'after', 'again', 'against', 'almost', 'among', 'amount', 'angle', 
'animal', 'answer', 'apple', 'arch', 'army', 'attempt', 'awake', 'back', 'balance', 'ball', 'band', 'base', 'basin', 'basket', 'bath', 'because', 'before', 'belief', 'bell', 'berry', 'between', 'bird', 'birth', 'bite', 'bitter', 'black', 'blade', 'blood', 'blue', 'board', 'boat', 'body', 'boiling', 'bone', 'book', 'boot', 'bottle', 'brain', 'brake', 'branch', 'brass', 'bread', 'breath', 'brick', 'bridge', 'bright', 'broken', 'brother', 'brown', 'brush', 'bucket', 'bulb', 'burn', 'burst', 'butter', 'button', 'cake', 'camera', 'canvas', 'card', 'care', 'cart', 'cause', 'certain', 'chain', 'chalk', 'chance', 'change', 'cheap', 'cheese', 'chest', 'chief', 'chin', 'church', 'circle', 'clean', 'clear', 'clock', 'cloth', 'cloud', 'coal', 'coat', 'cold', 'collar', 'comb', 'come', 'comfort', 'common', 'company', 'complex', 'control', 'cook', 'copper', 'copy', 'cord', 'cork', 'cotton', 'cough', 'country', 'cover', 'credit', 'crime', 'crush', 'current', 'curtain', 'curve', 'cushion', 'damage', 'danger', 'dark', 'dead', 'dear', 'deep', 'degree', 'demo', 'design', 'detail', 'door', 'doubt', 'down', 'drain', 'drawer', 'dress', 'drink', 'driving', 'drop', 'dust', 'early', 'earth', 'east', 'edge', 'effect', 'elastic', 'engine', 'enough', 'equal', 'error', 'even', 'event', 'ever', 'every', 'example', 'expert', 'face', 'fact', 'fall', 'false', 'family', 'farm', 'feather', 'feeble', 'feeling', 'fiction', 'field', 'fight', 'finger', 'fire', 'first', 'fish', 'fixed', 'flag', 'flame', 'flat', 'flight', 'floor', 'flower', 'fold', 'food', 'foolish', 'foot', 'force', 'fork', 'form', 'forward', 'fowl', 'frame', 'free', 'friend', 'from', 'front', 'fruit', 'full', 'future', 'garden', 'general', 'girl', 'give', 'glass', 'glove', 'goat', 'gold', 'good', 'grain', 'grass', 'great', 'green', 'grey', 'grip', 'group', 'growth', 'guide', 'hair', 'hammer', 'hand', 'happy', 'harbour', 'hard', 'harmony', 'have', 'head', 'healthy', 'hear', 'hearing', 'heart', 'heat', 'help', 'high', 'history', 'hollow', 'hook', 'hope', 'horn', 'horse', 'hour', 'house', 'humour', 'idea', 'impulse', 'insect', 'iron', 'island', 'jelly', 'jewel', 'join', 'journey', 'judge', 'jump', 'keep', 'kettle', 'kick', 'kind', 'kiss', 'knee', 'knife', 'knot', 'land', 'last', 'late', 'laugh', 'layer', 'lead', 'leaf', 'leather', 'left', 'letter', 'level', 'library', 'lift', 'light', 'like', 'limit', 'line', 'linen', 'liquid', 'list', 'little', 'living', 'lock', 'long', 'look', 'loose', 'loss', 'loud', 'machine', 'make', 'male', 'manager', 'mark', 'market', 'married', 'mass', 'match', 'meal', 'measure', 'meat', 'medical', 'meeting', 'memory', 'metal', 'middle', 'milk', 'mind', 'mine', 'minute', 'mist', 'mixed', 'money', 'monkey', 'month', 'moon', 'morning', 'mother', 'motion', 'move', 'much', 'muscle', 'music', 'nail', 'name', 'narrow', 'nation', 'natural', 'near', 'need', 'needle', 'nerve', 'news', 'night', 'noise', 'normal', 'north', 'nose', 'note', 'number', 'offer', 'office', 'only', 'open', 'opinion', 'orange', 'order', 'other', 'oven', 'over', 'owner', 'page', 'paint', 'paper', 'parcel', 'part', 'past', 'paste', 'payment', 'peace', 'pencil', 'person', 'picture', 'pipe', 'place', 'plane', 'plant', 'plate', 'play', 'please', 'plough', 'pocket', 'point', 'polish', 'poor', 'porter', 'potato', 'powder', 'power', 'present', 'price', 'print', 'prison', 'private', 'process', 'produce', 'profit', 'prose', 'public', 'pull', 'pump', 'purpose', 'push', 'quality', 'quick', 'quiet', 'quite', 'rail', 'rain', 'range', 'rate', 'reading', 'ready', 'reason', 'receipt', 'record', 'regret', 'regular', 'request', 'respect', 'rest', 'reward', 'rhythm', 'rice', 'right', 'ring', 'river', 'road', 'roll', 'roof', 'room', 'root', 'rough', 'round', 'rule', 'safe', 'sail', 'salt', 'same', 'sand', 'scale', 'school', 'science', 'seat', 'second', 'secret', 'seed', 'seem', 'self', 'send', 'sense', 'serious', 'servant', 'shade', 'shake', 'shame', 'sharp', 'sheep', 'shelf', 'ship', 'shirt', 'shock', 'shoe', 'short', 'shut', 'side', 'sign', 'silk', 'silver', 'simple', 'size', 'sleep', 'slip', 'slope', 'slow', 'small', 'smash', 'smell', 'smile', 'smoke', 'smooth', 'snake', 'sneeze', 'snow', 'soap', 'society', 'sock', 'soft', 'solid', 'some', 'song', 'sort', 'sound', 'soup', 'south', 'space', 'spade', 'special', 'sponge', 'spoon','spring', 'square', 'stage', 'stamp', 'star', 'start', 'station', 'steam', 'steel', 'stem', 'step', 'stick', 'sticky', 'still', 'stitch', 'stone', 'stop', 'store', 'story', 'strange', 'street', 'stretch', 'strong', 'such', 'sudden', 'sugar', 'summer', 'support', 'sweet', 'swim', 'system', 'table', 'tail', 'take', 'talk', 'tall', 'taste', 'test', 'than', 'that', 'then', 'theory', 'there', 'thick', 'thin', 'thing', 'this', 'thought', 'thread', 'thumb', 'thunder', 'ticket', 'till', 'time', 'tired', 'tongue', 'tooth', 'town', 'trade', 'train', 'tray', 'tree', 'trick', 'trouble', 'true', 'turn', 'twist', 'under', 'unit', 'value', 'verse', 'very', 'vessel', 'view', 'voice', 'waiting', 'walk', 'wall', 'warm', 'wash', 'waste', 'watch', 'water', 'wave', 'weather', 'week', 'weight', 'well', 'west', 'wheel', 'when', 'where', 'while', 'whip', 'whistle', 'white', 'wide', 'will', 'wind', 'window', 'wine', 'wing', 'winter', 'wire', 'wise', 'with', 'wood', 'wool', 'word', 'work', 'wound', 'writing', 'wrong', 'year', 'yellow', 'young', 'red', 'blue', 'yellow','green','purple','walnut', 'pebble','sky','cloud','laptop','mouse','keyboard', 'monitor','display', 'scroll', 'desktop', 'email');
		return $words[array_rand($words)].rand(10,99).$words[array_rand($words)];
	}

	public static function xmlentities($string, $quote_style=ENT_QUOTES) {
		$string = html_entity_decode($string);
		static $trans;
		if (!isset($trans)) {
			$trans = get_html_translation_table(HTML_ENTITIES, $quote_style);
			foreach ($trans as $key => $value) $trans[$key] = '&#'.ord($key).';';

			// dont translate the '&' in case it is part of &xxx;
			$trans[chr(38)] = '&';
		}

		// after the initial translation, _do_ map standalone '&' into '&#38;'
		return preg_replace("/&(?![A-Za-z]{0,4}\w{2,3};|#[0-9]{2,3};)/","&#38;" , strtr($string, $trans));
	}

	// Converts "special" characters to their ord equivalent to prevent quoting issues, or </script> tags
	// within a javascript variable breaking executing, or one vector of XSS attacks
	public static function jsentities($string) {
		$l = strlen($string);
		$returnstring = "";
		for ($i=0; $i<$l; ++$i) {
			switch($string[$i]) {
				case "\r":
					$returnstring .= "\\r";
					break;
				case "\n":
					$returnstring .= "\\n";
					break;
				case "\"":
				case "'":
				case "<":
				case ">":
				case "&":
					$returnstring .= '\x'.dechex(ord($string[$i]));
				break;
				default:
					$returnstring .= $string[$i];
					break;
			}
		}
		return $returnstring;
	}

	public static function recursiveMkdir($path) {
		$path = rtrim($path, "/");
		if (!file_exists($path)) {
			if (!dirname($path)) return false;
			Common::recursiveMkdir(dirname($path));
			if (!is_writable(dirname($path))) return false;
			$old_umask = umask(0);
			mkdir($path, 0777);
			umask($old_umask);
		}
		return true;
	}

	public static function financial($number, $currencysymb="&#163;", $symbpos="prefix", $nilprompt="Nil") {
		$number = round($number, 2);
		$prefix = ($symbpos=="prefix")?$currencysymb:"";
		$postfix = ($symbpos=="postfix")?$currencysymb:"";
		if ($number == 0) {
			return $nilprompt;
		} elseif ($number < 0) {
			return "&minus;&nbsp;".$prefix.number_format(abs($number), 2).$postfix;
		} else {
			return $prefix.number_format($number, 2).$postfix;
		}
	}

	public static function generateCSV($data, $delim=",", $escape="\"", $lineend="\n", $enclose="\"") {

		// Check the supplied parameters
		if (empty($enclose) and !empty($escape)) {
			trigger_error("The escape character is used to escape the enclose character, so if you do not specify an enclose character you cannot specify an escape character", E_USER_NOTICE);
		}

		// Build an return the CSV
		$op = "";
		foreach($data as $row) {
			foreach($row as $colkey=>$col) {
				$val = (empty($escape)?$col:str_replace($enclose, $escape.$enclose, $col));
				$row[$colkey] = $enclose.$val.$enclose;
			}
			$op .= join($delim, $row).$lineend;
		}
		return $op;
	}

	public static function convertHumanTime($date) {
		if (is_numeric($date)) return $date;
		$days = '0?[1-9]|[12][0-9]|3[01]';
		$months = '0?[1-9]|1[0-2]';
		$year = '\d\d|\d\d\d\d';
		$sep = '[\/\-\.\\\,]';
		if (preg_match("/\b($year)\-($months)\-($days)(\s*(\d\d):(\d\d):(\d\d))?\b/", $date, $d)) {
			if (!isset($d[5]) or !is_numeric($d[5])) $d[5] = 0;
			if (!isset($d[6]) or !is_numeric($d[6])) $d[6] = 0;
			if (!isset($d[7]) or !is_numeric($d[7])) $d[7] = 0;
			$date = mktime($d[5], $d[6], $d[7], $d[2], $d[3], $d[1]);
		} elseif (preg_match("/\b(($days)($sep))?($months)($sep)($year)\b/", $date, $d)) {
			if (!preg_match("/\b(\d{1,2})(\:(\d\d)(\:(\d\d))?)\s*(am|pm)?\b/i", $date, $t)) $t = array(0,0,0,0,0,0,0);
			if (!isset($d[2]) or !is_numeric($d[2])) $d[2] = 0;
			if (!isset($t[3]) or !is_numeric($t[3])) $t[3] = 0;
			if (!isset($t[5]) or !is_numeric($t[5])) $t[5] = 0;
			if (!empty($t[6]) and  $t[6]==="pm") $t[1] += 12;
			$date = mktime($t[1], $t[3], $t[5], $d[4], $d[2], $d[6]);
		} elseif (strlen($date)>4) {
			$date = strtotime($date);
		} else {
			$date = false;
		}

		// Note that dates earlier than 1970 are returned as negative numbers.  Because versions of PHP earlier than
		// 5.1.0 return -1 as a failure code from strtotime(), it is impossible to represent the date 31 Dec 1969 23:59:59,
		// except during the summer, when there is a DST gap between 31 Dec and the current date, when it becomes
		// impossible to represent 31 Dec 1969 22:59:59.
		return (is_integer($date) and $date != -1) ? $date : false; 
	}

	public static function xml2array ($xml_data, $processattributes=false, $storealltagnames=false) {
		$xml_data = trim($xml_data);
		//if (preg_match("/^\<\?xml.*\?\>[\r\n]+/i", $xml_data, $matches)) $xml_data = substr($xml_data, strlen($matches[0]));
		$parser = xml_parser_create();
		$values = array();
		xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);
		xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
		xml_parse_into_struct($parser, $xml_data, $vals);
		if ($error = xml_get_error_code($parser)) {
			$line = xml_get_current_line_number($parser);
			$lines = explode("\n", $xml_data, $line+1);
			return xml_error_string($error)." at line ".$line.":\n".$lines[$line-1]."\n";
			exit;
		}
		xml_parser_free($parser);
		$params = Common::xmltree($vals, $processattributes, $storealltagnames);
		return $params;
	}

	public static function xmltree($vals, $processattributes, $storealltagnames) {
		$ids = array();
		$op = array();
		$nodecount = array();
		$preservednodekey = false;
		$rootlevel = $vals[0]["level"];
		foreach($vals as $x) if ($x["level"]==$rootlevel and $x["type"] != "close") @$nodecount[$x["tag"]]++;
		for ($i=0; $i<sizeof($vals); $i++) {
			if ($nodecount[$vals[$i]["tag"]] > 1) {
				if (isset($ids[$vals[$i]["tag"]])) {
					$key = ++$ids[$vals[$i]["tag"]];
				} else {
					$ids[$vals[$i]["tag"]] = 0;
					$key = 0;
				}
				$preservednodekey = $vals[$i]["tag"];
			} else {
				$key = $vals[$i]["tag"];
				$preservednodekey = false;
			}
			switch ($vals[$i]['type']) {
			case 'open':
				$start = $i;
				do {
					$i++;
				} while ($i<sizeof($vals) and !($vals[$i]["type"]=="close" and $vals[$i]["tag"]==$vals[$start]["tag"] and 
$vals[$i]["level"]==$vals[$start]["level"]));
				$end = $i;
				if ($processattributes) {
					$nodevalue = Common::xmltree(array_slice($vals, $start+1, ($end-$start-1)), $processattributes, $storealltagnames);
					if (!empty($preservednodekey) and $storealltagnames) {
						if (!isset($op[$preservednodekey]["_value"])) $op[$preservednodekey]["_value"] = array();
						$op[$preservednodekey]["_value"][$key] = $nodevalue;
					} else {
						$op[$key] = $nodevalue;
					}
					if (isset($vals[$start]["attributes"]) and is_array($vals[$start]["attributes"])) {
						if (!empty($preservednodekey) and $storealltagnames) {
							$op[$preservednodekey]["_value"][$key]["_attrib"] = $vals[$start]["attributes"];
						} else {
							$op[$key]["_attrib"] = $vals[$start]["attributes"];
						}
					}
				} else {
					$op[$key] = Common::xmltree(array_slice($vals, $start+1, ($end-$start-1)), $processattributes, $storealltagnames);
				}
				break;
			case 'complete':
				if ($processattributes) {
					if (!empty($preservednodekey) and $storealltagnames) {
						if (!isset($op[$preservednodekey]["_value"])) $op[$preservednodekey]["_value"] = array();
						$op[$preservednodekey]["_value"][$key] = array();
						if (isset($vals[$i]["value"])) $op[$preservednodekey]["_value"][$key] = $vals[$i]["value"];
						if (isset($vals[$i]["attributes"]) and is_array($vals[$i]["attributes"]) and is_array($op[$preservednodekey]["_value"][$key])) $op[$preservednodekey]["_value"][$key]["_attrib"] = $vals[$i]["attributes"];
					} else {
						$op[$key] = array();
						if (isset($vals[$i]["value"])) $op[$key]["_value"] = $vals[$i]["value"];
						if (isset($vals[$i]["attributes"]) and is_array($vals[$i]["attributes"])) {
							$op[$key]["_attrib"] = $vals[$i]["attributes"];
						}
					}
				} else {
					$op[$key] = (empty($vals[$i]["value"])?"":$vals[$i]["value"]);
				}
				break;
			}
		}

		return $op;
	}

	public static function xmlselectnode($xmlarray, $nodepath) {
		if (!is_array($nodepath)) $nodepath = explode("/", trim($nodepath, "/"));
		foreach ($nodepath as $node) {
			if (array_key_exists($node, $xmlarray)) {
				$xmlarray = $xmlarray[$node];
			} else {
				return false;
			}
		}
		return $xmlarray;
	}

	public static function parseCsv($str, $f_delim = ',', $r_delim = "\n", $qual = '"') {
		$output = array();
		$row = array();
		$word = '';

		$len = strlen($str);
		$inside = false;

		$skipchars = array($qual,'\\');

		for ($i = 0; $i < $len; ++$i) {
			$c = $str[$i];
			if (!$inside && $c == $f_delim) {
				$row[] = $word;
				$word = '';
			} elseif (!$inside && $c == $r_delim) {
				$row[] = $word;
				$word = '';
				$output[] = $row;
				$row = array();
			} else if ($inside && in_array($c,$skipchars) && ($i+1 < $len && $str[$i+1] == $qual)) {
				$word .= $qual;
				++$i;
			} else if ($c == $qual) {
				$inside = !$inside;
			} else {
				$word .= $c;
			}
		}

		$row[] = $word;
		$output[] = $row;

		return $output;
	}

	public static function microtime_float() {
		list($usec, $sec) = explode(" ", microtime());
		return ((float)$usec + (float)$sec);
	} 

	/*
	########################################################
	imageProcess() deals with moving pictures to the correct location, resizing
	if necessary.  Attemps to conserve transparency and image ratio.  Can read
	jpegs, pngs, gifs, bitmaps or GD2, and can output jpeg, png or gif.

	Accepted Function Inputs:
	$imagePath - Filesystem path to the image file
	$targetFolder - folder in which to save the new image
	$targetName - name to call the new image, NOT including file extension
	$uploadedFileChecks - true/false - check whether the original file was uploaded via $_POST
	$deleteOriginal - true/false - delete the original or keep it.
	$overwriteFile - true/false - overwrite an existing file or generate unique filename
	$cropTop - number of pixels to crop from the top
	$cropRight - number of pixels to crop from the right
	$cropBottom - number of pixels to crop from the bottom
	$cropLeft - number of pixels to crop from the left
	$targetWidth - new width of the image
	$targetHeight - new height of the image
	$maxX - maximum width of the image (will resize proportionally to fit)
	$maxY - maximum height of the image (will resize proportionally to fit)
	$saveAsType - converts image to "png", "jpg", "gif" if necessary
	$sharpenLevel - optional level of sharpening, integer from 0 upwards.  Corresponds with simple editor, so 1 is a little, 2 is medium, 4 is heavy, etc.
	$jpegCompression - sets JPEG compression level from 0 to 100, where 0 is smallest file
	$frameSmallImages - boolean, make resulting image precisely maxX x maxY
	$frameColorR - Red component of RGB value for frame colour
	$frameColorG - Green component of RGB value for frame colour
	$frameColorB - blue component of RGB value for frame colour

	Returns the image name (not including path but including extension) if successful,
	and false if unsuccessful.

	Rowan Beentje
	Assanka Ltd
	########################################################
	*/

	public static function imageProcess($imagePath, $targetFolder, $targetName, $uploadedFileChecks, $deleteOriginal, $overwriteFile, $cropTop, $cropRight, $cropBottom, $cropLeft, $targetWidth, $targetHeight, $maxX, $maxY, $saveAsType = "jpg", $sharpenLevel = 0, $jpegCompression = 80, $frameSmallImages = false, $frameColorR = 255, $frameColorG = 255, $frameColorB = 255) {

		// Set the time limit again:
		set_time_limit(120);
		include_once("phpunsharpmask.php");

		$imageCreate = false;

		// Make an initial check whether the original file exists
		if (!file_exists($imagePath)) {
			trigger_error("Original file not found",E_USER_NOTICE);
			return false;
		}
		
		// If necessary check for $_POST uploaded files and abort if the check is failed
		if ($uploadedFileChecks && !is_uploaded_file($imagePath)) {
			if (($deleteOriginal == true) && !(($overwriteFile == true) && (strcmp($imagePath, $targetFolder.$imageName)))) unlink($imagePath);
			trigger_error("Original file was not uploaded, and uploadedFileChecks was set to true",E_USER_NOTICE);
			return false;
		}
		
		// Get the size of the original image and abort if image reading fails
		$imageSize = @getimagesize($imagePath);
		if (!$imageSize) {
			if (($deleteOriginal == true) && !(($overwriteFile == true) && (strcmp($imagePath, $targetFolder.$imageName)))) unlink($imagePath);
			trigger_error("Could not read original file, or original file was empty.",E_USER_NOTICE);
			return false;
		}
		
		// Check supplied variables for errors, and correct if necessary
		if ($jpegCompression < 0) $jpegCompression = 0;
		if ($jpegCompression > 100) $jpegCompression = 100;
		if ($cropTop < 0) $cropTop = 0;
		if ($cropRight < 0) $cropRight = 0;
		if ($cropBottom < 0) $cropBottom = 0;
		if ($cropLeft < 0) $cropLeft = 0;
		if ($maxX < 1) $maxX = 1;
		if ($maxY < 1) $maxY = 1;
		if (($cropTop + $cropBottom) > $imageSize[1]) $cropTop = $cropBottom = 0;
		if (($cropRight + $cropLeft) > $imageSize[0]) $cropRight = $cropLeft = 0;
		if (($saveAsType != "png") && ($saveAsType != "gif")) $saveAsType = "jpg";

		// If the target width values are 0 or -1, use the original image dimensions;
		// thus feeding in an image with no target dimensions but maximum sizes allows
		// downsizing where appropriate
		if ($targetWidth < 1) $targetWidth = $imageSize[0];
		if ($targetHeight < 1) $targetHeight = $imageSize[1];

		// Read in the source image.  This uses the image info supplied by
		// getimagesize, where: 1=GIF, 2=JPG, 3=PNG, 4=SWF, 5=PSD, 6=BMP...15=WBMP
		switch ($imageSize[2]) {
			case 1:
				$imageSource = @imagecreatefromgif($imagePath);
				break;
			case 2:
				$imageSource = @imagecreatefromjpeg($imagePath);
				break;
			case 3:
				$imageSource = @imagecreatefrompng($imagePath);
				break;
			case 6:
				if (file_exists("imagecreatefrombmp.php")) {
					include ("imagecreatefrombmp.php");
					$imageSource = @imagecreatefrombmp($imagePath);
					break;
				}
			default:
				$imageSource = @imagecreatefromstring(file_get_contents($imagePath));
		}

		// If image reading failed, delete if necessary and return false
		if (!$imageSource) {
			if (($deleteOriginal == true) && !(($overwriteFile == true) && (strcmp($imagePath, $targetFolder.$imageName)))) unlink($imagePath);
			
			return false;
		}
		
		// Crop the image if necessary
		if ($cropTop || $cropRight || $cropBottom || $cropLeft) {
			$imageSize[0] = $imageSize[0] - $cropLeft - $cropRight;
			$imageSize[1] = $imageSize[1] - $cropTop - $cropBottom;
			$imageCropped = imagecreatetruecolor($imageSize[0], $imageSize[1]);
			if ($saveAsType == "png" || $saveAsType == "gif") {
				imagealphablending($imageCropped, false);
				imagesavealpha($imageCropped,true);
			}
			imagecopy($imageCropped, $imageSource, 0, 0, $cropLeft, $cropTop, $imageSize[0], $imageSize[1]);
			imagedestroy($imageSource);
			$imageSource = imagecreatetruecolor($imageSize[0], $imageSize[1]);
			imagecopy($imageSource, $imageCropped, 0, 0, 0, 0, $imageSize[0], $imageSize[1]);
			imagedestroy($imageCropped);
			$imageCreate = true;
		}
		
		// Next check if picture size exceeds maximum desired; if it does, resize to fit.
		// This needs to be run over both dimensions so that even if both x and y
		// are rescaled the scaled versions will be within bounds.
		// Target dimensions of zero are counted as Very Large
		if (!$maxX) $maxX = 2000000;
		if (!$maxY) $maxY = 2000000;
		if (($targetWidth > $maxX) || ($targetHeight > $maxY)) {
			if ($imageSize[0] > $maxX) {
				$targetWidth = $maxX;
				$targetHeight = ($targetWidth/$imageSize[0]) * $imageSize[1];
			} else {
				$targetHeight = $maxY;
				$targetWidth = ($targetHeight/$imageSize[1]) * $imageSize[0];
			}
			if ($targetHeight > $maxY) {
				$targetWidth = ($maxY/$targetHeight) * $targetWidth;
				$targetHeight = $maxY;
			}
		}
		
		// Resample down if necessary.
		if (($targetWidth < $imageSize[0]) || ($targetHeight < $imageSize[1])) {

			// If targetWidth or targetHeight < 1px, then imagecreatetruecolor will error;
			// so catch this situation and throw a more descriptive notice instead
			if ($targetWidth < 1 || $targetHeight < 1) {
				trigger_error("Could not resample down to required size - resampled version would be less than 1px tall and / or less than 1px wide", E_USER_NOTICE);
				return false;
			}

			// Perform resample
			$imageResampled = imagecreatetruecolor($targetWidth, $targetHeight);
			if ($saveAsType == "png" || $saveAsType == "gif") {
				imagealphablending($imageResampled, false);
				imagesavealpha($imageResampled,true);
			}

			// If the target is much smaller than the current image, use
			// imagecopyresized to resize down to four times the target, then
			// resample down
			if (($imageSize[1] > (4*$targetHeight)) && ($imageSize[0] > (4*$targetWidth))) {
				$imageResized = imagecreatetruecolor($targetWidth*4, $targetHeight*4);
				if ($saveAsType == "png" || $saveAsType == "gif") {
					imagealphablending($imageResized, false);
					imagesavealpha($imageResized,true);
				}
				imagecopyresized($imageResized, $imageSource, 0, 0, 0, 0, $targetWidth*4, $targetHeight*4, $imageSize[0], $imageSize[1]);
				imagecopyresampled($imageResampled, $imageResized, 0, 0, 0, 0, $targetWidth, $targetHeight, $targetWidth*4, $targetHeight*4);		
				imagedestroy($imageResized);
			} else {
				imagecopyresampled($imageResampled, $imageSource, 0, 0, 0, 0, $targetWidth, $targetHeight, $imageSize[0], $imageSize[1]);		
			}
			
			imagedestroy($imageSource);
			$imageSource = imagecreatetruecolor($targetWidth, $targetHeight);
			imagecopy($imageSource, $imageResampled, 0, 0, 0, 0, $targetWidth, $targetHeight);
			imagedestroy($imageResampled);
			$imageCreate = true;
		}
		
		// Frame if necessary.
		if ((($maxX > $targetWidth) || ($maxY > $targetHeight)) && $frameSmallImages) {
			$imageResampled = imagecreatetruecolor($maxX, $maxY);
			if ($saveAsType == "png" || $saveAsType == "gif") {
				imagealphablending($imageResampled, false);
				imagesavealpha($imageResampled,true);
			}
			$bgcolor = imagecolorallocate($imageResampled, $frameColorR, $frameColorG, $frameColorB);
			imagefilledrectangle($imageResampled, 0, 0, $maxX - 1, $maxY - 1, $bgcolor);
			imagecopy($imageResampled, $imageSource, floor(($maxX - $targetWidth)/2), floor(($maxY - $targetHeight)/2), 0, 0, $targetWidth, $targetHeight);
			imagedestroy($imageSource);
			$imageSource = imagecreatetruecolor($maxX, $maxY);
			imagecopy($imageSource, $imageResampled, 0, 0, 0, 0, $maxX, $maxY);
			imagedestroy($imageResampled);
			$imageCreate = true;
		}

		// If the image hasn't been resized, check whether the extension matches; if
		// it does, there's no need to recompress the image.
		if (!$imageCreate) {	
			$imagePathParts = explode(".", $imagePath);
			$imageExtension = end($imagePathParts);
			if (strcasecmp($imageExtension,"jpeg") == 0) $imageExtension = "jpg";
			if (strcasecmp($imageExtension, $saveAsType) != 0) $imageCreate = true;
		}
		
		// Thanks to Torstein Hï¿½nsi's phpUnsharpMask, a sharpening operation can
		// be performed without the ImageMagick dependancy.
		if ($sharpenLevel) {
			
			// UnsharpMask as a command is fairly versatile, but for simplicity's
			// sake wetake an integer and generate 'standard' other values from it.
			// As $sharpenLevel goes, 0 is none, 1 is mild, 2 is medium, 4 is fairly heavy.
			$unsharpAmount = 50 * $sharpenLevel;
			$unsharpRadius = 0.2 + (0.2 * $sharpenLevel);
			$unsharpThreshold = 3.5 - (0.5 * $sharpenLevel);
			if ($unsharpThreshold < 0) $unsharpThreshold = 0; 
			UnsharpMask($imageSource, $unsharpAmount, $unsharpRadius, $unsharpThreshold);
			$imageCreate = true;
		}

		$imageName = $targetName.".".$saveAsType;

		// Recompress or convert the image if necessary
		if ($imageCreate) {
			imageinterlace($imageSource, 1);
			if ($overwriteFile == true) {
				Common::recursiveMkDir($targetFolder);
				if (file_exists($targetFolder.$imageName)) unlink($targetFolder.$imageName);
			} else {
				$imageName = Common::uniqueFilename($targetFolder, $targetName.".".$saveAsType);
			}
			
			if ($saveAsType == "png") {
				imagepng($imageSource, $targetFolder.$imageName);
			} else if ($saveAsType == "jpg") {
				imagejpeg($imageSource, $targetFolder.$imageName, $jpegCompression);
			} else if ($saveAsType == "gif") {
				if (function_exists("imagegif")) imagegif($imageSource, $targetFolder.$imageName);
				else {
					if (($deleteOriginal == true) && !(($overwriteFile == true) && (strcmp($imagePath, $targetFolder.$imageName)))) unlink($imagePath);
					trigger_error("Could not save as GIF - no imagegif function",E_USER_NOTICE);
					return false;
				}
			}
			
			// Delete the original if required.
			if (($deleteOriginal == true) && !(($overwriteFile == true) && (strcmp($imagePath, $targetFolder.$imageName)))) unlink($imagePath);
			
		// Otherwise just move the original, replacing the extension with all-lowercase
		} else {
			if ($overwriteFile == true) {
				if (file_exists($targetFolder.$imageName)) unlink($targetFolder.$imageName);
			}
			if ($deleteOriginal == true) {
				rename($imagePath, $targetFolder.$imageName);
			} else if ($imagePath != $targetFolder.$imageName) {
				copy($imagePath, $targetFolder.$imageName);
			}
		}
		imagedestroy($imageSource);
		return $imageName;
	}
	
	// TODO:RB:20071001: Improve this function - multipart, attachments? See email thread.
	public static function mail($to, $from, $subject, $message, $additionalheaders = false, $additionalparams = false) {
		
		// Basic error catching
		if (!trim($to)) trigger_error("No email address provided to send an email to.", E_USER_ERROR);
		if (!trim($from)) trigger_error("No email address provided to send an email from.", E_USER_ERROR);
		if (!trim($subject)) trigger_error("No subject line provided for email.", E_USER_ERROR);
		if (!trim($message)) trigger_error("No message provided to send.", E_USER_ERROR);
		 
		// Prevent header injection via the "to" and "subject" fields
		$to = str_replace(array("\r", "\n"), "", $to);
		$subject = str_replace(array("\r", "\n"), "", $subject);
		
		// Encode the to and from parts if they're (a) not just email addresses and (b) contain UTF chars
		$emailregex = "/^(.*)?\s*(\<(?:[a-z0-9\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+(?:\.[a-z0-9\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+)*|\"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])\>)$/i";
		if (preg_match($emailregex, $to, $matches) and strlen($matches[1])) {
			if (Common::detectUTF8($matches[1])) {
				$to = Common::_quoted_printable_encode(trim($matches[1], " \t\n\r\0\x0B\""))." ".$matches[2];
			}
		}
		if (preg_match($emailregex, $from, $matches) and strlen($matches[1])) {
			if (Common::detectUTF8($matches[1])) {
				$from = Common::_quoted_printable_encode(trim($matches[1], " \t\n\r\0\x0B\""))." ".$matches[2];
			}
		}
		
		// Encode the subject line if appropriate
		if (Common::detectUTF8($subject)) {
			$subject = Common::_quoted_printable_encode(trim($subject));
		}
		
		// Add UTF headers and the sender to the additional headers list
		if (strpos($additionalheaders, "Content-Type") === false) {
			$additionalheaders = "Content-Type: text/plain; charset=UTF-8".(($additionalheaders)?"\r\n".$additionalheaders:"");
		}
		$additionalheaders = "From: ".$from."\r\n".$additionalheaders;

		mail($to, $subject, $message, $additionalheaders, $additionalparams);
		return true;	
	}

	// Private function used by Common::mail for encoding text.  Originally sourced from
	// http://uk2.php.net/manual/en/function.imap-8bit.php
	public static function _quoted_printable_encode($sText, $bEmulate_imap_8bit = true) {
	
		// Split text into lines
		$aLines = explode(chr(13).chr(10), $sText);
		
		for ($i=0;$i<count($aLines);$i++) {
			$sLine =& $aLines[$i];
			if (strlen($sLine)===0) continue; // do nothing, if empty
		
			$sRegExp = '/[^\x09\x20\x21-\x3C\x3E-\x7E]/e';
			
			// imap_8bit encodes x09 everywhere, not only at lineends,
			// for EBCDIC safeness encode !"#$@[\]^`{|}~,
			// for complete safeness encode every character :)
			if ($bEmulate_imap_8bit) $sRegExp = '/[^\x20\x21-\x3C\x3E-\x7E]/e';
		
			$sReplmt = 'sprintf( "=%02X", ord ( "$0" ) ) ;';
			$sLine = preg_replace( $sRegExp, $sReplmt, $sLine ); 
		
			// encode x09,x20 at lineends
			$iLength = strlen($sLine);
			$iLastChar = ord($sLine{$iLength-1});
			
			//              !!!!!!!!   
			// imap_8_bit does not encode x20 at the very end of a text,
			// here is, where I don't agree with imap_8_bit,
			// please correct me, if I'm wrong,
			// or comment next line for RFC2045 conformance, if you like
			if (!($bEmulate_imap_8bit && ($i==count($aLines)-1))) {
				if (($iLastChar==0x09)||($iLastChar==0x20)) {
					$sLine{$iLength-1} = '=';
					$sLine .= ($iLastChar==0x09)?'09':'20';
				}
			}
	
			// imap_8bit encodes x20 before chr(13), too
			// although IMHO not requested by RFC2045, why not do it safer :)
			// and why not encode any x20 around chr(10) or chr(13)
			if ($bEmulate_imap_8bit) {
				$sLine=str_replace(' =0D','=20=0D',$sLine);
			}
		
			// finally split into softlines no longer than 76 chars,
			// for even more safeness one could encode x09,x20
			// at the very first character of the line
			// and after soft linebreaks, as well,
			// but this wouldn't be caught by such an easy RegExp                  
			preg_match_all( '/.{1,73}([^=]{0,2})?/', $sLine, $aMatch );
		
			// Assanka: 
			$sLine = "=?utf-8?Q?".implode( "?=\r\n\t=?utf-8?Q?" . chr(13).chr(10), $aMatch[0] )."=?="; // add soft crlf's
		}
		
		// join lines into text
		return implode(chr(13).chr(10),$aLines);
	}
	
	// Function to detect whether UTF-8 is present in a string - from comment by chris AT w3style.co DOT uk
	// on http://www.php.net/mb_detect_encoding
	public static function detectUTF8($string) {
		return preg_match('%(?:
		[\xC2-\xDF][\x80-\xBF]        # non-overlong 2-byte
		|\xE0[\xA0-\xBF][\x80-\xBF]               # excluding overlongs
		|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}      # straight 3-byte
		|\xED[\x80-\x9F][\x80-\xBF]               # excluding surrogates
		|\xF0[\x90-\xBF][\x80-\xBF]{2}    # planes 1-3
		|[\xF1-\xF3][\x80-\xBF]{3}                  # planes 4-15
		|\xF4[\x80-\x8F][\x80-\xBF]{2}    # plane 16
		)+%xs', $string);
	}

	// Function to prevent cross-site scripting attacks by adding <span></span> tags to dangerous tags
	// and attributes; also prevents non-printable characters, linebreaks, and character encodings
	// from being used to attempt to get around similar sets.
	// This function is adapted from http://quickwired.com/smallprojects/php_xss_filter_function.php
	// (which is in the public domain).
	public static function removeXSS($string) {
		
		// Remove all non-printable characters. CR(0a) and LF(0b) and TAB(9) are allowed;
		// this prevents some character re-spacing such as <java\0script>.  Note that splits
		// with \n, \r, and \t are handled later since they *are* allowed in some inputs.
		$string = preg_replace('/([\x00-\x08,\x0b-\x0c,\x0e-\x19])/', '', $string);

		// Replace encoded "normal" characters with the normal characters themselves.  Standard
		// text shouldn't be using encoded text for all characters anyway, and this prevents tags
		// like <IMG SRC=&#X40&#X61&#X76&#X61&#X73&#X63&#X72&#X69&#X70&#X74&#X3A&#X61
		// &#X6C&#X65&#X72&#X74&#X28&#X27&#X58&#X53&#X53&#X27&#X29 />
		$search = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
		$search .= '1234567890!@#$%^&*()~`";:?+/={}[]-_|\'\\'; 
		for ($i = 0; $i < strlen($search); $i++) {
		
			// ;? at the end matches the ;, which is optional.
			// 0{0,8} matches any padded zeros, which are optional and go up to 8 chars

			// Replace hex-encoded characters with their text equivalent
			$string = preg_replace('/(&#[xX]0{0,8}'.dechex(ord($search[$i])).';?)/i', $search[$i], $string);

			// Replace ord/long-encoded ASCII characters with their text equivalent
			$string = preg_replace('/(&#0{0,8}'.ord($search[$i]).';?)/', $search[$i], $string);
		}

		// By now the only remaining whitespace attacks are \t, \n, and \r - dealt with in $pattern.
		$ra1 = Array('javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'style', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base');
		$ra2 = Array('onabort', 'onactivate', 'onafterprint', 'onafterupdate', 'onbeforeactivate', 'onbeforecopy', 'onbeforecut', 'onbeforedeactivate', 'onbeforeeditfocus', 'onbeforepaste', 'onbeforeprint', 'onbeforeunload', 'onbeforeupdate', 'onblur', 'onbounce', 'oncellchange', 'onchange', 'onclick', 'oncontextmenu', 'oncontrolselect', 'oncopy', 'oncut', 'ondataavailable', 'ondatasetchanged', 'ondatasetcomplete', 'ondblclick', 'ondeactivate', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'onerror', 'onerrorupdate', 'onfilterchange', 'onfinish', 'onfocus', 'onfocusin', 'onfocusout', 'onhelp', 'onkeydown', 'onkeypress', 'onkeyup', 'onlayoutcomplete', 'onload', 'onlosecapture', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onmove', 'onmoveend', 'onmovestart', 'onpaste', 'onpropertychange', 'onreadystatechange', 'onreset', 'onresize', 'onresizeend', 'onresizestart', 'onrowenter', 'onrowexit', 'onrowsdelete', 'onrowsinserted', 'onscroll', 'onselect', 'onselectionchange', 'onselectstart', 'onstart', 'onstop', 'onsubmit', 'onunload');
		$ra = array_merge($ra1, $ra2);

		// Keep replacing as long as the previous round replaced something
		$found = true; 
		while ($found == true) {
			$string_before = $string;
			for ($i = 0; $i < sizeof($ra); $i++) {
			
				// Build up a pattern which includes optional \t, \n, and \r between each word.
				$pattern = '/';
				for ($j = 0; $j < strlen($ra[$i]); $j++) {
					if ($j > 0) {
						$pattern .= '((&#[xX]0{0,8}([9ab]);)|(&#0{0,8}([9|10|13]);))*';
					}
					$pattern .= $ra[$i][$j];
				}
				$pattern .= '/i';
				
				// Replace any found instances with <span></span> - this is invisible if plain text
				// has been mistakenly identified, but breaks up tags or attributes.
				$replacement = substr($ra[$i], 0, 2).'<span></span>'.substr($ra[$i], 2);
				$string = preg_replace($pattern, $replacement, $string); 

				// If no replacements were made, exit the loop 
				if ($string_before == $string) {
					$found = false;
				}
			}
		}
		return $string;
	}

}

// For compatibility reasons - declare initially as AssankaCommonV1, and if nothing else is using Common,
// redeclare as that.
if (!class_exists("Common")) {
        class Common extends AssankaCommonV1 {
        }
}


