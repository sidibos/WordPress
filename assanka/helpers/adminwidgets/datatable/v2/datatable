<?php
/**
 * Data table display class
 *
 * Generates HTML for displaying tables of data.
 *
 * @copyright The Financial Times Limited [All Rights Reserved]
 */
class DatatableV2 extends TemplateManager {
	
	private $tablename, $columns, $filters, $data, $footer, $sortable, $title, $usekeys, $allowfilterdefaults, $uri, $xls_splithorizontal = false, $xls_splitvertical = false, $xls_customtemplate = false, $defaultdefs = false;


	/**
	 * Create a data table
	 * 
	 * Instantiates a data table object, using a name that is used to identify the table in the DOM
	 *
	 * @param   string   $name   Name of table to use in HTML DOM
	 * @return  DatatableV2
	 */
	function __construct($name=null) {
		parent::__construct($_SERVER["CORE_PATH"]."/helpers/adminwidgets/datatable/v2/templates");
		if (!$name) $name = substr(uniqid(), 0, 6);
		$this->tablename = $name;
		$this->set("tablename", $name);
		$this->columns = array();
		$this->filters = array();
		$this->data = array();
		$this->footer = array();
		$this->sortable = true;
		$this->usekeys = false;
		$this->allowfilterdefaults = (!isset($_SESSION["datatable"][$this->tablename]["filters"])) ? 1 : 0;
		$this->uri = (!empty($_GET)) ? substr($_SERVER["REQUEST_URI"], 0, strpos($_SERVER["REQUEST_URI"], "?")) : $_SERVER["REQUEST_URI"];
		$this->uri = preg_replace('|/page-[0-9]+/?$|i', '/', $this->uri);

		if (isset($_GET["fil_set"]) and $_GET["fil_set"] == $this->tablename) {

			// Clear any stored pagination
			unset($_SESSION['datatable'][$this->tablename]['lastusedpage']);

			if (!empty($_GET["fil_submit"]) and $_GET["fil_submit"] == "Reset") {
				unset($_SESSION["datatable"][$this->tablename]["filters"]);
				$this->allowfilterdefaults = 1;
				$usefiltersettings = false;
			} else {
				$_SESSION["datatable"][$this->tablename]["filters"] = array();
				$usefiltersettings = true;
			}

			foreach($_GET as $key=>$value) {
				if (strpos($key, "fil_") !== 0) continue;
				if ($usefiltersettings and $key != 'fil_set' and $value != "") {
					$filterkey = substr($key, strlen("fil_"));
					$_SESSION["datatable"][$this->tablename]["filters"][$filterkey] = $value;
				}
				unset($_GET[$key]);				
			}
			
			// Rebuild the $_GET string without the column selector or sort direction, to prevent
			// resorting of the table on use of "back" link.
			$urlvars = array();
			foreach ($_GET as $key=>$value) {
				$urlvars[] = urlencode($key).'='.urlencode($value);
			}
			header("Location: ".$this->uri.((count($urlvars))?'?'.implode('&', $urlvars):''));
			exit;
		}

		if (isset($_GET["s"])) {

			// Clear any stored pagination
			unset($_SESSION['datatable'][$this->tablename]['lastusedpage']);
		
			// Apply the sort column if supplied
			if (!empty($_GET["s"]) and !empty($_SESSION["datatable"][$this->tablename]["sort"]) and $_SESSION["datatable"][$this->tablename]["sort"]["col"] == $_GET["s"]) {
				$d = $_SESSION["datatable"][$this->tablename]["sort"]["dir"];
				$_SESSION["datatable"][$this->tablename]["sort"]["dir"] = ($d=="ASC") ? "DESC" : "ASC";
			} else {
				$_SESSION["datatable"][$this->tablename]["sort"] = array();
			}
			$_SESSION["datatable"][$this->tablename]["sort"]["col"] = $_GET["s"];
			unset($_GET["s"]);
			
			// Apply a sort direction if supplied - used for restoring saved views, eg IOMA reports.
			if (isset($_GET["sortdir"])) {
				if (strtolower($_GET["sortdir"]) == "asc") $_SESSION["datatable"][$this->tablename]["sort"]["dir"] = "ASC";
				elseif (strtolower($_GET["sortdir"]) == "desc") $_SESSION["datatable"][$this->tablename]["sort"]["dir"] = "DESC";
				unset($_GET["sortdir"]);
			}
			
			// Rebuild the $_GET string without the column selector or sort direction, to prevent
			// resorting of the table on use of "back" link.
			$urlvars = array();
			foreach ($_GET as $key=>$value) {
				$urlvars[] = urlencode($key).'='.urlencode($value);
			}
			header("Location: ".$this->uri.((count($urlvars))?'?'.implode('&', $urlvars):''));
			exit;
		}
	}

	/**
	 * Set default definition data for fields
	 * 
	 * Loads a set of definition data into the class, allowing fields to be added to the table without specifying individual definitions for each one.  Sets the default options for addColumn, addColumns, addFilter and addFilters calls. Useful to pass a model of your data structure into the datatable in one go.
	 *
	 * @param   array   $defdata   Associative array of field names to arrays containing definition data
	 * @return  void
	 */
	function useDefinitions(&$defdata) {
		if (!is_array($defdata)) trigger_error("Default definition data must be an array", E_USER_ERROR);
		$this->defaultdefs = $defdata;
	}

	/**
	 * Set the title of the table
	 * 
	 * Causes the table to be rendered with a title bar.  If this method is not used, the table will have no title, which is better if the table is the only thing on the page.
	 *
	 * @param   string   $title   Title to display
	 * @return  void
	 */
	function setTitle($title) {
		$this->set("title", $title);
	}

	/**
	 * Get the name of the table
	 *
	 * @return  string  The name given as an argument when the table was constructed
	 */
	function getName() {
		return $this->tablename;
	}

	/**
	 * Add row IDs to the DOM
	 * 
	 * Makes Datatable insert additional attributes on the <tr> element of each row, identifying the row using a unique key. The elements added are the ID, which is set to {tablename}_{rowkey}, and ROWKEY, which is set to the raw row key.
	 *
	 * @return  void
	 */
	function useKeys() {
		$this->usekeys = true;
	}

	/**
	 * Enables or disables sorting of the table as a whole
	 * 
	 * Sets the sortability of the table, ie. whether it is possible to sort it by clicking on column headings. Individual columns can be made non-sortable by using a column definition option, whereas this method applies to all columns. Default is true. If set to false all columns will be non-sortable regardless of any column-specific sortable settings.
	 *
	 * @return  void
	 */
	function setSortable($bool) {
		$this->sortable = $bool;
	}

	/**
	 * Add a column to the table
	 *
	 * The second argument to this method is the definition of the column, which may include any/all of the following properties in an associative array:
	 * 
	 * <dl>
	 * <dt>primarysort</dt><dd>Boolean, whether this column should be used to sort the table if there is no user defined sort preference.  Default false.</dd>
	 * <dt>displaycallback</dt><dd>Mixed, callback function to be called by Datatable before displaying cell data in this column.  If a globally defined function, pass the name of the function in a string.  If a method of a statically defined class, pass the name of the class and the method as elements in a simple two-element array.  If a method of an object instance, pass a reference to the object and the name of the function in a simple two element array.  Note: If you want to create a link on every cell in a column, such as to link from an inex table to the view pages for each item, use a display callback.  For generic relationships like index -&gt; view, a generic display callback can be used.  Here's an example:
	 * <code>
	 * function disp_viewlink($ref, $data) {
	 *   $base = dirname($_SERVER["SCRIPT_NAME"]);
	 *   return "<a href=\"".$base."/view?id=".$data["id"]."\">" . 
	 *   $data[$ref]."</a>";
	 * }
	 * </code>
	 * If you want to add hyperlinks to the content of a table cell, use display modifiers to do that.</dd>
	 * <dt>displaymodifiers</dt><dd>String, standard template manager display modifiers to be applied by the template manager prior to display of cell data in this column.</dd>
	 * <dt>sort</dt><dd> Default sort direction for this column.  Choose from 'ASC' or 'DESC'.  Default is 'ASC'.</dd>
	 * <dt>sortcallback</dt><dd>Mixed, callback function to be called by Datatable to generate sort SQL for this column.  If a globally defined function, pass the name of the function in a string.  If a method of a statically defined class, pass the name of the class and the method as elements in a simple two-element array.  If a method of an object instance, pass a reference to the object and the name of the function in a simple two element array.  If not specified, Datatable will construct sort SQL using the column name followed by the sort direction.</dd>
	 * <dt>highlightfilter</dt><dd> String, name of a filter whose value should be highlighted in the cell data of the column.</dd>
	 * <dt>width</dt><dd>Integer, width in pixels of the column.  Default is flexible width.</dd>
	 * <dt>align</dt><dd>String, value of CSS property text-align in the column cells.  'left' or 'right' (default is left)</dd>
	 * <dt>label</dt><dd>String, label to apply to column header.  If omitted, will use column name capitalised.</dd>
	 * <dt>sortable</dt><dd>Boolean, whether this individual column is sortable.  Default is true if the table as a whole is sortable.  If the table is not sortable, this setting has no effect.</dd>
	 * <dt>columnclass</dt><dd>String, CSS class to be added to the <th> and <td> cells in this column.</dd>
	 * </dl>
	 *
	 * // COMPLEX:RB:20080716: Note that columns are sometimes added to tables after data is added,
	 * // so that the code beneath should remain compatible with multiple orders of execution.
	 *
	 * @param   string  $name        The name of the column.  This will be used to refer to the column for sorting, and to look up definitions if supplied using useDefinitions
	 * @param   array   $definition  Definition data for the column, as described above.  If not present, will use definitions defined by useDefinitions
	 * @return  void
	 */
	function addColumn($name, $definition=array()) {
		if (is_array($this->columns) and array_key_exists($name, $this->columns)) {
			trigger_error("Column '".$name."' already exists, ignoring this column.", E_USER_NOTICE);
			return false;
		}
		if (!is_array($definition)) trigger_error("Column definition must be an array", E_USER_ERROR);
		if (empty($definition) and !empty($this->defaultdefs[$name])) $definition = $this->defaultdefs[$name];
		$this->columns[$name] = $definition;
	}

	/**
	 * Adds lots of columns to the table
	 * 
	 * Add multiple columns to the table, with no definition parameters (default definitions will be used if they are available, see useDefinitions).  Pass as many arguments as you there are columns you wish to add.
	 *
	 * @param   string   $col1   Name of column 1
	 * @param   string   $col2   Name of column 2
	 * @param   string   $coln   Name of column n
	 * @return  void
	 */
	function addColumns() {
		$arglist = func_get_args();
		foreach ($arglist as $arg) $this->addColumn($arg);
	}

	/**
	 * Returns the number of columns defined on the table
	 *
	 * @return  integer  Number of columns
	 */
	function getNumColumns() {
		return (sizeof($this->columns)+1);
	}

	/**
	 * Adds a filter field to the table.
	 * 
	 * While the Datatable does not filter its data, you can use the DataTable to generate an HTML form appropraite for use as a UI for stting filter values, which can then be used to determine what data to fetch and feed into the DataTable.  The second parameter to addFilter is an array of definiiton properties, any or all of which can be included in an associative array.  The available properties are:
	 * <dl>
	 * <dt>label</dt><dd>String, label to apply to the filter in the filter form</dd>
	 * <dt>type</dt><dd>String, type of filter: text, radio (not implemented), check, select</dd>
	 * <dt>options</dt><dd>Array, for check and select filters, specifies the list of options to display. Keys are used as the possible values of the filter, and the values are used to label the possible values.</dd>
	 * <dt>default</dt><dd>Mixed, default for the filter. For text, select and radio filters, a string giving the default value of the filter. For check filters, an array of keys from the options array to check or select by default.</dd>
	 * </dl>
	 *
	 * @param   string   $name   Name for the filter
	 * @param   array    $col2   Definition of the filter, using properties as described above.
	 * @return  void
	 */
	function addFilter($name, $definition=array()) {
		if (!is_array($definition)) trigger_error("Filter definition must be an array", E_USER_ERROR);
		if (empty($definition) and !empty($this->defaultdefs[$name])) $definition = $this->defaultdefs[$name];
		$this->filters[$name] = $definition;
		if (isset($definition["default"]) and $this->allowfilterdefaults) {
			$_SESSION["datatable"][$this->tablename]["filters"][$name] = $definition["default"];
		}
	}

	/**
	 * Adds lots of filters to the table
	 * 
	 * Add multiple filters to the table, with no definition parameters (default definitions will be used if they are available, see useDefinitions).  Pass as many arguments as you there are filters you wish to add.
	 *
	 * @param   string   $fil1   Name of filter 1
	 * @param   string   $fil2   Name of filter 2
	 * @param   string   $filn   Name of filter n
	 * @return  void
	 */
	function addFilters() {
		$arglist = func_get_args();
		foreach ($arglist as $arg) $this->addFilter($arg);
	}

	/**
	 * Set the default sort column of the table
	 * 
	 * Sets the default sort column of the table, which can be overridden by the user or by the session. Equivilent to setting primarysort=true on the column definition. Note that this does not actually sort any data - it simply indicates to the user that the table is being sorted by this column, and allows them to choose to sort the table differently if desired.  You have to feed the data into DataTable in an order that corresponds with the sort order you have indicated.  To get the current value of the user's sort preference, call getSortSQL().
	 *
	 * @param   string   $colname   Name of the column to sort by, by default
	 * @return  void
	 */
	function setDefaultSort($column) {
		foreach($this->columns as $col=>$params) {
			$this->columns[$col]["primarysort"] = ($col == $column) ? true : false;
		}
	}

	/**
	 * Fetch a MySQL-compatible ORDER BY string
	 * 
	 * Generate an SQL ORDER BY expression to sort the data retrieved from a database.
	 *
	 * @return  string  ORDER BY clause for your query
	 */
	function getSortSQL() {
		$s = isset($_SESSION["datatable"][$this->tablename]["sort"]) ? $_SESSION["datatable"][$this->tablename]["sort"] : false;
		if (!isset($s["col"]) or !array_key_exists($s["col"], $this->columns)) {
			foreach($this->columns as $col=>$params) {
				if (!empty($params["primarysort"])) {
					$s["col"] = $col;
					$s["dir"] = (!empty($params["sort"]) and ($params["sort"]=="ASC" or $params["sort"]=="DESC")) ? $params["sort"] : "ASC";
					break;
				}
			}
		}
		if (!empty($s)) {
			if (empty($s["dir"])) $s["dir"] = (!empty($this->columns[$s["col"]]["sort"])) ? $this->columns[$s["col"]]["sort"] : "ASC";
			$_SESSION["datatable"][$this->tablename]["sort"] = $s;
			$scol = $this->columns[$s["col"]];
			if (!isset($scol["sortable"]) or $scol["sortable"]) {
				return ((isset($scol["sortname"]))?$scol["sortname"]:$s["col"])." ".$s["dir"];
			} elseif (isset($scol["sortcallback"])) {
				return call_user_func($scol["sortcallback"], $s["dir"]);
			}
		}
		return "";
	}
	
	/**
	 * Return the name of the column wich is the current sort column
	 * 
	 * Returns the current sort column.  Retrieved from the session if available; otherwise returns the default sort column for the table if one is set.
	 *
	 * @return  string  Name of the current sort column
	 */
	function getSortColumn() {
		$s = isset($_SESSION['datatable'][$this->tablename]['sort']) ? $_SESSION['datatable'][$this->tablename]['sort'] : false;
		if (!$s or !isset($s['col']) or !array_key_exists($s['col'], $this->columns)) {
			foreach ($this->columns as $col=>$params) {
				if (!empty($params['primarysort'])) {
					if (!$s) $s = array();
					$s['col'] = $col;
					break;
				}
			}
		}
		return ($s) ? $s['col'] : false;
	}
	
	/**
	 * Returns the current sort direction
	 * 
	 * Returns the current sort direction of the table.  Retrieved from the session if available; otherwise returns the default sort order for the currently selected column/default sort column.
	 *
	 * @return  string  'ASC' or 'DESC'
	 */
	function getSortDir() {
		$s = isset($_SESSION['datatable'][$this->tablename]['sort']) ? $_SESSION['datatable'][$this->tablename]['sort'] : array();
		if (!isset($s['col'])) $s['col'] = $this->getSortColumn();
		if (!empty($s['col']) and !isset($s['dir'])) {
			$defaultsort = isset($this->columns[$s['col']]['sort'])?$this->columns[$s['col']]['sort']:false;
			$s['dir'] = ($defaultsort and ($defaultsort == 'ASC' or $defaultsort == 'DESC'))?$defaultsort:'ASC';
		}
		return (isset($s['dir'])) ? $s['dir'] : false;
	}		
	
	/**
	 * Returns the value of a specified filter field
	 * 
	 * Returns the current value of a specified table filter. Value may be returned as a string or an array depending on the type of filter - text, select and radio will return a string, while check will return an array (even if only one option is selected).
	 *
	 * @return  mixed  value of specified filter (may be the default value)
	 */
	function getFilterValue($ref) {
		if (array_key_exists($ref, $this->filters) and isset($_SESSION["datatable"][$this->tablename]["filters"][$ref])) {
			return $_SESSION["datatable"][$this->tablename]["filters"][$ref];
		} else {
			return false;
		}
	}
	
	/**
	 * Returns the values of all table filters
	 * 
	 * Returns the current value of all table filters. Values may be returned as a string or an array depending on the type of filter - text, select and radio will return a string, while check will return an array (even if only one option is selected). All will be returned in an associative array of filter keys and values.
	 *
	 * @return  array  Associative array of filter keys and values
	 */
	function getFilterValues() {
		$op = array();
		foreach ($this->filters as $key=>$params) {
			if (isset($_SESSION["datatable"][$this->tablename]["filters"][$key])) {
				$op[$key] = $_SESSION["datatable"][$this->tablename]["filters"][$key];
			} else {
				$op[$key] = null;
			}
		}
		return $op;
	}

	/**
	 * Set the value of a table filter
	 * 
	 * Sets the current value of a specified table filter.
	 *
	 * @param   string  $ref    Name of the filter to set
	 * @param   mixed  $value  Value to set the filter to (string or number for all filters except check, which should be an array of selected keys)
	 * @return  void
	 */
	function setFilterValue($ref, $value) {
		if (array_key_exists($ref, $this->filters)) {
			$_SESSION["datatable"][$this->tablename]["filters"][$ref] = $value;
		}
	}

	/**
	 * Returns the table name.
	 *
	 * @return  string  The table name
	 */
	function getTableName() {
		return $this->tablename;
	}

	/**
	 * Adds a footer row to the table. 
	 * 
	 * If this is called multiple times, then only the last specified values are used.
	 *
	 * @param   array  $values  A keyed array with keys corresponding to the column names in the table, and values containing the cell data for the footer.   Footers are output in a <<tfoot>> section, and can therefore be styled differently to ordinary rows, otherwise you could also simply add an extra row to the table.
	 * @return  void
	 */
	function addFooter($values) {
		$this->footer=array();
		foreach ($values as $col=>$value) {
			if (array_key_exists($col, $this->columns)) {
				$this->footer[$col] = $value;
			}
		}
	}

	/**
	 * Adds a row of data to the table
	 * 
	 * @param   array  $values  Array, a keyed array with keys corresponding to the column names in the table, and values containing the cell data.
	 * @param   string $rowkey  String, a key to associate with the row. Will be output in the row ID HTML attribute if useKeys() is set.
	 * @return  void
	 */
	function addRow($values, $key=false) {
		$nextrow = sizeof($this->data);
		foreach ($values as $col=>$value) {
			$this->data[(($key!==false)?$key:$nextrow)][$col] = $value;
		}
	}

	/**
	 * Adds lots of rows of data to the table
	 *
	 * // COMPLEX:RB:20080716: Note that columns are sometimes added to tables after data is added,
	 * // so that the code beneath should remain compatible with multiple orders of execution.
	 *
	 * Example:
	 * <code>
	 * $data = array();
	 * $data[] = array("key"=>1, "col1"=>"Apple", "col2"=>5);
	 * $data[] = array("key"=>12, "col1"=>"Banana", "col2"=>0);
	 * $data[] = array("key"=>5, "col1"=>"Carrot", "col2"=>7);
	 * $tb->addData($data, "key");
	 * </code>
	 *
	 * @param   array  $values       Array, an array of keyed arrays with keys corresponding to the column names in the table, and values containing the cell data. The keys in the outer array are read as row keys and included in the output markup if useKeys() is set.
	 * @param   string $overridekey  String, which, if specified, will be used find the key within the values array rather than use the array's key (see example). 
	 * @return  void
	 */
	function addData($rows, $overridekey=false) {
		if (is_array($rows) and sizeof($rows)) foreach ($rows as $key=>$row) $this->addRow($row,($overridekey)?$row[$overridekey]:$key);
	}

	/**
	 * Deletes all data from the table
	 *
	 * Removes all data added with addRow, addData and addFooter.  Does not clear filters or column definitions.
	 * 
	 * @return  void
	 */
	function clear() {
		$this->data = array();
		$this->footer = array();
	}

	/**
	 * Returns the number of rows currently assigned to the table
	 * 
	 * @return  integer  Number of rows in the table
	 */
	function getNumRows() {
		return sizeof($this->data);
	}
	
	/**
	 * Returns an XHTML representation of the table and filter controls, in an associative array suitable for passing as an argument to the template manager.
	 * 
	 * @return  array  An array containing two elements, 'content' and 'rightnav'
	 */
	function getOutput() {
		$sort = (isset($_SESSION["datatable"][$this->tablename]["sort"]))? $_SESSION["datatable"][$this->tablename]["sort"] : array();
		$fil = (isset($_SESSION["datatable"][$this->tablename]["filters"])) ? $_SESSION["datatable"][$this->tablename]["filters"] : array();
		$this->set("numcols", sizeof($this->columns));
		foreach ($this->columns as $colname=>$params) {
			$data = $params;
			$data["colname"] = $colname;
			if (sizeof($sort) and $sort["col"] == $colname) {
				if (!empty($sort["dir"])) {
					$data["sortclass"] = "sort".strtolower($sort["dir"]);
				} elseif (!empty($params["sort"])) {
					$data["sortclass"] = "sort".strtolower($params["sort"]);
					$_SESSION["datatable"][$this->tablename]["sort"]["dir"] = $params["sort"];
				} else {
					$data["sortclass"] = "sortasc";
					$_SESSION["datatable"][$this->tablename]["sort"]["dir"] = "ASC";
				}
			}
			$data["label"] = (isset($params["label"])) ? $params["label"] : ucwords($colname);
			if ($this->sortable and (!isset($params["sortable"]) or $params["sortable"])) {
				$data["sortablecol"] = true;
			}
			$data['checkselectall'] = !empty($params['checkselectall']);
			if (isset($params["columnclass"])) {
				$data["columnclass"] = $params["columnclass"];
			}
			$this->add("coldefs", $data);
		}
		$this->set("bodyrows", $this->generateRowHTML());
		$this->set("thisuri", $this->uri);
		$op = array("content"=>$this->render("table"));

		if (sizeof($this->filters)) {
			$op["rightnav"] = "<h3>Apply Filters</h3>";
			$op["rightnav"] .= '<form method="get" action="' . $this->uri . '" class="filters" name="filters">';
			$op["rightnav"] .= '<input type="hidden" name="fil_set" value="'.$this->tablename.'" />';
			foreach($this->filters as $name=>$params) {
				if (empty($params["type"])) $params["type"] = 'text';
				if (empty($params["label"])) $params["label"] = ucwords($name);
				if (!empty($params['options']) and !empty($params['sortoptions'])) {
					$sorter = empty($params['sortoptionscallback']) ? 'asort' : $params['sortoptionscallback'];
					$sorter($params['options']);
				}
				switch($params["type"]) {
					case "text":
					case "textarea":
					case "autocomplete":
					case "date":
					case "datetime":
					case "datetimeseconds":
					case "time":
					case "timeseconds":
					case "integer":
					case "float":
					case "colorpick":
					case "percent":
						$op["rightnav"] .= '<label id="'.$this->tablename.'_fillabel_'.$name.'" for="'.$this->tablename.'_fil_'.$name.'">'.((isset($params["label"]))?$params["label"]:$name).':</label><br /><input type="text" name="fil_'.$name.'" id="'.$this->tablename.'_fil_'.$name.'" value="'.((isset($fil[$name]))?htmlspecialchars($fil[$name], ENT_QUOTES, 'UTF-8'):'').'" /><br /><br />';
						break;
					case "radio":
						// TODO:AB:20060104
						break;
					case "check":
					case "boolean":
						if (empty($params["options"]) or !is_array($params["options"])) trigger_error("No options defined for check box list filter '".$name."'", E_USER_ERROR);
						$op["rightnav"] .= "<span class=\"filtergrouptitle\">".((isset($params["label"]))?$params["label"]:$name).":</span><br />";
						$i=1;
						foreach($params["options"] as $key=>$option) {
							if (is_array($option)) {
								$title = isset($option["helptext"])?htmlspecialchars($option["helptext"]):false;
								$option = $option["label"];
							} else {
								$title = false;
							}
							$op["rightnav"] .= "<input type=\"checkbox\" name=\"fil_".$name."[]\" id=\"".$this->tablename."_fil_".$name."_".(++$i)."\" value=\"".htmlspecialchars($key, ENT_QUOTES, 'UTF-8')."\"";
							if (isset($fil[$name]) and is_array($fil[$name]) and in_array($key, $fil[$name])) $op["rightnav"] .= " checked=\"checked\"";
							if (!empty($title)) $op["rightnav"] .= " title=\"".$title."\"";
							$op["rightnav"] .= "><label id=\"".$this->tablename."_fillabel_".$name."_".$i."\"".(empty($title)?"":" title=\"".$title."\"")." for=\"".$this->tablename."_fil_".$name."_".$i."\"".(empty($title)?"":" title=\"".$title."\"").">".htmlspecialchars($option, ENT_QUOTES, 'UTF-8')."</label><br />";
						}
						$op["rightnav"] .= "<br />";
						break;
					case "select":
					case "enum":
						if (empty($params["options"]) or !is_array($params["options"])) trigger_error("No options defined for select list filter '".$name."'", E_USER_ERROR);
						$op["rightnav"] .= '<label id="'.$this->tablename.'_fillabel_'.$name.'" for="'.$this->tablename.'_fil_'.$name.'">' . (($params["label"])?$params["label"]:$name) . ':</label><br /><select name="fil_'.$name.'" id="'.$this->tablename.'_fil_'.$name.'">';
						$op["rightnav"] .= '<option value=""></option>';
						foreach($params["options"] as $key=>$option) {
							$op["rightnav"] .= '<option value="'.htmlspecialchars($key, ENT_QUOTES, 'UTF-8').'"'.((isset($fil[$name]) and $key==$fil[$name] and (!empty($key) or is_numeric($fil[$name])))?" selected=\"selected\"":"").'>'.htmlspecialchars($option, ENT_QUOTES, 'UTF-8').'</option>';
						}
						$op["rightnav"] .= '</select><br /><br />';
						break;
				}
			}
			$op["rightnav"] .= '<span class="filteractions">';
			$op["rightnav"] .= '<input type="submit" name="fil_submit" value="Update" id="filtersubmit" class="button" />';
			$op["rightnav"] .= '<input type="submit" name="fil_submit" value="Reset" id="filterreset" class="button" style="margin-left: 5px;" />';
			$op["rightnav"] .= '</span></form>';
		}
		return $op;
	}

	/**
	 * Returns an XHTML representation of the body rows of the table
	 * 
	 * @return  string  HTML code
	 */
	function generateRowHTML() {
		$fil = (isset($_SESSION["datatable"][$this->tablename]["filters"])) ? $_SESSION["datatable"][$this->tablename]["filters"] : array();
		$cols = array_keys($this->columns);
		$htmlrows = "";
		if (sizeof($this->footer)) $this->data["footer"] = $this->footer;
		foreach($this->data as $rowkey => $row) {
			$rowtemplate = '<tr'.(($this->usekeys)?' id="'.$this->tablename.'_'.$rowkey.'" rowkey="'.$rowkey.'"':'').'>';
			foreach ($cols as $col) {
				if (array_key_exists($col, $row)) {
					$this->applyDisplayCallBacksAndModifiers($col, $row);
					if (isset($this->columns[$col]["highlightfilter"])) {
						if (array_key_exists($this->columns[$col]["highlightfilter"], $this->filters) and isset($fil[$this->columns[$col]["highlightfilter"]])) {
							$srhstr = $fil[$this->columns[$col]["highlightfilter"]];
							if (is_string($srhstr) and strlen($srhstr)) {
								$row[$col] = preg_replace("/(".preg_quote($srhstr, "/").")(?=[^>]*(<|$))/i", "<span class=\"srhhl\">$1</span>", $row[$col]);
							}
						}
					}
					$this->set("data".$col, $row[$col]);
				} else {
					$this->clearAssigned("data".$col);
				}
				if (isset($this->columns[$col]["align"])) $this->set("align".$col, $this->columns[$col]["align"]);
				$columnclass = (isset($this->columns[$col]["columnclass"])?$this->columns[$col]["columnclass"]:"");
				$rowtemplate .= '<td class=\''.$columnclass.'\' <!--@align'.$col.'|prepend:" style=\"text-align: ",append:"\""-->><!--@data'.$col;
				$rowtemplate .= "--></td>";
			}
			$rowtemplate .= '</tr>';
			if ($rowkey==="footer") {
				$this->add("footer", $this->renderFromString($rowtemplate));
			} else {
				$htmlrows .= $this->renderFromString($rowtemplate);
			}
		}
		return $htmlrows;
	}

	/**
	 * Returns a CSV representation of the data in the table
	 *
	 * Returns a CSV representation of the table data, including a header row using the label property of each column. Default CSV encoding is designed to be Microsoft-Excel friendly.
	 * 
	 * @param   string  $delim      Field separator (default is a comma)
	 * @param   string  $escape     Character to use to escape the enclose character (default is a backslash)
	 * @param   string  $lineend    Row separator (default is a newline)
	 * @param   string  $enclose    Character to use to enclose cell values (default is a double quote)
	 * @return  string              CSV data
	 */
	function outputCsv($delim=",", $escape="\\", $lineend="\n", $enclose="\"") {
		$opdata = array();
		foreach($this->columns as $colname=>$params) {
			$opdata[0][] = $params["label"];
		}
		if (sizeof($this->data)) {
			$cols = array_keys($this->columns);
			foreach($this->data as $row) {
				$thisrow = array();
				foreach ($cols as $col) {
					if (array_key_exists($col, $row)) {
						$this->applyDisplayCallBacksAndModifiers($col, $row);
					}
					$thisrow[] = ((isset($row[$col]))?$row[$col]:"");
				}
				$opdata[] = $thisrow;
			}
		}
		$op = "";
		foreach($opdata as $row) {
			if ($enclose) foreach($row as $colkey=>$col) $row[$colkey] = $enclose.str_replace($enclose, $escape.$enclose, $col).$enclose;
			$op .= join($delim, $row).$lineend;
		}
		return $op;
	}

	function setSpreadsheetSplitHorizontal($splithorizontal) {
		if (!($splithorizontal === false or is_numeric($splithorizontal))) return false;
		$this->xls_splithorizontal = $splithorizontal;
	}

	function setSpreadsheetSplitVertical($splitvertical) {
		if (!($splitvertical === false or is_numeric($splitvertical))) return false;
		$this->xls_splitvertical = $splitvertical;
	}

	function setSpreadsheetCustomTemplate($templatefile) {
		$this->xls_customtemplate = $templatefile;
	}

	/**
	 * Returns a Microsoft Excel format spreadsheet
	 *
	 * Returns a Microsoft Excel format spreadsheet containing the table data, including a header row using the label property of each column. The spreadsheets output are compatible with MS Excel 2002 and later.
	 *
	 * // TODO:AB:20100207: The prototype of this function does not match that documented in the Assanka Wiki - RS please update.
	 * 
	 * @return  string   Excel XML
	 */
	function outputXls() {

		// Set up spreadsheet
		$this->set("worksheetname", $this->tablename);

		// Define basic cell styles
		$this->add("customstyles", array("id"=>"tableheader_rightalign", "horizalign"=>"Right", "bold"=>true));
		$this->add("customstyles", array("id"=>"tableheader_leftalign", "horizalign"=>"Left", "bold"=>true));
		$this->add("customstyles", array("id"=>"datacell", "borders"=>true, "bordertop"=>true, "borderright"=>true, "borderbottom"=>true, "borderleft"=>true));

		// Add row of cells containing column headers
		$row["cells"] = "";
		foreach ($this->columns as $colname=>$params) {
			$this->set("styleid", "tableheader".((!empty($params["align"]) and $params["align"] == "right")?"_rightalign":"_leftalign"));
			$this->set("data", $params["label"]);
			$row["cells"] .= $this->render("excelspreadsheet-cell");
		}
		$this->add("rows", $row);

		// Add cells containing actual data
		foreach ($this->data as $row) {
			$row["cells"] = "";
			foreach ($this->columns as $colname=>$params) {

				$this->clearAssigned("data");
				if (array_key_exists($colname, $row)) {

					$data = $row[$colname];
					if ((!empty($params["type"]) and (in_array($params["type"], array("number", "float"))) and is_numeric($data)) or (!empty($params["type"]) and ($params["type"] == "hidden" and is_numeric($data)))) {
						$this->set("datatype", "Number");
					} else {
						$this->set("datatype", "String");
						$this->applyDisplayCallBacksAndModifiers($colname, $row);
					}

					// Only send data to template manager if it is not an empty string
					// as otherwise the template manager will produce markup that
					// breaks the Excel XML parser (empty data cells must self-close)
					if (!empty($data) or $data === 0) {
						$this->set("data", $data);
					}
				}

				$this->set("styleid", "datacell");
				$row["cells"] .= $this->render("excelspreadsheet-cell");
			}
			$this->add("rows", $row);
		}

		// Freeze Panes
		if ($this->xls_splithorizontal or $this->xls_splitvertical) {
			$this->set("freezepanes", true);
			$this->set("splithorizontal", ($this->xls_splithorizontal?$this->xls_splithorizontal:1));
			$this->set("splitvertical", ($this->xls_splitvertical?$this->xls_splitvertical:1));
		}

		// Return XML
		return $this->render($this->xls_customtemplate?$this->xls_customtemplate:"excelspreadsheet");
	}


	// Function for use when generating output for CSV, XLS, or HTML datatable
	function applyDisplayCallbacksAndModifiers(&$col, &$row) {
		if (isset($this->columns[$col]["displaycallback"])) {
			$row[$col] = call_user_func($this->columns[$col]["displaycallback"], $col, $row);
		}
		if (isset($this->columns[$col]["displaymodifiers"])) {
			$this->set("data", $row[$col]);
			$row[$col] = $this->renderFromString("<!--@data|".$this->columns[$col]["displaymodifiers"]."-->");
			$this->clearAssigned("data");
		}
	}
}

if (!class_exists('Datatable')) class_alias('DatatableV2', 'Datatable');
