<?php
/**
 * Generic object class - provides access to databases and variable population
 *
 * This is an abstract class - you must define a subclass in order
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once $_SERVER['CORE_PATH']."/helpers/validator/v2/validator";
require_once $_SERVER['CORE_PATH']."/helpers/orm/v2/OrmBase";
require_once $_SERVER['CORE_PATH']."/helpers/errorhandler/v5/exception";

abstract class OrmActiveRecord extends OrmBase implements ArrayAccess, Iterator, Countable {

	protected $data = array(), $rels = array(), $junctions = array(), $haschanged = 0, $existsindb = 0;
	protected static $fields = array(), $links = array(), $keyfields = array(), $tablename, $iscacheable = true, $objectcachingenabled = true, $memcachecachingenabled = true, $projname = 'generic';
	private static $objectcache;

	const MEMCACHE_TTL = 60;

	/**
	 * Construct a new object
	 *
	 * Objects can be instantiated in a number of ways:
	 * 1. Create a new empty object, not in DB: $x = new Thing();
	 * 2. Create a pre-populated new object, not in DB: $x = new Thing($data); (will error if you provide a primary key)
	 * 3. Create an object from an existing DB record: $x = new Thing($row, false, true) (BUT: don't do this, use createFromKey instead)
	 * 4. Create an object from a modified DB record: $x = new Thing($row, true, true) (consider createFromKey then editing instead)
	 *
	 * @param array   $vars       Associative array of data with with to populate the new object.  Keys must match those defined in the static $fields array
	 * @param boolean $haschanged Whether the object should consider itself to be different to its stored representation in the database.  Has no effect if the object is not populated in full including a primary key value
	 * @param boolean $existsindb Whether the object exists in the database.  Default false, if left to or set to false, and a primary key field is included in $vars, an exception will be thrown.
	 * @return OrmActiveRecord
	 */
	public function __construct($vars = array(), $haschanged = true, $existsindb = false) {
		if (!self::dbread() or !self::dbwrite()) throw new InternalException('No database connectors found');
		if (!is_array(static::$fields) or !count(static::$fields)) throw new InternalException('No fields defined');
		if (!is_array(static::$keyfields) or !count(static::$keyfields)) throw new InternalException('No key fields defined');
		if (!is_string(static::$tablename) or empty(static::$tablename)) throw new InternalException('No table name defined');

		foreach (static::$fields as $key=>$def) {
			if (empty($def['type'])) $this->fields[$key]['type'] = 'text';
		}

		$this->haschanged = $haschanged;
		$this->existsindb = $existsindb;

		if (is_array($vars)) {
			$this->populate($vars);
		} elseif (!empty($vars)) {
			 throw new InvalidCallException('Object constructor input must be an array');
		}

		if ($this->existsindb) {
			foreach (static::$keyfields as $field) {
				if (!isset($this->data[$field])) throw new InvalidCallException('Cannot create an object that exists in the database without all key fields defined');
			}
		}
	}

	/**
	 * Get a property of the object
	 *
	 * Properties of an object can be read in a number of ways:
	 * 1. Using the explicit get method: $x->get('property');  (This method)
	 * 2. Using the magic get method: $x->property
	 * 3. Using ArrayAccess: $x['property']
	 * 4. Via the getProperties method: $x->getProperties();
	 *
	 * @param string $field The key of the field whose value should be returned.
	 * @return mixed The value of the property.  If the key does not exist, null will be returned (null will also be returned if the value of the property is null)
	 */
	protected function get($field) {
		return (isset($this->data[$field])) ? $this->data[$field] : null;
	}

	/**
	 * Get a property of the object
	 *
	 * Properties of an object can be read in a number of ways:
	 * 1. Using the explicit get method: $x->get('property');
	 * 2. Using the magic get method: $x->property  (This method)
	 * 3. Using ArrayAccess: $x['property']
	 * 4. Via the getProperties method: $x->getProperties();
	 *
	 * The magic get method will also allow access to properties set using the magic set method, which are not defined fields in the object's database table mapping ($fields).  This permits literal properties to be set and read without causing errors (the Assanka error handler, for example, relies on the ability to set an arbitrary property of an object in order to resolve references)
	 *
	 * @param string $field The key of the field whose value should be returned.
	 * @return mixed The value of the property.  If the key does not exist, null will be returned (null will also be returned if the value of the property is null)
	 */
	public function __get($field) {
		return (isset($this->data[$field])) ? $this->data[$field] : (isset($this->$field) ? $this->field : null);
	}

	/**
	 * Get all properties of the object
	 *
	 * Properties of an object can be read in a number of ways:
	 * 1. Using the explicit get method: $x->get('property');
	 * 2. Using the magic get method: $x->property
	 * 3. Using ArrayAccess: $x['property']
	 * 4. Via the getProperties method: $x->getProperties();   (This method)
	 *
	 * @return array An associative array of all known properties of the object
	 */
	public function getProperties() {
		return $this->data;
	}

	/**
	 * Set the value of a property
	 *
	 * This is a magic method, which can be invoked as if the property is predefined in the class, eg $x->property = "new value";  Doing so will call the __set method automatically, and is equivilent to $x->edit(array('property'=>'new value')) for properties that are defined in $fields.  Setting a property that is not defined in $fields will set the property as a direct object property.  You can set any arbitrary property of an ORM object, and it will not attempt to write it to the database or do anything with it other than make it available for reading via this method's sister magic get method.  This is useful in that most objects in PHP allow arbitrary properties to be manipulated publicly, so this matches that expected behaviour (the Assanka error handler, for example, relies on the ability to set an arbitrary property of an object in order to resolve references)
	 *
	 * @param string $field The name of the field key
	 * @param mixed  $value The value to set on the property
	 * @return void
	 */
	public function __set($field, $value) {
		if (!isset(static::$fields[$field])) {
			$this->$field = $value;
		} else {
			$this->edit(array($field=>$value));
		}
	}

	/**
	 * Return true if a proposed edit would succeed, or an array of errors if it would not.
	 *
	 * The edits are validated against the provided (or built in) field definitions, and do NOT include checking for required fields (which allows validateEdit to be used on partial edits, eg proposing an edit to a single field).  When the object is saved with save(), required fields will be checked.
	 *
	 * @param array $vars An associative array of data which is proposed for addition to the object's properties
	 * @param array $defs An array of fields, in field definition format, which should define the fields for which edited data is provided in $vars.  If not supplied, will use the definitions from the class's $fields array.
	 * @return mixed True if the edit would succeed, or an associative array of field keys to error strings if it would fail.
	 */
	public function validateEdit($vars, $defs = false) {
		$errors = array();
		if (!$defs or !is_array($defs)) $defs = static::$fields;

		// Allow callbacks back to this object
		foreach ($defs as &$cbdef) if (isset($cbdef['validationcallback']) and is_array($cbdef['validationcallback']) and $cbdef['validationcallback'][0] == 'self') $cbdef['validationcallback'][0] = $this;
		foreach ($vars as $key=>$val) {
			if (!isset($defs[$key]) or $vars[$key] === '' or $vars[$key] === null) continue;
			if ($invalidmsg = Validator::checkField($val, $defs[$key])) $errors[$key] = $invalidmsg;
		}
		foreach ($defs as $key=>$def) {
			$boolallowed = in_array($def['type'], array("check", "boolean"));
			if (!empty($def['required']) and (!isset($this->data[$key]) or (is_bool($this->data[$key]) and !$boolallowed) or $this->data[$key] === '') and (!isset($vars[$key]) or (is_bool($vars[$key]) and !$boolallowed) or $vars[$key] === '')) {
				$errors[$key] = "This field is required";
			}
		}
		return $errors ? $errors : true;
	}

	/**
	 * Edit one or more properties of an object
	 *
	 * @param array   $vars         An associative array of data to merge into the object's properties
	 * @param boolean $allowprivate Whether to allow properties defined private in the $fields array to be edited.  It is recommended that if the edit() method is publicly exposed by the subclass, it provides only the $vars parameter, and sets this parameter to false in passing the call through to the parent.
	 * @return void
	 */
	protected function _edit($vars, $allowprivate = false) {
		foreach ($vars as $key=>$val) {
			if (!isset(static::$fields[$key])) {
				throw new InvalidCallException('Unknown key', 0, null, $key);
			}
			if (!$allowprivate and isset(static::$fields[$key]['visibility']) and static::$fields[$key]['visibility'] == 'private') {
				throw new InvalidCallException('Cannot set value of private key', 0, null, $key);
			}
			if ($this->existsindb and in_array($key, static::$keyfields)) {
				trigger_error('Unwise to change the value of a key field once saved to DB.  Consider creating a new object instead', E_USER_NOTICE);
			}
			if (!empty($val) and $invalidmsg = Validator::checkField($val, static::$fields[$key])) {
				throw new UserInputException($invalidmsg, 0, null, get_defined_vars());
			}
			$vars[$key] = Validator::normalise($val, static::$fields[$key]);
			if (isset($this->data[$key]) and $this->data[$key] === $vars[$key]) unset($vars[$key]);
		}
		if (count($vars)) {
			$this->haschanged = 1;
			$this->populate($vars);
		}
	}

	/**
	 * Edit one or more public properties of an object
	 *
	 * This method must be overridden in the subclass in order to be exposed on the public interface of your object
	 *
	 * @param array $vars An associative array of data to merge into the object's properties
	 * @return void
	 */
	protected function edit($vars) {
		return $this->_edit($vars);
	}

	/**
	 * Link another OrmActiveRecord object of a different class to the current object, via a foreign key relationship
	 *
	 * Allows objects to be related via a declared link in the $links array of the subclass.  For has-one relationships, will extract the primary key of the target and update the object's foreign key property for that link appropriately.  For has-many relationships, will apply the object's primary key to the target's foreign key property.  For junction relationships, will add a row to the appropriate junction table containing the primary keys of both objects.
	 *
	 * Note that no database changes are effected until the objects are saved.  Junction rows are written when the linking object is saved (not when the link target object is saved)
	 *
	 * This method is protected and it is recommended that it is not exposed publicly by the subclass.  Instead, expose more semantic methods, eg. for a has-one relationship, setAuthor($authorobj), which then calls parent::link('author', $authorobj).  The prefix 'set' is appropriate since setting an author would remove any existing author.  For a has-many or junction, an example would be $author->addPost($postobj), but the parent call would follow exactly the same principle.  In a has-many or junction relationship an 'add' prefix is more suitable because the target will be linked to the object without removing links to other targets of the same type (ie an author can have more than one post - adding another post to the author doesn't change the fact that they wrote other posts already attached to them).   Remember that the other end of a has-many is a has-one, so calling the example addPost method won't remove existing posts written by the author, but will remove another author currently assigned to the post.  In has-many relationships, you may therfore want to be a bit more creative, eg $author->assignPost();  Junctions should more consistently use the 'add' prefix.
	 *
	 * @param string          $linkname The name of the link
	 * @param OrmActiveRecord $obj      The object to link (must be of the correct subclass for the specified link name)
	 * @return void
	 */
	protected function link($linkname, $obj) {
		$this->checkLinkArgs($linkname, $obj);
		if (static::$links[$linkname]['rel'] == 'hasone') {
			foreach (static::$links[$linkname]['fieldmap'] as $origfield => $destfield) {
				if (!$obj->get($destfield)) throw new InvalidCallException("Key required to create link", 0, null, get_defined_vars());
				if (!$obj->existsInDb()) throw new InvalidCallException("Can't link to an object which is not in the database", 0, null, get_defined_vars());
				$this->_edit(array($origfield=>$obj->get($destfield)), true);
			}
		} elseif (static::$links[$linkname]['rel'] == 'hasmany') {
			if (!$this->existsInDb()) throw new InvalidCallException("Can't create a hasmany relationship from an object which is not in the database", 0, null, get_defined_vars());
			$obj->link(static::$links[$linkname]['destlink'], $this);
		} elseif (static::$links[$linkname]['rel'] == 'junction') {
			if (!$obj->existsInDb()) throw new InvalidCallException("Can't link to an object which is not in the database", 0, null, get_defined_vars());
			$keymap = array();
			foreach (static::$links[$linkname]['destmap'] as $junctionfield => $destfield) {
				if (!$obj->get($destfield)) throw new InvalidCallException("Key required to create link", 0, null, get_defined_vars());
				$keys[] = $obj->get($destfield);
			}
			$keystr = join("-", $keys);
			if (!isset($this->junctions[$linkname])) $this->junctions[$linkname] = array();
			$this->junctions[$linkname][$keystr] = array('action'=>'add', 'obj'=>$obj);
		}
	}

	/**
	 * Remove a link between the object and a specified target object
	 *
	 * See link() for further details of linking.  unlink() simply removes a link that has been created with link(), and takes the same parameters.  As with link(), it is protected and should not be exposed by the subclass, but instead used to create semantic shortcut methods, such as removeAuthor(), removePost().
	 *
	 * If the object is not linked to the target, the method will do nothing and will not throw an exception
	 *
	 * @param string          $linkname The name of the link
	 * @param OrmActiveRecord $obj      The object to unlink (must be of the correct subclass for the specified link name)
	 * @return void
	 */
	protected function unlink($linkname, $obj) {
		$this->checkLinkArgs($linkname, $obj);
		if (static::$links[$linkname]['rel'] == 'hasone') {
			foreach (static::$links[$linkname]['fieldmap'] as $origfield => $destfield) {
				$this->_edit(array($origfield=>null), true);
			}
		} elseif (static::$links[$linkname]['rel'] == 'hasmany') {
			$obj->unlink(static::$links[$linkname]['destlink'], $this);
		} elseif (static::$links[$linkname]['rel'] == 'junction') {
			$keymap = array();
			foreach (static::$links[$linkname]['destmap'] as $junctionfield => $destfield) {
				$keys[$junctionfield] = $obj->get($destfield);
			}
			$keystr = join("-", $keys);
			if (!isset($this->junctions[$linkname])) $this->junctions[$linkname] = array();
			$this->junctions[$linkname][$keystr] = array('action'=>'remove', 'obj'=>$obj);
		}
	}

	/**
	 * Remove a link between the object and all linked objects on a specified link name
	 *
	 * For has-many and junction relationships, unlinkAll() removes links to all objects sharing the same link name, so if an author has many posts, unlinkAll('posts') would remove all the posts from the author, equivilent to calling unlink() for each post object individually (but much more efficient).  For has-one relationships, removes a maximum of one linked object, however, this may still be worth using over unlink(), since the target object need not be specified.
	 *
	 * If the object is not linked to any others via the specified link, the method will do nothing and will not throw an exception
	 *
	 * @param string $linkname The name of the link
	 * @return void
	 */
	protected function unlinkAll($linkname) {
		$this->checkLinkArgs($linkname);
		if (static::$links[$linkname]['rel'] == 'hasone') {
			foreach (static::$links[$linkname]['fieldmap'] as $origfield => $destfield) {
				$this->_edit(array($origfield=>null), true);
			}
		} else {
			foreach ($this->getRelations($linkname) as $obj) {
				$this->unlink($linkname, $obj);
			}
		}
	}

	/**
	 * Returns the object or objects linked to the current object via the specified linkname
	 *
	 * It is recommended that this protected method is not exposed publicly by the subclass, but instead is used to create semantic method names, such as getPosts for an Author class, eg $author->getPosts(), which would call parent::_getRelations('posts');
	 *
	 * @param string $linkname The name of the link
	 * @return mixed For has-one relationships, returns either an object or null.  For has-many and junction relationships, returns an array (which may be empty)
	 */
	protected function getRelations($linkname) {
		$this->checkLinkArgs($linkname);
		if (static::$links[$linkname]['rel'] == 'hasone') {
			$keys = array();
			foreach (static::$links[$linkname]['fieldmap'] as $origfield => $destfield) {
				if ($this->get($origfield) === null or $this->get($origfield) === false) return null;
				$keys[$destfield] = $this->get($origfield);
			}
			$class = static::$links[$linkname]['destclass'];
			return $class::createFromKey($keys);

		} elseif (static::$links[$linkname]['rel'] == 'hasmany') {
			$class = static::$links[$linkname]['destclass'];
			$destlink = $class::$links[static::$links[$linkname]['destlink']];
			$criteria = array();
			foreach ($destlink['fieldmap'] as $destfield => $origfield) {
				$criteria[$destfield] = $this->get($origfield);
			}
			return $class::search($criteria);

		} elseif (static::$links[$linkname]['rel'] == 'junction') {
			$class = static::$links[$linkname]['destclass'];
			$criteria = $keymap = $keydata = $results = array();
			foreach (static::$links[$linkname]['originmap'] as $junctionfield => $origfield) {
				$criteria[$junctionfield] = self::sqlPlaceholder($junctionfield, true);
				$keydata[$junctionfield] = $this->get($origfield);
			}
			foreach (static::$links[$linkname]['destmap'] as $junctionfield => $destfield) {
				$keymap[$junctionfield] = $destfield;
			}
			$res = self::dbread()->query("SELECT * FROM ".static::$links[$linkname]['table']." WHERE ".join(" AND ", $criteria), $keydata);
			foreach ($res as $row) {
				$keys = array();
				foreach ($keymap as $junctionfield => $destfield) {
					$keys[$destfield] = $row[$junctionfield];
				}
				$keystr = join("-", $keys);
				$obj = $class::createFromKey($keys);
				if ($obj) $results[$keystr] = $obj;
			}

			// Modify results to add/remove unsaved junction changes
			if (!empty($this->junctions[$linkname])) {
				foreach ($this->junctions[$linkname] as $keystr => $item) {
					if ($item['action'] == 'add') $results[$keystr] = $item['obj'];
					elseif (isset($results[$keystr])) unset($results[$keystr]);
				}
			}
			return $results;
		}
	}

	/**
	 * Deletes the object
	 *
	 * Deletes the object from the database and unlinks all associated objects to maintain foreign key integrity.  Deletion is done immediately - does not require caling save().  After the deletion, the object will still contain all the properties it had prior to the deletion but will have it's primary key fields set to null.  If saved after the deletion, the object will need a new primary key (which may be allocated automatically by the database if it's an autoincrement column).
	 *
	 * @return void
	 */
	protected function delete() {
		$criteria = array();
		foreach (static::$keyfields as $key) {
			if (!isset($this->data[$key])) throw new InvalidCallException('Primary key is not set');
			$criteria[$key] = self::sqlPlaceholder($key, true);
		}

		// Automatically break junction links.  No need to break hasone links since they will be broken by deleting the record anyway.  Could, but will not, delete hasmany relationships, so following the delete there may be other entities with an orphaned hasone relationship to the deleted record.  If data integity must be enforced on these links, it can be done with an 'on delete cascade' config in MySQL.
		foreach (static::$links as $linkname=>$link) {
			if ($link['rel'] == 'junction') $this->unlinkAll($linkname);
		}

		// Save object in order to delete the junction table rows
		$this->save();

		self::dbwrite()->query("DELETE FROM ".static::$tablename." WHERE ".join(" AND ", $criteria), $this->data);
		$this->removeFromCache();
		foreach (static::$keyfields as $key) unset($this->data[$key]);
	}

	/**
	 * Normalises data and sets new properties on the object
	 *
	 * Using the definitons from the $fields array, normalises inputs and assigns the normalised values to the object's database mapped properties.  Dates are normalised to unix timestamps.
	 *
	 * Should not be made public by the subclass, and should be used sparingly - this method is mainly intended for internal use in the parent class, but there are use cases where it is necessary to call it from the subclass.
	 *
	 * @param array $vars The data to merge into the object
	 * @return void
	 */
	protected function populate($vars) {
		$targetkeys = array_keys(static::$fields);
		foreach ($vars as $key=>$val) if (in_array($key, $targetkeys)) {
			$val = Validator::normalise($val, static::$fields[$key]);
			$this->data[$key] = $val;
		}
	}

	/**
	 * Saves the object to the database
	 *
	 * Writes the object's properties to a database row, either updating or inserting as appropriate.  If the database assigns an ID from an autoincrement column as a result of the write operation, the new ID will be assigned to the object's primary key field.  Also saves any pending relationship changes.
	 *
	 * If the object hasn't changed since it was populated from the database, no queries will be made.
	 *
	 * @return void
	 */
	protected function save() {
		if (!$this->hasChanged() and empty($this->junctions)) return false;
		if ($this->hasChanged()) {
			$countkeysset = 0;
			$updates = array();
			foreach (static::$fields as $key=>$def) {
				if (!empty($def['required']) and !isset($this->data[$key])) throw new InvalidCallException('Required data '.$key.' missing', 0, null, $this->data);
				if (array_key_exists($key, $this->data)) {
					$updates[$key] = self::sqlPlaceholder($key);
					if (in_array($key, static::$keyfields) and isset($this->data[$key])) {
						$keyfieldcriteria[$key] = self::sqlPlaceholder($key, true);
						$countkeysset++;
					}
				}
			}
			if ($countkeysset and $countkeysset != count(static::$keyfields)) throw new InvalidCallException('Partial primary key', 0, null, $this->data);
			if ($countkeysset and $this->existsindb) {
				if (count($updates)) $res = self::dbwrite()->query("UPDATE ".static::$tablename." SET ".join(", ", $updates)." WHERE ".join(" AND ", $keyfieldcriteria), $this->data);
				else $res = null;
			} else {
				$query_set = (count($updates)) ? " SET ".join(", ", $updates) : "() VALUES()";
				try {
					$res = self::dbwrite()->query("INSERT INTO ".static::$tablename.$query_set, $this->data);
				} catch (AssankaException $e) {
					if (preg_match('/^Duplicate entry/', $e->getMessage())) throw new InvalidCallException('Key already exists', 0, $e, $query_set);
					else throw $e;
				}
			}
			if (count(static::$keyfields) == 1 and !$countkeysset and $res and $id = $res->getInsertId()) {
				$this->data[reset(static::$keyfields)] = $id;
			}

			$this->haschanged = false;
			$this->existsindb = true;
		}
		if (!empty($this->junctions)) {
			foreach ($this->junctions as $linkname=>$items) {
				$class = static::$links[$linkname]['destclass'];
				foreach ($items as $item) {
					$keymap = $keys = $sql = array();
					foreach (static::$links[$linkname]['destmap'] as $junctionfield => $destfield) {
						$keys[$junctionfield] = $item['obj']->get($destfield);
						$sql[] = self::sqlPlaceholder($junctionfield, $item['action'] != 'add');
					}
					foreach (static::$links[$linkname]['originmap'] as $junctionfield => $origfield) {
						$keys[$junctionfield] = $this->get($origfield);
						$sql[] = self::sqlPlaceholder($junctionfield, $item['action'] != 'add');
					}
					if ($item['action'] == 'add') {
						$datefieldsql = empty(static::$links[$linkname]['datefield']) ? '' : ', '.static::$links[$linkname]['datefield'].'=NOW()';
						self::dbwrite()->query("INSERT IGNORE INTO ".static::$links[$linkname]['table']." SET ".join(", ", $sql).$datefieldsql, $keys);
					} else {
						self::dbwrite()->query("DELETE FROM ".static::$links[$linkname]['table']." WHERE ".join(" AND ", $sql), $keys);
					}
				}
			}
			$this->junctions = array();
		}
		$this->writeToCache();
		return true;
	}

	/**
	 * Sets a default value for a database-mapped property
	 *
	 * Where the object is saved without setting a value in a specified field, the field will be set to the specified value automatically.
	 *
	 * @param string $key   Field key on which to specify the default
	 * @param mixed  $value Value to set if no value is already set when save() is called
	 * @return void
	 */
	protected function setDefault($key, $value) {
		if (!isset($this->data[$key])) $this->data[$key] = $value;
	}

	/**
	 * Returns true if the object has changed relative to it's representation in the database
	 *
	 * @return boolean
	 */
	public function hasChanged() {
		return (bool)$this->haschanged;
	}

	/**
	 * Returns true if the object is in the database
	 *
	 * @return boolean
	 */
	public function existsInDb() {
		return (bool)$this->existsindb;
	}

	/**
	 * Writes the current state of the object to memcache.
	 *
	 * Used internally by OrmActiveRecord and called automatically on any save operation.  Should be called again by the subclass if any post-save changes are made to the object in the subclass's save method.  Can also be called publicly.
	 *
	 * @return void
	 */
	public function writeToCache() {
		if (!static::$iscacheable) return;
		$cachekey = $this->getCacheKey();
		if (static::$objectcachingenabled) self::$objectcache[$cachekey] = $this;
		if (static::$memcachecachingenabled) self::getMemcache()->set($cachekey, $this, self::MEMCACHE_TTL);
	}

	/**
	 * Remove the object from Memcache
	 *
	 * @return void
	 */
	protected function removeFromCache() {
		$cachekey = $this->getCacheKey();
		unset(self::$objectcache[$cachekey]);
		self::getMemcache()->delete($cachekey);
	}

	/**
	 * Returns the key used to reference the object in memcache
	 *
	 * @return string
	 */
	protected function getCacheKey() {
		$class = get_called_class();
		$keys = array();
		foreach (static::$keyfields as $field) {
			if (!isset($this->data[$field])) return false;
			$val = $this->get($field);
			if (is_numeric($val)) $keys[$field] = $val;
			else $keys[$field] = md5($val);
		}
		ksort($keys);
		return 'ORM/'.self::$projname.'/'.$class.'/'.join('-', $keys);
	}


	/* Private methods */

	/**
	 * Check arguments for a link related operation
	 *
	 * Link related operations (link, unlink, unlinkAll, getRelations) take a link name and (mostly) an object as parameters.  This method checks that the specified link exists within the object's $links array, and if an object is supplied, that it is of the type expected by that link.  Does not return anything, but throws exceptions on error.
	 *
	 * @param string          $linkname The name of the link to check
	 * @param OrmActiveRecord $obj      Target object
	 * @return void
	 */
	private function checkLinkArgs($linkname, $obj=null) {
		if (empty(static::$links[$linkname]['destclass'])) throw new InvalidCallException('Specified link name does not exist');
		if ($obj !== null) {
			if (!is_object($obj)) throw new InvalidCallException('Object expected');
			$classname = get_class($obj);
			if (strtolower(static::$links[$linkname]['destclass']) != strtolower($classname)) throw new InvalidCallException('Object is not of the expected class');
		}
	}


	/* Implementation of ArrayAccess */

	public function offsetExists($offset) { return isset($this->data[$offset]); }
	public function offsetGet($offset) { return $this->get($offset); }
	public function offsetSet($offset, $value) { $this->edit(array($offset=>$value)); }
	public function offsetUnset($offset) { $this->edit(array($offset=>null)); }


	/* Implementation of Iterator */

	protected $currentkey;
	public function current() { return ($this->valid()) ? $this->data[$this->currentkey] : null; }
	public function key() { return $this->currentkey; }
	public function valid() { return array_key_exists($this->currentkey, $this->data); }
	public function next() {
		next($this->data);
		$this->currentkey = key($this->data);
		return $this->current();
	}
	public function rewind() {
		reset($this->data);
		$this->currentkey = key($this->data);
	}


	/* Implementation of Countable */

	public function count() { return count($this->data); }




	/* Static methods */

	/**
	 * Instantiate an instance of the object by looking up a record based on a primary key
	 *
	 * Shortcut for $x = Object::find(array("id"=>34));  If an object with the specified primary key exists in the database, it's record is fetched and it's object is returned.  If it does not exist, null is returned.  May not trigger a database query if the object is available in memcache.
	 *
	 * To find records by a field that is not the primary key, see search().
	 *
	 * @param mixed $id Value of the primary key for the record to load, normally an integer.  If object has a combination key, an associative array should be passed with an element for each of the fields comprising the key
	 * @return OrmActiveRecord
	 */
	public static function createFromKey($id) {
		$class = get_called_class();
		if (empty(static::$keyfields)) throw new InvalidCallException('No primary key configured');
		if (is_array($id) and count(static::$keyfields) != count($id)) throw new InvalidCallException('Incorrect key count');
		if (!is_array($id) and count(static::$keyfields) > 1) throw new InvalidCallException('Scalar key given where array key required');
		$keys = (is_array($id)) ? $id : array(reset(static::$keyfields)=>$id);
		ksort($keys);
		$hashedkeys = array();
		foreach ($keys as $key => $val) {
			if (is_numeric($val)) $hashedkeys[$key] = $val;
			else $hashedkeys[$key] = md5($val);
		}
		$cachekey = 'ORM/'.self::$projname.'/'.$class.'/'.join('-', $hashedkeys);
		if (static::$iscacheable and static::$objectcachingenabled and isset(self::$objectcache[$cachekey])) {
			return self::$objectcache[$cachekey];
		} elseif (static::$iscacheable and static::$memcachecachingenabled and $obj = self::getMemcache()->get($cachekey)) {
			return self::$objectcache[$cachekey] = $obj;
		} else {
			$criteria = array();
			foreach (static::$keyfields as $field) {
				if (array_key_exists($field, $keys)) $criteria[$field] = self::sqlPlaceholder($field, true);
			}
			$data = self::dbread()->queryRow("SELECT * FROM ".static::$tablename." WHERE ".join(" AND ", $criteria), $keys);
			if (!$data) return null;
			$obj = new $class($data, false, true);
			$obj->writeToCache();
			return $obj;
		}
	}

	/**
	 * Return a list of objects with the specified primary key values
	 *
	 * @param array $keylist List of keys suitable for passing to createFromKey
	 * @return array A list of matching objects
	 */
	public static function createFromKeys($keylist) {
		$results = array();
		foreach ($keylist as $keys) {
			$keystr = is_array($keys) ? join("-", $keys) : $keys;
			$obj = self::createFromKey($keys);
			if ($obj) $results[$keystr] = $obj;
		}
		return $results;
	}

	/**
	 * Return a list of objects matching specified criteria
	 *
	 * Searches the database with an SQL WHERE expression based on equality tests on each of the fields included in the $criteria array.  Returns an array, which may be empty if no records match the criteria.  For example, $users = User::search(array('firstname'=>'Joe', 'surname'=>'Blogs')) will return an array containing a User object for each user that has a firstname equal to Joe and a surname equal to Blogs.
	 *
	 * This method is not suitable for finding records based on complex SQL expressions (ie anything other than a series of ANDed equality tests).  For that, use sqlSearch().
	 *
	 * @param array  $criteria Associative array of fields and values to constrain the search on the database table
	 * @param string $limit    The limit to apply to the SQL statement in the format {offset},{limit}
	 * @return array A list of matching objects
	 */
	public static function search(array $criteria, $limit="0,999999999") {
		$sql = $vals = array();
		foreach ($criteria as $key=>$val) {
			if (isset(static::$fields[$key])) {
				$sql[$key] = self::sqlPlaceholder($key, true);
				$vals[$key] = $val;
			} elseif (isset(static::$links[$key])) {
				if (static::$links[$key]['rel'] == 'hasone') {
					foreach (static::$links[$key]['fieldmap'] as $origfield => $destfield) {
						$sql[$origfield] = self::sqlPlaceholder($key);
						$vals[$origfield] = $val->get($destfield);
					}
				} elseif (static::$links[$key]['rel'] == 'hasmany') {
					throw new InvalidCallException('Searching a hasmany relationship is not supported.  Follow the hasone relationship from the other end');
				} else {
					throw new InvalidCallException('Searching a junction relationship is not supported.  Implement a custom method to do this');
				}
			} else {
				throw new InvalidCallException('Unknown key', 0, null, $key);
			}
		}
		return self::sqlSearch(join(" AND ", $sql), $limit, $vals);
	}

	/**
	 * Return a list of objects matching an SQL expression
	 *
	 * Searches the database with a custom raw SQL WHERE expression specified in the method call.  The WHERE clause specified should not include the word 'WHERE' and has access only to the table that maps to the object.  This method is not suitable for fetching objects based on queries that include JOINs.  Returns an array of matching objects, which might be empty.
	 *
	 * @param string $criteria Custom WHERE expression
	 * @param string $limit    The limit to apply to the SQL statement in the format {offset},{limit}
	 * @param mixed  $params   Parameters to use in a prepared statement (see MySqlConnection->query())
	 * @return array A list of matching objects
	 */
	public static function sqlSearch($criteria, $limit = "0,999999999") {
		$args = func_get_args();
		array_shift($args);
		array_shift($args);
		$query = "SELECT ".join(", ", static::$keyfields)." FROM ".static::$tablename." WHERE ".$criteria." LIMIT ".$limit;
		array_unshift($args, $query);
		$res = call_user_func_array(array(self::dbread(), 'query'), $args);
		$results = array();
		foreach ($res as $row) {
			ksort($row);
			$keystr = join("-", $row);
			$obj = self::createFromKey($row);
			if ($obj) $results[$keystr] = $obj;
		}
		return $results;
	}

	/**
	 * Find a single object based on specified criteria
	 *
	 * Identical to search() except that the return value is the object found (or null if no objects matched the search), and an exception will be thrown if more than one match is found.
	 *
	 * @param array $criteria Associative array of fields and values to constrain the search on the database table
	 * @return OrmActiveRecord The matching object (or null if no object is found).
	 */
	public static function find(array $criteria) {
		$results = self::search($criteria, "0,2");
		if (count($results) == 2) throw new InvalidCallException('More than one result found', 0, null, $criteria);
		return (empty($results)) ? false : reset($results);
	}

	/**
	 * Returns an array containing every object of this type in the database, optionally contained by pagination limits
	 *
	 * Use with extreme care on datasets that can grow beyond a few items
	 *
	 * @param string $limit The limit to apply to the SQL statement in the format {offset},{limit}
	 * @return OrmActiveRecord The matching object (or null if no object is found).
	 */
	public static function getAll($limit="0,999999999") {
		return self::sqlSearch('TRUE', $limit);
	}

	/**
	 * Returns the definition of a specified field
	 *
	 * Useful for paring an ORM object with a core adminform, which takes field definitions in the format returned by this method
	 *
	 * @param string $key The field name for which the definition array is required
	 * @return array An associative array of field properties
	 */
	public static function getField($key) {
		return empty(static::$fields[$key]) ? null : static::$fields[$key];
	}

	/**
	 * Returns the definitions of all the fields in the class's $fields array (essentially just returns $fields)
	 *
	 * Useful for paring an ORM object with a core adminform, which takes field definitions in the format returned by this method
	 *
	 * @return array An associative array of fields, where each element is an array with the field properties for that field.
	 */
	public static function getFields() {
		return static::$fields;
	}

	/**
	 * Returns a list of the properties of the object which are editable publicly (have visibility=public in the field definition)
	 *
	 * Identical to getFields except that only editable fields are included
	 *
	 * @return array An array of field definitons for only the editable fields
	 */
	public static function getEditableFields() {
		$fields = array();
		foreach (static::$fields as $field=>$def) {
			if ($def['visibility'] == 'public') $fields[$field] = $def;
		}
		return $fields;
	}

	/**
	 * Sets the name of the project for memcache namespacing
	 *
	 * This method should be called on OrmActiveRecord, and the same value will be used for all subclasses.
	 *
	 * @param string $name Name of project (should be the appropriate Assanka project code)
	 * @return void
	 */
	public static function setProjName($name) {
		self::$projname = $name;
	}

	/**
	 * Enables or disables object caching
	 *
	 * This method should be called on OrmActiveRecord.
	 *
	 * @param boolean $enabled Whether object caching should be enabled
	 * @return void
	 */
	public static function setObjectCachingEnabled($enabled) {
		static::$objectcachingenabled = (bool)$enabled;
	}

	/**
	 * Enables or disables memcache caching
	 *
	 * This method should be called on OrmActiveRecord.
	 *
	 * @param boolean $enabled Whether memcache caching should be enabled
	 * @return void
	 */
	public static function setMemcacheCachingEnabled($enabled) {
		static::$memcachecachingenabled = (bool)$enabled;
	}
}