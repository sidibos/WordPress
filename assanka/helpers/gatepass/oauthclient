<?php

require_once $_SERVER['CORE_PATH']."/helpers/http/HTTPRequest";

class OAuthClient {
	
	private $_urlreqtok, $_urlaccesstok, $_urlauthorise, $_consumerkey, $_consumersecret, $_sigmethod, $_scheme;
	private $_state, $_token, $_toksecret;

	const UNINITIALISED = 0, UNAUTHREQTOKEN = 1, AUTHREDIRECT = 2, UNAUTHORISED = 3, AUTHORISED = 4;
	
	public function OAuthClient($urlprefix, $urlreqtok, $urlaccesstok, $urlauthorise, $consumerkey, $consumersecret) {
		$this->_urlreqtok = $urlprefix.$urlreqtok;
		$this->_urlaccesstok = $urlprefix.$urlaccesstok;
		$this->_urlauthorise = $urlprefix.$urlauthorise;
		$this->_consumerkey = $consumerkey;
		$this->_consumersecret = $consumersecret;
		$this->_sigmethod = 'PLAINTEXT';
		$this->_scheme = (isset($_SERVER['HTTPS']) and $_SERVER['HTTPS'] == 'on') ? 'https://' : 'http://';
		$this->_thisurl = $this->_scheme . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
		$this->_thisurl = preg_replace("/[\?\&]oauth_token=[^\&]*/i", "", $this->_thisurl);

		$this->_state = self::UNINITIALISED;

		// If returning from a redirection-based authentication, retrieve session params
		$this->_readSession();
		return true;
	}
	
	public function authorize() { return $this->authorise(); }
	public function authorise() {
		if ($this->_state == self::UNINITIALISED) {
			if ($this->_getRequestToken()) {
				return $this->authorise();
			} else {
				throw new Exception("Could not get request token");
			}
		} elseif ($this->_state == self::UNAUTHREQTOKEN) {
			$this->_requestAuthorisation();
		} elseif ($this->_state == self::AUTHREDIRECT) {
			$this->_getAccessToken();
			return ($this->_state==self::AUTHORISED) ? array('accesstoken'=>$this->_token, 'tokensecret'=>$this->_toksecret) : false;
		} elseif ($this->_state == self::AUTHORISED) {
			return array('accesstoken'=>$this->_token, 'tokensecret'=>$this->_toksecret);
		} elseif ($this->_state == self::UNAUTHORISED) {
			return false;
		} else {
			throw new Exception('Unknown OAuth state');
		}
	}
	
	public function setSigMethod($method) {
		if ($method != 'PLAINTEXT') throw new Exception('Signature method not supported');
		$this->_sigmmethod = $method;
		return true;
	}

	public function setToken($type, $token, $secret) {
		$this->_token = $token;
		$this->_toksecret = $secret;
		if ($type="request") {
			$this->_state = self::UNAUTHREQTOKEN;
		} else {
			$this->_state = self::AUTHORISED;
		}
	}
	
	private function _getRequestToken() {
		$resp = $this->_makereq('GET', $this->_urlreqtok);
		$data = is_object($resp) ? $resp->getData() : null;
		if (!isset($data['oauth_token']) or !is_array($data)) {
			return false;
		}
		$this->_token = $data['oauth_token'];
		$this->_toksecret = $data['oauth_token_secret'];
		$this->_state = self::UNAUTHREQTOKEN;
		return true;
	}
	
	private function _requestAuthorisation() {
		$this->_state = self::AUTHREDIRECT;
		$this->_writesession();
		header('Location: '.$this->_urlauthorise.'?oauth_token='.$this->_token.'&oauth_callback='.$this->_thisurl);
		exit;
	}
	
	private function _getAccessToken() {
		$resp = $this->_makereq('GET', $this->_urlaccesstok);
		if (is_object($resp) and $resp->getResponseStatusCode() == 200) {
			$data = $resp->getData();
		}
		if (empty($data['oauth_token'])) {
			$this->_state = self::UNAUTHORISED;
			return false;
		}

		// Update saved token to access token, forget request token
		$this->_token = $data['oauth_token'];
		$this->_toksecret = $data['oauth_token_secret'];
		$this->_state = self::AUTHORISED;
		return $this->_token;
	}
	
	// Currently all the arguments to this method are ignored because they are not used in the PLAINTEXT sig method.  However, they are all that is required to sign an OAuth request using HMAC or MD5, so these implementations could be added later.
	private function _sign($method, $url, $oauth, $reqparams) {
		$toksecret = ((!empty($this->_toksecret))?$this->_toksecret:'');
		if ($this->_sigmethod=='PLAINTEXT') {
			return $this->_consumersecret.'&'.$toksecret;
		} else {
			throw new Exception('Unsupported signature method');
		}
	}
		
	private function _getRandomString($length) {
		$s = '';
		for ($i = 0; $i < $length; $i++) {
			$s .= base_convert(mt_rand(0, 35), 10, 36);
		}
		return $s;
	}

	private function _readSession() {
		if (empty($_COOKIE['PHPSESSID'])) return;
		if (!session_id()) {
			session_start();
			$sessionstarted = true;
		} else {
			$sessionstarted = false;
		}
		if (!empty($_SESSION['OAuthClient'])) {
			foreach ($_SESSION['OAuthClient'] as $k=>$v) $this->$k = $v;
			unset($_SESSION['OAuthClient']);
			if ($sessionstarted and !$_SESSION) {
				session_unset();
				session_destroy();
				setcookie(session_name(), '', time()-3600);
				unset($_COOKIE[session_name()]);
			}
		}
	}

	private function _writesession() {
		if (!session_id()) session_start();
		$_SESSION['OAuthClient'] = array("_token"=>$this->_token, "_toksecret"=>$this->_toksecret, "_token"=>$this->_token, "_state"=>$this->_state);
	}
	
	public function getAuthorizationHeader($method, $url, $reqparams=array()) {
		$auth = array();
		$auth['oauth_consumer_key'] = $this->_consumerkey;
		if ($this->_token) $auth['oauth_token'] = $this->_token;
		$auth['oauth_signature_method'] = $this->_sigmethod;
		$auth['oauth_timestamp'] = time();
		$auth['oauth_nonce'] = $this->_getRandomString(10);
		$auth['oauth_version'] = 1;
		$auth['oauth_signature'] = $this->_sign($method, $url, $auth, $reqparams);
		$authheader = 'OAuth';
		foreach ($auth as $key => $value) {
			$authheader .= ' '.$key.'="'.rawurlencode($value).'",';
		}
		$authheader = rtrim($authheader, ",");
		return $authheader;
	}

	// Only used for token exchange requests
	private function _makereq($method, $url, $reqparams=array()) {
		$http = new HTTPRequest($url);
		$http->setHeader("Authorization", $this->getAuthorizationHeader($method, $url, $reqparams));
		$http->setHeader("User-Agent", 'Assanka OAuth Client 1.0');
		$http->setMethod($method);
		try {
			return $http->send();
		} catch (Exception $e) {
			return false;
		}
	}

	public function getLastError() { trigger_error("Deprecated", E_USER_DEPRECATED); }
}
?>
