<?php
/**
 * Assanka Error handler
 *
 * Replaces standard PHP error hander.  In development mode,
 * displays a memory dump and stack trace on screen in a
 * tree view.  In production mode, displays an error page
 * and tracking number for visitor's reference, and posts
 * memory dump and stack trace to support system.
 *
 * Can also be used in AJAX or command line mode, which
 * causes it to produce much less verbose output.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

// Include an Assanka Exception that allows the error handler to record context
require_once 'exception';

class ErrorHandlerV5 {

	// Actions to take depend upon error type and manual overrides
	private static $action = array('log' => 0, 'stop' => 0, 'report' => 0);

	// If the error triggers a stop action, display an HTML page, or a short plain text error
	private static $reportpagetype;

	// Other properties
	private static $devmode, $logfiledir, $summaryfile, $ishttp, $templates, $server;
	private static $debugmode = false;
	private static $lasterrtree = null;

	private static $indexedobjs = array();
	private static $respdescrs = array(200 => "OK", 201 => "Created", 202 => "Accepted", 203 => "Non-Authoritative Information", 204 => "No Content", 205 => "Reset Content", 206 => "Partial Content", 400 => "Bad Request", 401 => "Unauthorized", 403 => "Forbidden", 404 => "Not Found", 405 => "Method Not Allowed", 406 => "Not Acceptable", 407 => "Proxy Authentication Required", 408 => "Request Timeout", 409 => "Conflict", 410 => "Gone", 411 => "Length Required", 412 => "Precondition Failed", 413 => "Request Entity Too Large", 414 => "Request URI Too Long", 415 => "Unsupported Media Type", 416 => "Requested Range Not Satisfiable", 417 => "Expectation Failed", 500 => "Internal Server Error", 501 => "Not Implemented", 502 => "Bad Gateway", 503 => "Service Unavailable", 504 => "Gateway Timeout", 505 => "HTTP Version Not Supported");

	const FULL_LOG_INTERVAL = 14400;
	const MAX_SCALAR_SIZE = 512;
	const MAX_ARRAY_SIZE = 20;
	const MAX_OBJECT_SIZE_FOR_EVAL = 50000;
	const MAX_TREE_DEPTH = 8;
	const DEFAULT_RESPONSE_CODE = 500;
	const CONTEXT_LINE_COUNT = 3;
	const UDP_MONITOR_HOST = 'udperrormonitor';
	const UDP_MONITOR_PORT = 9755;

	const PAGE_TYPE_HTML = 1, PAGE_TYPE_TEXT = 0;

	/**
	 * Bind the class to PHP's error handler and set default values
	 *
	 * This method must be called to enable the error handler, and must be called before any other method.
	 *
	 * @return void
	 */
	public static function init() {


		/* Determine whether in dev mode, for setting default alert levels */
		//if explicitly set to live disable DEV MODE
		if(isset($_SERVER["IS_LIVE"]) && $_SERVER["IS_LIVE"]){
			self::$devmode = false;
		} elseif (isset($_SERVER["IS_DEV"]) && $_SERVER["IS_DEV"]) {
			self::$devmode = true;
		} else {
			self::$devmode = false;
		}

		self::useDefaultActionTriggers();

		// Construct the log file path - a central repository, with the year/month appended.
		self::$logfiledir = '/var/log/apps';
		self::$summaryfile = 'errorhandler-summary.log';

		// Determine whether the script is running in a web server environment.
		// COMPLEX:AB:20100102: This previously checked for existence of $_SERVER['HTTP_HOST'] but this was problematic when applications set this variable themselves even when in a CLI environment.
		self::$ishttp = function_exists("apache_request_headers");

		// Report using an HTML page if running in web server and not AJAX (check for common AJAX path and HTTP headers)
		self::$reportpagetype = (self::$ishttp and !preg_match("/\/aja?x\//i", $_SERVER["REQUEST_URI"])) ? self::PAGE_TYPE_HTML : self::PAGE_TYPE_TEXT;
		if (self::$reportpagetype and self::$ishttp) {
			$reqheaders = apache_request_headers();
			if (!empty($reqheaders["X-Requested-With"]) and $reqheaders["X-Requested-With"] == "XMLHttpRequest") {
				self::$reportpagetype = self::PAGE_TYPE_TEXT;
			}
		}

		// Set default error page templates
		self::$templates = array('html' => dirname(__FILE__).'/template_std_html', 'text' => dirname(__FILE__).'/template_std_text');

		// Process every error.  Note that regardless of the value of error_reporting, the error handler will always be called, but in cases where the application has set error_reporting to 0 or the default setting is 0, we need to set it to something else so that errors in @-prefixed commands can be distinguished from errors in non-error-suppressed code.
		error_reporting(E_ALL);
		set_error_handler(array('ErrorHandlerV5', 'reportError'));
		set_exception_handler(array('ErrorHandlerV5', 'reportException'));
		register_shutdown_function(array('ErrorHandlerV5', 'fatalErrorShutdownHandler'));

		// Enable output buffering if running in web server to ensure error pages replace any output already sent to the browser (this may be overridden by the application, in which case error will be appended to partial page output)
		if (isset($_SERVER["REQUEST_URI"])) ob_start();
	}


 	/**
	 * Set default alert levels based on whether in devmode
	 *
	 * The following actions are set by this method, based on whether the error handler is in dev mode:
	 *
	 * Dev mode:   Log and stop on everything (including STRICT), do not report anything.
	 * Live mode:  Log and report everything except STRICT, NOTICE, and DEPRECATED.  Stop only on ERROR, USER_ERROR and WARNING
	 *
	 * The actions correspond to the following:
	 *
	 *  'log' - Generate and write a detailed log of the error to disk
	 *  'report' - Send the log file to the Assanka helpdesk (requires log)
	 *  'stop' - Stop execution of the script and display a report page.  log must also be enabled for the report page to provide debug information in dev mode.
	 *
	 * @return void
	 */
	public static function useDefaultActionTriggers() {
		if (self::$devmode) {
			self::$action = array(
				'log'  => 0,
				'stop'  => E_ALL | E_STRICT,
				'report'  => 0
			);
		} else {
			self::$action = array(
				'log'  => E_ALL ^ (E_NOTICE | E_DEPRECATED | E_USER_DEPRECATED),
				'stop'  => E_USER_ERROR | E_ERROR | E_WARNING,
				'report'  => E_ALL ^ (E_NOTICE | E_DEPRECATED | E_USER_DEPRECATED)
			);
		}
	}



	public static function reportException($ex, $level=E_ERROR) {
		try {
			self::reportError($level, $ex->getMessage(), $ex->getFile(), $ex->getLine(), $ex);
		} catch (Exception $e) {
			self::reportError($level, "Unhandled exception thrown while processing error report", $e->getFile(), $e->getLine(), array("origexception" => $ex->getMessage(), "origfile" => $ex->getFile(), "origline" => $ex->getLine()));
		}
	}

	public static function fatalErrorShutdownHandler() {
		$error = error_get_last();
		if (!empty($error) and $error['type'] === E_ERROR) {
			self::reportError(E_ERROR, $error['message'], $error['file'], $error['line']);
		}
	}

	/**
	 * Report an error
	 *
	 * Should not be called directly.  Use trigger_error instead,
	 * which will call this as the method registered as PHP's
	 * error handler.  Depending on the configuration of the error
	 * handler instance, reportError <b>may</b> cause the script to
	 * exit before returning.
	 *
	 * @param integer $errno   Bitwise integer indicating the error tye
	 * @param string  $errstr  Error message
	 * @param string  $errfile File path of file in which error occured
	 * @param integer $errline Line number on which error occured
	 * @param array   $context Variables within the context of the error
	 * @return void
	 */
	public static function reportError($errno, $errstr, $errfile, $errline, $context=array()) {

		// If the error is not reportable, return
		if (!(error_reporting() & $errno)) return;

		// If there are no actions defined for this kind of error, return
		if (!($errno & (self::$action['log'] | self::$action['stop'] | self::$action['report']))) return;

		// Determine where operating under heavy load
		$loadavg = explode(' ', shell_exec('cat /proc/loadavg'));
		$highload = ($loadavg[0] > 5);

		// Special case for corrupted session IDs - assign a new session (support request #2809)
		if (strpos($errstr, "The session id contains invalid characters, valid characters are") !== false or strpos($errstr, "The session id contains illegal characters, valid characters are") !== false) {

			// Clear the current session
			unset($_COOKIE["PHPSESSID"]);
			@session_unset();
			@session_destroy();

			// Start a new one using the current microsecond timestamp as an ID to replace the corrupted one
			session_id(str_replace('.', '', microtime(true)));
			session_start();


			/* Allow error page to be displayed because the script may depend on session data that has now been wiped.  On next pageload the new session will be used. */

		}

		// Detect and read machine tags in error string
		$origerrstr = $errstr;
		$errortags = array();
		preg_match_all('/\beh\:(httpresponse|hashcode|tolerance|projcode|report|noreport)(=([^\s]*))?\b/i', $errstr, $m, PREG_SET_ORDER);
		if ($m) {
			foreach ($m as $match) {
				$errstr = str_replace($match[0], "", $errstr);
				$errortags[$match[1]] = isset($match[3]) ? $match[3] : true;
			}
		}
		$errstr = trim($errstr);

		// Shorten common error strings
		$shortmsg = ($a = strpos($errstr, "occured in query")) ? substr($errstr, 0, $a) : $errstr;
		$shortmsg = preg_replace("/([^\)]+\()[^\)]+(\))/", "$1$2", $shortmsg);
		$shortmsg = preg_replace("/\[\<.*\>\]/U", "", $shortmsg);

		// Ensure error string is valid UTF-8
		if (function_exists('mb_convert_encoding')) $shortmsg = mb_convert_encoding($shortmsg, "UTF-8", "auto");

		// Determine which server the error handler is running on
		self::$server = trim(shell_exec('hostname'));

		// Generate a backtrace
		if (is_object($context) and method_exists($context, 'getTrace')) {
			$backtrace = $context->getTrace();
		} elseif ($errno != E_ERROR) {
			$backtrace = debug_backtrace();
		} else {
			$backtrace = null;
		}


		/* Generate a hash of the error */

		// Special case for MySQL too many connections or system error 95
		if (preg_match('/mysql_connect\(\)\s*:\s*(Too many connections|Lost connection to MySQL server)/i', $shortmsg)) {

			for ($i = 0; isset($backtrace[$i]) and $backtrace[$i]['function'] != 'mysql_connect'; $i++) {
			} // Skipping over all items in the backtrace which are not the mysql_connect call

			$dbhost = $backtrace[$i]['args'][0];
			$servers = ($dbhost == self::$server or $dbhost == 'localhost' or $dbhost == '127.0.0.1') ? self::$server : $dbhost."/".self::$server;
			$shortmsg = $hashtrace = "MySQL Too many connections (".$servers.")";

		// Special case for E_ERROR (no backtrace available)
		} elseif ($errno == E_ERROR) {
			$hashtrace = $shortmsg;

		} else {

			// Remove includes from backtrace before hashing, to group together the same error triggered via different include paths
			$hashtrace = $backtrace;
			$stopat = array("require", "include", "require_once", "include_once");
			for ($i = 0, $s = count($hashtrace); $i < $s; $i++) {
				if (isset($hashtrace[$i]["function"]) and in_array($hashtrace[$i]["function"], $stopat)) {
					$hashtrace = array_slice($hashtrace, 0, $i);
					break;
				}
				unset($hashtrace[$i]["args"]);
				unset($hashtrace[$i]["object"]);
			}

			// Serialise the hashable backtrace.  print_r will fail below if the error handler is running in an output buffer callback, because in order to return the string rather than echoing it, it uses the output buffer, and access to the output buffer is not available in an output buffer callback.  So if this fails, revert to serialise.  If that fails, just use the error string.
			$hashtrace = @print_r($hashtrace, true);
			if (!$hashtrace) $hashtrace = @serialize($hashtrace);
			if (!$hashtrace) $hashtrace = $shortmsg;
		}

		$hashtrace = str_replace("\n", " ", $hashtrace);
		$hash = (!empty($errortags['hashcode'])) ? $errortags['hashcode']: sprintf('%08X', crc32($hashtrace));


		/* Process appropriate actions */

		// LOG: Log the error details to disk (in a summary file and in an individual error report file)
		// STOP: Display error details on screen (if in dev mode, this will include the log, so the log still needs to be prepared)
		if ((empty($errortags['nolog']) and (!empty($errortags['log']) or ($errno & self::$action['log']))) or
		(self::$devmode and empty($errortags['nostop']) and (!empty($errortags['stop']) or ($errno & self::$action['stop'])))) {

			// Set umask for all files written by the error handler
			umask(0);

			// Write to the summary file if logging is enabled
			if (empty($errortags['nolog']) and (!empty($errortags['log']) or ($errno & self::$action['log']))) {
				if (!is_dir(self::$logfiledir)) @mkdir(self::$logfiledir, 0777, true);
				$summaryfilename = self::$logfiledir."/".self::$summaryfile;
				$summaryline = "\"". date("r") . "\",\"" . $_SERVER["SCRIPT_NAME"] . "\",\"" . $errno . "\",\"" . $hash . "\",\"" . $origerrstr . "\",\"" . $errfile . "\",\"" . $errline . "\",\"" . ((isset($_SERVER["PHP_AUTH_USER"]))?$_SERVER["PHP_AUTH_USER"]:"defaultuser") . "\",\"".((isset($_SERVER["HTTP_X_VARNISH"]))?$_SERVER["HTTP_X_VARNISH"]:"")."\"\n";
				if (is_writable($summaryfilename) or (!file_exists($summaryfilename) and is_writable(dirname($summaryfilename)))) {
					$summaryfileoffset = file_exists($summaryfilename) ? filesize($summaryfilename) : 0;
					if ($handle = fopen($summaryfilename, 'a')) {
						fwrite($handle, $summaryline);
						fclose($handle);
					}
				} else {
					$summaryfileoffset = "Unable to write to summary file";
				}
			} else {
				$summaryfileoffset = 0;
			}


			/* Create an array of error details */

			// Avoid including globals in the context or backtrace
			if (is_array($context) and isset($context['GLOBALS'])) $context = "Error occured within global scope - context is global";

			// No need to duplicate error context in backtrace (first step in backtrace is this method - reportError)
			// Also check second step for compatibility with ErrorHandlerV4
			unset($backtrace[0]["args"][4]);
			if (isset($backtrace[1]) and isset($backtrace[1]['args'][4]) and is_array($backtrace[1]['args'][4]) and isset($backtrace[1]['args'][4]['GLOBALS'])) {
				unset($backtrace[1]['args'][4]);
			}

			// Error levels for convenience
			$errlevels = array(1  => "E_ERROR", 2  => "E_WARNING", 4  => "E_PARSE", 8  => "E_NOTICE", 16  => "E_CORE_ERROR", 32  => "E_CORE_WARNING", 64  => "E_COMPILE_ERROR", 128  => "E_COMPILE_WARNING", 256  => "E_USER_ERROR", 512  => "E_USER_WARNING", 1024  => "E_USER_NOTICE", 2048  => "E_STRICT", 4096  => "E_RECOVERABLE_ERROR", 8192 => 'E_DEPRECATED', 16384 => 'E_USER_DEPRECATED');

			// Build the error detail tree
			$errtree = array(
				"Error details"  => array(
					"msg"  => $errstr,
					"file"  => $errfile,
					"calledfrom"  => $_SERVER["SCRIPT_NAME"],
					"codecontext"  => array(),
					"errline"  => $errline,
					"level"  => $errno,
					"levelname"  => $errlevels[$errno],
					"server"  => self::$server,
					"time"  => date("Y-m-d H:i:s"),
					"Error handling"  => array(
						"shortmsg"  => $shortmsg,
						"hash"  => $hash,
						"hashtrace"  => $hashtrace,
						"tags"  => $errortags
					)
				),
				"Server variables"  => $_SERVER
			);
			if ($summaryfileoffset) $errtree['Error details']['Error handling']["summaryfilepos"] = $summaryfileoffset;
			if ($highload) $errtree['Error details']['Error handling']["highloadwarning"] = 'Debug process curtailed by high load';


			// Add a snippet of code from around the point of the error
			if (is_file($errfile)) {
				$errorfilecontent = file($errfile);
				$minline = max(0, ($errline - 1) - self::CONTEXT_LINE_COUNT);
				$maxline = min(count($errorfilecontent) - 1, ($errline - 1) + self::CONTEXT_LINE_COUNT);
				for ($i = $minline; $i <= $maxline; $i++) {
					$errtree['Error details']['codecontext'][$i + 1] = rtrim($errorfilecontent[$i]);
				}
			}

			// Set location for occurence debug log
			$logdir = "/tmp/errorhandler/".$hash;
			if (!is_dir($logdir)) @mkdir($logdir, 0777, true);

			// Determine time of last occurence of this error on this server
			$latesttime = 0;
			if (is_dir($logdir)) {
				$dh = opendir($logdir);
				while (!empty($dh) and false !== ($file = readdir($dh))) {
					if ($file != "." and $file != "..") {
						$a = @filemtime($logdir."/".$file);
						if (!$a) {
							$latesttime = time();
							break;
						}
						if ($a and $a > $latesttime) $latesttime = $a;
					}
				}
				closedir($dh);
			}

			// If most recent mod time is more than FULL_LOG_INTERVAL seconds ago, include additional
			// context and full globals in debug log.  Always include globals if devmode is enabled
			if (!$highload and ($latesttime < (time() - self::FULL_LOG_INTERVAL) or self::$devmode)) {

				// If the script is being executed in the context of an HTTP Request, add the request details to the error log
				if (self::$ishttp) {
					$req = array();
					if (isset($_SERVER["REQUEST_METHOD"])) $req["method"] = $_SERVER["REQUEST_METHOD"];
					if (isset($_SERVER["REQUEST_URI"])) $req["requesturi"] = $_SERVER["REQUEST_URI"];
					if (isset($_SERVER["HTTP_HOST"])) $req["host"] = $_SERVER["HTTP_HOST"];
					if (isset($_SERVER["PHP_AUTH_USER"])) $req["user"] = $_SERVER["PHP_AUTH_USER"];
					if (isset($_SERVER["HTTP_REFERER"])) $req["referrer"] = $_SERVER["HTTP_REFERER"];
					if (isset($_SERVER["HTTP_USER_AGENT"])) $req["useragent"] = $_SERVER["HTTP_USER_AGENT"];
					if (isset($_SERVER["REMOTE_ADDR"])) $req["visitor"] = $_SERVER["REMOTE_ADDR"];
					if (isset($_GET)) $req["GET data"] = $_GET;
					if (isset($_POST)) $req["POST data"] = $_POST;
					if (isset($_COOKIE)) $req["Cookies"] = $_COOKIE;
					if (isset($_FILES)) $req["File uploads"] = $_FILES;
					$req['Headers'] = apache_request_headers();
					$errtree['HTTP Request'] = $req;
				}

				// Add local variable context provided by the error handler argument (after HTTP, if present)
				if ($context) $errtree["Context"] = $context;

				// Increase memory limit and allow globals to be added to var dump
				if (isset($GLOBALS)) {
					if ($currentmemorylimit = ini_get("memory_limit")) {
						if (preg_match('/\A([0-9\.]+)([K|M|G])\Z/', $currentmemorylimit, $matchparts)) {
							$multipliers = array('K' => 1024, 'M' => 1048576, 'G' => 1073741824);
							$currentmemorylimit = $matchparts[1] * $multipliers[$matchparts[2]];
						}
						if (!is_numeric($currentmemorylimit) or $currentmemorylimit < (128 * $multipliers['M'])) {
							ini_set("memory_limit", "128M");
						}
					} else {
						ini_set("memory_limit", "128M");
					}
					$g = array();
					$unwantedkeys = array("HTTP_COOKIE_VARS", "HTTP_POST_VARS", "HTTP_GET_VARS", "HTTP_SERVER_VARS", "HTTP_ENV_VARS", "HTTP_POST_FILES", "HTTP_SESSION_VARS", '_POST', '_GET', '_COOKIE', '_FILES', '_REQUEST', 'GLOBALS', '_SERVER');
					foreach($GLOBALS as $key  => $vals) if (!in_array($key, $unwantedkeys)) $g[$key] = $vals;
					$errtree['Globals'] = $g;
				}

				// Finally add the backtrace at the end
				if ($backtrace) $errtree["Backtrace"] = $backtrace;

				// Store a *copy* of the session, to reinstate later
				$sessioncopy = empty($_SESSION) ? null : unserialize(serialize($_SESSION));
			} else {
				$errtree['Error details']['Error handling']['ratelimitwarning'] = 'Debug curtailed because a previous full report of the same error has been made recently';
			}

			// Truncate data in sections of the log which might otherwise get very big, and index all referenced objects into the self::$indexedobjs array
			self::$indexedobjs = array(0 => 1);
			$inspectarrays = (empty($errortags['nostop']) and (!empty($errortags['stop']) or ($errno & self::$action['stop'])));
			$errtree = self::abbreviate($errtree, 0, false, $inspectarrays);
			$errtree['objstore'] = self::$indexedobjs;
			if (!empty($sessioncopy)) $_SESSION = $sessioncopy;

			// Log to disk if logging is enabled
			if (empty($errortags['nolog']) and (!empty($errortags['log']) or ($errno & self::$action['log']))) {

				// Serialise to JSON if possible
				$json = false;
				$json = @json_encode($errtree);
				if (empty($json)) $json = print_r($errtree, true);

				// Write the occurence debug log file
				$logfile = tempnam($logdir, "");
				if ($handle = fopen($logfile, 'a')) {
					fwrite($handle, $json);
					fclose($handle);
					chmod($logfile, 0777);
				}
			}
		} else {
			$errtree = false;
		}

		// REPORT: Post to the support system (requires LOG, otherwise there will be nothing to send)
		if (!$highload and $errtree and empty($errortags['noreport']) and (!empty($errortags['report']) or ($errno & self::$action['report']))) {
			$path = "/helpers/errorhandler/v5/postreport";
			$path = (isset($_SERVER["CORE_PATH"])) ? $_SERVER["CORE_PATH"].$path : "/assanka".$path;
			$cmd = "nohup nice -n 19 ".$path." ".$logfile." 2>&1 &";
			pclose(popen($cmd, "r"));
		}

		// STOP: Produce report page if required
		if (empty($errortags['nostop']) and (!empty($errortags['stop']) or ($errno & self::$action['stop']))) {
			if (ob_get_level()) ob_end_clean();
			if (!empty($_SERVER["REQUEST_URI"])) {
				if (!empty($errortags['httpresponse']) and !empty(self::$respdescrs[$errortags['httpresponse']])) {
					$code = $errortags['httpresponse'];
				} else {
					$code = self::DEFAULT_RESPONSE_CODE;
				}
				if (!headers_sent()) {
					header("HTTP/1.1 ".$code." ".self::$respdescrs[$code]);
					header("Content-type: text/".((self::$reportpagetype == self::PAGE_TYPE_HTML)?'html':'plain'));
					header("Expires: Sat, 26 Jul 1997 05:00:00 GMT");
					header("Cache-Control: no-cache, must-revalidate");
					header("X-No-Cache: 1");
				}
			}
			self::$lasterrtree = $errtree;
			echo "\n".self::errorReportPage($errtree, self::$reportpagetype, self::$devmode)."\n";
			exit(1);
		}
	}

	/**
	 * Abbreviates a nested data structure, for debug purposes
	 *
	 * To reduce storage requirements, bandwidth use and size of debug pages displayed in the browser, this method selectively truncates and simplifies a PHP data structure, returning a new data structure.
	 *
	 * Any object instances within the structure will be removed and replaced with a string identifier, with the object itself moved to the static $indexedobjs array.  Private members of indexed objects will be exposed and turned into arrays.  However, private members of two object instances that are both references to the same third object cannot be paired, and these references will therefore be expanded in duplicate.
	 *
	 * Numerically indexed arrays with more than MAX_ARRAY_SIZE elements will be truncated to the maximum number of elements, with elements removed from the middle of the array.
	 *
	 * Any scalar value larger than MAX_SCALAR_SIZE will be truncated to MAX_SCALAR_SIZE bytes, with data being removed from the middle of the value, and replaced with the string ' ... '
	 *
	 * Does not allow the structure to recurse beyond MAX_TREE_DEPTH levels.
	 *
	 * @param array   &$data         Data to abbreviate
	 * @param integer $level         Level of recursion, set automatically on recursive calls - should not be set be the caller
	 * @param boolean $isglobals     Set to true if this element should be fully retained and not truncated
	 * @param boolean $inspectarrays Set to true to resolve references where multiple variables reference the same array.  Pollutes the array with error handler debug keys, so should only be used if the error is fatal (ie the arrays are not going to be used again)
	 * @return array Abbreviated data
	 */
	public static function abbreviate(&$data, $level=0, $isglobals=false, $inspectarrays=true) {
		if (is_object($data) and !($data instanceOf Closure)) {
			self::debug(str_repeat("\t", $level)."Instance of ".get_class($data).": ");
			$objid = spl_object_hash($data);
			if (isset(self::$indexedobjs[$objid])) {
				self::debug("Already indexed as object ".$objid."\n");
				return array("_errorhandler_objid" => $objid, "_errorhandler_type" => 'object');
			} else {

				self::debug("Indexing as object ".$objid."\n");
				self::$indexedobjs[$objid] = array();

				// Retrieve public members from the object (references are preserved)
				$vars = array();
				$a = get_object_vars($data);
				foreach ($a as $k => $v) if (!isset($vars[$k])) $vars[$k] = @$data->$k;

				// Cast object to an array to gain access to private members.  References are broken, so only populate properties that have not already been discovered by get_object_vars.
				$x = (array)$data;
				foreach ($x as $k => $v) {
					$k = preg_replace('/^\0.*?\0(.+)$/', "$1", $k);
					if (!isset($vars[$k])) $vars[$k] = $v;
				}

				$vars['_errorhandler_classname'] = get_class($data);
				$vars['_errorhandler_objid'] = $objid;
				$vars['_errorhandler_type'] = 'object';
				self::$indexedobjs[$objid] = self::abbreviate($vars, $level, false, $inspectarrays);
				return array("_errorhandler_objid" => $objid, "_errorhandler_type" => 'object');
			}
		}
		if (is_array($data) and $level >= self::MAX_TREE_DEPTH) return "ERROR HANDLER MAX TREE DEPTH REACHED";
		if (is_object($data) and $data instanceOf Closure) {
			return array("_errorhandler_type"  => "closure");
		} elseif (is_array($data)) {
			self::debug(str_repeat("\t", $level)."Array: ");
			if (isset($data['_errorhandler_objid'], $data['_errorhandler_type']) and $data['_errorhandler_type'] == 'array') {
				self::debug("Already indexed as array ".$data['_errorhandler_objid']."\n");
				return array("_errorhandler_type" => 'array', "_errorhandler_arrref" => $data['_errorhandler_objid'], "_errorhandler_objid" => $data['_errorhandler_objid']);
			} else {
				if ($inspectarrays) {
					if (!isset($data['_errorhandler_objid'])) {
						$arrid = count(self::$indexedobjs);
						self::debug("Indexing as array ".$arrid."\n");
						$data['_errorhandler_objid'] = $arrid;
						$data['_errorhandler_type'] = 'array';
						self::$indexedobjs[$arrid] = 'array';
					} else {
						self::debug("representation of object ".$data['_errorhandler_objid']."\n");
					}
				}
				$returnarr = array();
				$boundary = floor(self::MAX_ARRAY_SIZE / 2);
				$s = count($data);
				$i = 0;
				foreach ($data as $k => $v) {
					if ($isglobals or $i < $boundary or $i > ($s - $boundary)) {
						self::debug(str_repeat("\t", $level)."Array element $k\n");
						$passwordkeys = array('pw', 'pass', 'password', 'password2', 'vaultkey', 'secret', 'passverify', 'verifypass');
						if (is_string($k) and (in_array($k, $passwordkeys))) {
							$x = "--Password-like key: value deleted--";
						} else {
							$x = self::abbreviate($data[$k], $level + 1, ($k == "Globals" or $k == 'Server variables'), $inspectarrays);
						}
						$returnarr[$k] = $x;
					} elseif ($i == $boundary) {
						$returnarr['_errorhandler_debug'] = ($s - self::MAX_ARRAY_SIZE)." element(s) removed";
					}
					$i++;
				}
				return $returnarr;
			}

		} elseif (is_bool($data)) {
			return ($data == true);

		} elseif (is_resource($data)) {
			return array('_errorhandler_type'  => 'PHP resource handle', '_errorhandler_value' => (integer)$data);

		} elseif (is_int($data)) {
			return $data + 0;

		} elseif (is_float($data)) {
			return $data + 0;

		} elseif (is_string($data)) {
			$data = trim($data);
			if (isset($_SERVER["PHP_AUTH_PW"])) $data = str_replace($_SERVER["PHP_AUTH_PW"], "--PHP_AUTH_PW Password Deleted--", $data);

			// Convert known encodings to UTF-8
			$encodings = array('ASCII', 'Windows-1252', 'UTF-8');
			$dtype = false;
			while (!$dtype and list($k, $enc) = each($encodings)) {
				if (mb_check_encoding($data, $enc)) $dtype = $enc;
			}
			if ($dtype) {
				$data = mb_convert_encoding($data, 'utf-8', $dtype);
			} else {

				// Convert unknown encodings to hex
				$data = join(" ", str_split(join(unpack("H*", $data)), 2));
			}

			// Shorten if necessary
			if (strlen($data) > self::MAX_SCALAR_SIZE) {
				$segmentlen = floor((self::MAX_SCALAR_SIZE - 5) / 2);
				$missing = mb_strlen($data) - self::MAX_SCALAR_SIZE;
				$data = mb_substr($data, 0, $segmentlen) . " ... ".$missing." chrs ... " . mb_substr($data, (strlen($data) - $segmentlen));
			}

			// If hex, wrap in a special type marker
			if (!$dtype) $data = array('_errorhandler_type'  => 'String (HEX dump for unrecognised charset)', '_errorhandler_value' => $data);

			return $data;


		} elseif ($data === null) {
			return null;

		} else {
			return array('_errorhandler_type' => 'unknown');
		}
	}

	private static function debug($msg) {
		if (!self::$debugmode) return;
		static $debug;
		$debug .= $msg;
		file_put_contents("/tmp/ehdebug", $debug);
	}

	/**
	 * Generate an HTML representation of an associative array
	 *
	 * Produces a nested HTML unordered list containing all the name-value pairs from an array.  This is used to serialise the error handler's memory dump prior to logging to disk, display on screen or posting to the support system.  This method calls itself recursively.
	 *
	 * @param array   $dumparr Data to serialise
	 * @param integer $level   Level of recursion, set automatically on recursive calls - should not be set be the caller
	 * @return string HTML unordered list
	 */
	public static function generateTree($dumparr, $level=0) {
		static $objstore, $objidmap;
		if (!$objstore and isset($dumparr['objstore'])) {
			$objstore = $dumparr['objstore'];
			unset($dumparr['objstore']);
		}
		if (!$objidmap) $objidmap = array();
		if (is_array($dumparr)) {
			$op = "";
			foreach ($dumparr as $key => $data) {
				$key = str_replace(array("\r","\n"), array("\\r","\\n"), htmlentities($key, ENT_COMPAT, 'UTF-8'));
				$value = $data;
				$subtree = null;
				$type = 'unknown';
				$id = null;
				$isref = false;
				$keyclasses = array('key');
				$liclasses = array();
				$interp = '';
				if (in_array($key, array("_errorhandler_objid", "_errorhandler_classname", "_errorhandler_indexed", "_errorhandler_type"))) continue;
				if (is_array($data)) {
					$type = 'array';
					if (isset($data['_errorhandler_objid'])) {
						$id = $value['_errorhandler_objid'];
						if (isset($data['_errorhandler_type'])) $type = $data['_errorhandler_type'];
						if (($type == 'object' and isset($objstore[$id]['_errorhandler_indexed'])) OR ($type == 'array' and isset($data['_errorhandler_arrref']))) {
							$isref = true;
							$keyclasses[] = 'objreference';
						} elseif ($type == 'object') {
							$objstore[$data['_errorhandler_objid']]['_errorhandler_indexed'] = $id;
							$subtree = $objstore[$data['_errorhandler_objid']];
							$value = isset($subtree['_errorhandler_classname']) ? "instance of ".htmlentities($subtree['_errorhandler_classname']) : "";
						} else {
							$subtree = $data;
							$value = "";
						}
					} elseif (isset($value['_errorhandler_type'])) {
						$type = $value['_errorhandler_type'];
						$value = isset($value['_errorhandler_value']) ? $value['_errorhandler_value'] : '';
					} else {
						$value = '';
						$subtree = $data;
					}

				} elseif (is_bool($value)) {
					$type = 'bool';
					$value = (($value)?'True':'False');
				} elseif (is_int($value)) {
					$type = 'int';
					if ($value > 631152000 and $value < 2145916800) {
						$interp = "Unix timestamp? ".date('r', $data);
					}

				} elseif (is_float($value)) {
					$type = 'float';
				} elseif (is_string($value)) {
					$type = 'string';
					$value = htmlentities($value, ENT_COMPAT, 'utf-8');
				} elseif ($value === null) {
					$type = 'null';
				}

				if ($key == 'errline') $liclasses[] = 'open';

				if ($id) {
					if (!empty($objidmap[$id])) {
						$domid = $objidmap[$id];
						$keyclasses[] = $domid;
					} else {
						$domid = $objidmap[$id] = 'obj_'.count($objidmap);
					}
				}
				$op .= "<li class='" . join(' ', $liclasses) . "'><span" . (($id and !$isref) ? " id='".$domid."'" : "") . " class='".join(' ', $keyclasses)."'>".$key." <span class='type'>".$type."</span> <span class='val'>" . ($isref ? "<a href='#".$domid."' class='objreflink'>see other reference</a>" : str_replace(array("\r","\n"), array("\\r","\\n"), $value)) . "</span>" . ($interp?"<span class='interp'>".$interp."</span>":"") . "</span>" . ($subtree ? self::generateTree($subtree, ($level + 1)) : "") . "</li>\n";
			}
			if ($op) $op = "<ul>\n" . $op . "</ul>\n";
		} else {
			$op = "";
		}
		return $op;
	}


	/**
	 * Generate a plain text backtrace from the output of debug_backtrace();
	 *
	 * Produces a plain text rendering of the output of the PHP debug_backtrace function. The format produced is similar to debug_print_backtrace, but with the advantage that the output is returned rather than printed to the output buffer.
	 *
	 * @param array $data Output from debug_backtrace()
	 * @return string Plain text backtrace
	 */
	public static function generatePlainBackTrace($data) {
		if (empty($data['Backtrace']) or !is_array($data['Backtrace'])) return false;
		$op = "";
		foreach ($data['Backtrace'] as $idx => $call) {
			$op .= '#'.$idx.'  ';
			$op .= (!empty($call['class'])) ? $call['class'].$call['type'] : '';
			$op .= $call['function'];
			$op .= (!empty($call['file'])) ? ' called at ['.$call['file'].':'.$call['line']."]\n" : "";
		}
		return $op;
	}


	/**
	 * Generate an HTML or plain text output page
	 *
	 * Produces a complete HTML or plain text page describing an error
	 *
	 * @param array   $data     An error handler error summary array
	 * @param integer $pagetype Whether to produce an HTML page or plain text.  Specify ErrorHandler::PAGE_TYPE_HTML or ErrorHandler::PAGE_TYPE_TEXT
	 * @param bool    $devmode  Whether to include debug information.  True for yes, false for no
	 * @return string The output for display
	 */
	public static function errorReportPage($data, $pagetype=self::PAGE_TYPE_HTML, $devmode=true) {
		$op = array();
		if ($data) {
			if ($devmode) {
				$op["debug"] = self::generateTree($data);
				$op["textdebug"] = self::generatePlainBacktrace($data);
			}
			if (isset($data['Error details']['Error handling']['shortmsg'])) $op["errstr"] = $data['Error details']['Error handling']['shortmsg'];
			if (isset($data['Error details']['Error handling']['hashmsg'])) $op["errstr"] = $data['Error details']['Error handling']['hashmsg'];
			$op["errline"] = $data['Error details']['errline'];
			$op["errfile"] = $data['Error details']['file'];
			$op['host'] = (isset($data['HTTP Request']['host'])) ? $data['HTTP Request']['host'] : '';
			$op["line"] = "";
			if (isset($data['Error details']['codecontext'])) {
				foreach ($data['Error details']['codecontext'] as $linenum  => $line) {
					if (is_numeric($linenum)) $op['line'] .= $linenum.": ".$line."\n";
				}
			} else {
				$op['line'] = "No code context available";
			}
			$op["url"] = (isset($data["HTTP Request"]['referrer'])) ? $data["HTTP Request"]['referrer'] : "javascript:history.go(-1)";
			$op["errorcode"] = $data['Error details']['Error handling']['hash'];
		} else {
			$op['errstr'] = "No debug information available";
			$op['errline'] = "Unknown";
			$op['errfile'] = "Unknown";
			$op["line"] = "";
			$op["errorcode"] = 'No ref available';
		}

		// Set up a function to act as a basic templatemanager
		$compileerrortemplate = function($templatetext, $arguments) {
			return trim(preg_replace("/\<\!\-\-\@(.*?)\-\-\>/e", "(isset(\$arguments[\"$1\"]))?\$arguments[\"$1\"]:\"\"", $templatetext));
		};

		// Always compile the text version
		$errorPage = $compileerrortemplate(file_get_contents(($devmode) ? dirname(__FILE__)."/template_dev_text" : self::$templates['text']), $op);

		// Replace with the HTML version if appropriate, passing in the text version
		if ($pagetype == self::PAGE_TYPE_HTML) {
			$op['textversion'] = $errorPage;
			$op['line'] = mb_check_encoding($op['line'], 'UTF-8') ? htmlentities($op['line'], ENT_QUOTES, 'utf-8') : $op['line'];
			$errorPage = $compileerrortemplate(file_get_contents(($devmode) ? dirname(__FILE__)."/template_dev_html" : self::$templates['html']), $op);
		}

		return $errorPage;
	}

	/**
	 * Set the type of report page to HTML or text
	 *
	 * An HTML report page is suitable for display to a web user, while the plain text version is more suited to command line or AJAX.  If you do not call this method, the error handler will use the environment to determine whether it should output HTML or plain text, and will prefer the latter for command line and AJAX requests.  An AJAX request is identified either by containing an XMLHTTPRequest header (set by Firefox and other browsers) or by having a REQUEST_URI that contains /ajx/ or /ajax/.
	 *
	 * @param integer $type Type of report page to produce.  ErrorHandlerV5::PAGE_TYPE_HTML or ErrorHandlerV5::PAGE_TYPE_TEXT
	 * @return bool         Whether the report page type was set successfully
	 */
	public static function setReportPageType($type) {
		if ($type != self::PAGE_TYPE_HTML and $type != self::PAGE_TYPE_TEXT) return false;
		self::$reportpagetype = $type;
		return true;
	}

	/**
	 * Set location of error log
	 *
	 * Sets the location of the directory where the error handler will store the summary log.  The hander will add a line to a summary.txt file in /year/month/summary.txt.  If not set, defaults to /var/log/apps.
	 *
	 * @param string $dir Filesystem path to a world-writable directory
	 * @return bool       Whether the directory was accetpable
	 */
	public static function setLogFileDir($dir) {
		if (!is_dir($dir) or !is_writable($dir)) return false;
		self::$logfiledir = $dir;
		return true;
	}

	/**
	 * Places the error handler in development or live mode
	 *
	 * When ErrorHandlerV5::init() is called, the ErrorHandler will attempt to determine whether it is running in a dev or live environment, and will set the devmode property accordingly.  Then it calls ErrorHandlerV5::useDefaultActionTriggers to set the action triggers to their defaults for the dev or live environments as appropriate.
	 *
	 * Call this method to set the dev mode manually after the init is complete.  The value of dev mode directly affects the format of stop pages - in dev mode these contain debug information, in live mode they contain only an error hash.  However, setting dev mode manually does not affect the action triggers that have been set up by init().  If you wish the error handler to use the default action triggers for the mode you have just set, call ErrorHandlerV5::useDefaultActionTriggers just after setDevMode.  You can also set action trigger behaviours manually with setActionTriggers, addActionTrigger and removeActionTrigger.
	 *
	 * @param bool $mode Whether the Error Handler should operate in dev mode.
	 * @return void
	 */
	public static function setDevMode($mode=true) {
		self::$devmode = ($mode == true);
	}

	/**
	 * Returns true if the errorhandler is in dev mode, false otherwise.
	 *
	 * @return bool  Whether the errorhandler is in dev mode
	 */
	public static function isDevMode() {
		return self::$devmode;
	}

	/**
	 * Sets the name of the summary error log
	 *
	 * When error handler processes an error which triggers a LOG action, it writes both a dedicated file for the error, and also adds a line to a summary error log.  By default the summary log is called 'summary.txt'.  Use this method to change its name.
	 *
	 * @param string $filename Filename of a file to use as a summary log
	 * @return void
	 */
	public static function setSummaryFilename($filename) {
		self::$summaryfile = $filename;
	}

	/**
	 * Sets the error levels that will trigger a particular action
	 *
	 * Each of the error handler actions (log, report and stop) can be attached to any combination of PHP errors.  This method allows a particular action (or all at once, by passing 'all') to be linked to a specified set of PHP errors expressed as a bitwise integer.
	 *
	 * The levels value given will replace any existing setting for that action (or actions, if using 'all').
	 *
	 * @param string  $action Name of action trigger to modify (log, report, stop, or all)
	 * @param integer $levels Levels of PHP error which will trigger this action (bitwise integer)
	 * @return bool Whether the action trigger was set successfully
	 */
	public static function setActionTriggers($action, $levels) {
		if (!is_integer($levels)) return false;
		if ($action == 'all') {
			self::$action['log'] = $levels;
			self::$action['stop'] = $levels;
			self::$action['report'] = $levels;
		} else {
			self::$action[$action] = $levels;
		}
		return true;
	}

	/**
	 * Adds a PHP error type to the set of error types that will trigger a specified error handler action
	 *
	 * Each of the four error handler actions (log, report and stop) can be attached to any combination of PHP errors.  This method allows a particular PHP error level to be ADDED to the set of error levels that will trigger a specified action.  The specified level can be added to *all* actions by specifying 'all' for the action.
	 *
	 * The level value given will be ORed with any existing setting for that action (or actions, if using 'all').
	 *
	 * @param string  $action Name of action trigger to modify (log, report, stop, or all)
	 * @param integer $level  Level of PHP error which will trigger this action (in addition to existing levels already set on this acton trigger) (bitwise integer)
	 * @return bool Whether the action trigger was set successfully
	 */
	public static function addActionTrigger($action, $level) {
		if (!is_integer($level)) return false;
		if ($action == 'all') {
			self::$action['log'] |= $level;
			self::$action['stop'] |= $level;
			self::$action['report'] |= $level;
		} else {
			self::$action[$action] |= $level;
		}
		return true;
	}


	/**
	 * Removes a PHP error type from the set of error types that will trigger a specified error handler action
	 *
	 * Each of the error handler actions (log, report and stop) can be attached to any combination of PHP errors.  This method allows a particular PHP error level to be REMOVED from the set of error levels that will trigger a specified action.  The specified level can be removed from *all* actions by specifying 'all' for the action.
	 *
	 * The level value given will be ANDed with any existing setting for that action (or actions, if using 'all').
	 *
	 * @param string  $action Name of action trigger to modify (log, report, stop, or all)
	 * @param integer $level  Level of PHP error which should NOT trigger this action (bitwise integer)
	 * @return bool Whether the action trigger was set successfully
	 */
	public static function removeActionTrigger($action, $level) {
		if (!is_integer($level)) return false;
		if ($action == 'all') {
			self::$action['log'] &= ~$level;
			self::$action['stop'] &= ~$level;
			self::$action['report'] &= ~$level;
		} else {
			self::$action[$action] &= ~$level;
		}
		return true;
	}

	/**
	 * Retrieves the current state of an action trigger.  Note that unlike other commands, this does not
	 * accept "all".
	 *
	 * @param string  $action The name of the action trigger to return the status of (log, report, stop)
	 * @param integer $level  The level of PHP error to check (bitwise integer)
	 *
	 * @return bool The state of the trigger setting.
	 */
	public static function getActionTriggerState($action, $level) {
		if (!is_integer($level)) throw new AssankaException('Invalid trigger level');
		if ($action == 'all') throw new AssankaException('Retrieval of "all" state not supported');

		return isset(self::$action[$action]) ? ($level & self::$action[$action]) : false;
	}

	/**
	 * Sets the template which will be used to display the report page in the event of a stop action being triggered
	 *
	 * If error handler handles an error which triggers a stop action, it will output an HTML or plain text page, and stop execution of the script.  By default this will use templates built into the errorhandler, but you can use this method to specify alternative templates for both the html and text formats.  Only live mode pages will be affected - there is no way to change the format of pages produced by the error handler in dev mode.
	 *
	 * The following template variables may be used:
	 *
	 * <!--@errorcode--> - The error hash
	 * <!--@host-->      - Hostname of server on which error occured
	 * <!--@url-->       - URL to which the user may safely navigate to resume browsing (usually the referrer)
	 *
	 * @param string $type Type of template to replace (text or html)
	 * @param string $path Path to the template on the filesystem
	 * @return bool Whether the template could be found
	 */
	public static function setTemplate($type, $path) {
		if (!is_file($path)) return false;
		self::$templates[$type] = $path;
		return true;
	}

	/**
	 * Returns the last error which stopped execution or null if there have been no errors
	 *
	 * @return array
	 */
	public static function getLastError() {
		return self::$lasterrtree;
	}
}

if (!class_exists('ErrorHandler')) class_alias('ErrorHandlerV5', 'ErrorHandler');
