#!/usr/bin/php -q
<?php
/**
 * Watches the PHP error log for errors and reports them.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once $_SERVER["CORE_PATH"]."/helpers/daemon/v2/daemon";


$d = new DaemonV2(array(
	'maxinstances'				=> 1,
	'startingdaemoninstances'	=> 1,
	'name'						=> "phperrortrack",
	'description'				=> "Tracks PHP errors using the php error log file.",
	'args'						=> array(
			'source'	=> "Log file source to watch for errors."
		)
	));

$args = $d->getCliArgs();

$log = new AssankaLoggerV1('phperrortrack');
$log->setLogMethod('file');

// Don't log errors in this script to the error log, so that
// loops are avoided:
ini_set("error_log", "");

// Set error reporting level - use PHP's internal error handler
error_reporting(E_ALL);

$sourcelogfile = (!empty($args["source"])) ? $args["source"] : "/var/log/httpd/php-error-log";
$log->write(array("Source"  => $sourcelogfile));

$offset = 0;
$mtime = 0;
$host = trim(shell_exec("hostname"));

while (true) {
	$log->write(array("Reading Logs..."));

	// Clear file status cache.  (PHP built in func)
	clearstatcache();

	if (!is_file($sourcelogfile)) {
		sleep(1);
		continue;
	}

	$newmtime = filemtime($sourcelogfile);
	$newoffset = filesize($sourcelogfile);

	if ($newoffset > $offset) {

		// The size of the file has changed, read the new log lines.
		$log->write(array("Log Status" => "Reading"));
		$fp = fopen($sourcelogfile, "r");
		fseek($fp, $offset);
		$buffer = "";
		while (!feof($fp)) $buffer .= fread($fp, 1024);
		fclose($fp);
	} elseif ($newmtime != $mtime) {

		// The size of the file has not changed but the file modified time has changed therefore read the entire file into the buffer, assuming that the log files have changed but happened to have the same size as before.
		$log->write(array("Log Status" => "Reading"));
		$buffer = file_get_contents($sourcelogfile);
	} else {

		// Nothing has changed.
		$log->write(array("Log Status" => "Nothing"));
		sleep(5);
		continue;
	}

	$mtime = $newmtime;
	$offset = $newoffset;

	// Ignore errors while load average is higher than 5
	$loadavg = explode(' ', shell_exec('cat /proc/loadavg'));
	if ($loadavg[0] > 5) continue;

	$pattern = "/^\[(\d\d)\-(\w\w\w)\-(\d\d\d\d) (\d\d)\:(\d\d)\:(\d\d)\] PHP (.*?)\: (.*?) in (.*?)( on line |:)(\d+)( from request_uri=\(([^\)]+)\))?(,?\s*path_translated=([^\s]+))?/si";
	$stackpattern = "/^(\[(\d\d)\-(\w\w\w)\-(\d\d\d\d) (\d\d)\:(\d\d)\:(\d\d)\] PHP\s+(Stack trace|\d+\.))|Stack trace|#\d+|\s+thrown in /i";
	$lines = explode("\n", $buffer);
	$unmatched = '';
	$errtree = null;
	foreach ($lines as $line) {
		if (!is_null($errtree)) {
			if (preg_match($stackpattern, $line)) {
				$errtree['Error details']['msg'] .= "\n".$line;
				continue;
			}
			else report_error($errtree);
		}
		if (!preg_match($pattern, $line, $matches) and !preg_match($pattern, $unmatched.$line, $matches)) {
			$log->write("Line does not match regex: $line\n");
			$unmatched .= $line;
			continue;
		}
		$unmatched = '';

		$log->write($matches);

		// Determine the hash, and other properties that need submitting:
		$months = array("Jan"=>"01", "Feb"=>"02", "Mar"=>"03", "Apr"=>"04", "May"=>"05", "Jun"=>"06", "Jul"=>"07", "Aug"=>"08", "Sep"=>"09", "Oct"=>"10", "Nov"=>"11", "Dec"=>"12");
		$msg = trim($line);
		$hashmsg = $matches[8];
		$time = $matches[4].":".$matches[5].":".$matches[6];
		$date = $matches[3]."-".$months[$matches[2]]."-".$matches[1];
		$hash = sprintf('%08X', crc32($hashmsg));
		$file = $matches[9];
		$errortype = $matches[7];
		$errline = $matches[11];
		$requesturi = (!empty($matches[13])) ? $matches[13] : null;
		$scriptname = (!empty($matches[15])) ? $matches[15] : null;

		// Normalise error type to name of relevant PHP constant
		$typemap = array("Fatal error"=>"E_ERROR", "Warning"=>"E_WARNING", "Notice"=>"E_NOTICE", "Deprecated"=>"E_DEPRECATED");
		$errortype = (!empty($typemap[$errortype])) ? $typemap[$errortype] : $errortype;

		// Ignore logs of the form "Unknown on line 0"
		if ($file == "Unknown" and $errline == 0) continue;

		// Ignore 'deprecated' errors
		if ($errortype == 'E_DEPRECATED' or $errortype == "E_NOTICE") continue;

		$errtree = array(
			"Error details" => array(
				"msg" => $msg,
				"file" => $file,
				"errline" => $errline,
				"levelname" => $errortype,
				"server" => $host,
				"time" => $date." ".$time,
				"Error handling" => array(
					"hashmsg" => $hashmsg,
					"hash" => $hash,

					// Can't get backtrace from the error log, so just use the filename.  This should be okay because hashtrace is just used for grouping.
					"hashtrace" => $file,
				)
			)
		);
		if ($requesturi) $errtree['HTTP Request'] = array("requesturi"=>$requesturi);
		if ($scriptname) $errtree['Error details']['calledfrom'] = $scriptname;

	}

	if (!is_null($errtree)) {
		$log->write(array("Status" => "Reporting Error"));
		report_error($errtree);
	}


}

function report_error(&$errtree) {
	global $log;

	if (is_null($errtree)) return;

	// Detect and read machine tags in error string
	$errortags = array();
	preg_match_all('/\beh\:(httpresponse|hashcode|projcode|report|noreport|index|noindex)(=([^\s]*))?\b/i', $errtree['Error details']['msg'], $m, PREG_SET_ORDER);
	if ($m) {
		foreach ($m as $match) {
			$errtree['Error details']['msg'] = str_replace($match[0], "", $errtree['Error details']['msg']);
			$errortags[$match[1]] = isset($match[3]) ? $match[3] : true;
		}
	}
	$errtree['Error details']['msg'] = trim($errtree['Error details']['msg']);
	$errtree['Error details']['Error handling']['tags'] = $errortags;

	if (!empty($errortags['noreport'])) return;
	if (!empty($errortags['hashcode'])) $errtree['Error details']['Error handling']['hash'] = $errortags['hashcode'];

	$hash = $errtree['Error details']['Error handling']['hash'];
	$op = json_encode($errtree);
	$logdir = "/assanka/log/errors/".date('Y/m/').$hash;
	umask(0);
	if (!is_dir($logdir)) mkdir($logdir, 0777, true);
	$logfile = $logdir."/".md5($op);

	if (!file_exists($logfile) and !file_exists($logfile."-posted")) {

		$log->write(array("NEW" => $op));

		// Write the file
		if ($handle = fopen($logfile, 'w')) {
			$log->write(array("STORED" => $logfile));
			fwrite($handle, $op);
			fclose($handle);
		}

		// Set file permissions
		$um = umask(0);
		chmod($logfile, 0777);
		umask($um);

		// Determine whether running on a production server
		if (!empty($_SERVER["IS_DEV"])) {
			$devmode = true;
		} else {
			$devmode = false;
		}

		// Post the report to the support system if in production mode
		if (!$devmode) {
			$path = "/assanka/helpers/errorhandler/v5/postreport";
			$cmd = $path." ".$logfile." 2>&1";
			$pp = popen($cmd, "r");
			sleep(10);
			pclose($pp);
			$log->write("REPORTED");
		} else {
			$log->write("DEV MODE NOT REPORTED");
		}
	} else {

		$log->write(array("DUP" => json_encode($errtree)));

		// This incident has already been posted, so this script must
		// be re-reading an old log file, and so shouldn't post duplicated.
	}
	$errtree = null;
}
