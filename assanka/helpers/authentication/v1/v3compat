<?php
/**
 * Authentication helper: Core v3 compatibility
 *
 * Allows Apache to authenticate users, and looks
 * up details in the v3 cfg_adminusers table to
 * provide a standard core v4 authentication interface
 * for v4 application tabs
 *
 * This has the following limitations compared to
 * normal v3/v4 authentication interfaces:
 *
 * 1. Rights are 'extracted' from the permissions_
 *    columns, but *roles* are lost.
 * 2. No administration is provided - it's readonly
 *
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once("auth");

class AuthV3Compat extends Auth {

	private $db, $realm;
	private $incompatiblerights;

	public function AuthV3Compat (&$db, $realm='Assanka') {
		parent::Auth();
		$this->db = $db;
		$this->realm = $realm;
		$this->incompatiblerights = array();
		if (isset($_SERVER["PHP_AUTH_USER"])) $this->processLogin();
	}

	public function checkRights($requiredrights=false, $redirectonbad=true) {
		if (!is_array($requiredrights)) $requiredrights = array($requiredrights);
		foreach ($requiredrights as $right) {
			if (in_array($right, $this->incompatiblerights)) {
				trigger_error("This permission column is not upgradable to core v4", E_USER_ERROR);
			}
		}
		return parent::checkRights($requiredrights=false, $redirectonbad=true);
	}

	protected function showLogin() {
		header("HTTP/1.1 401 Unauthorized");
		header('WWW-Authenticate: Basic realm="'.$this->realm.'"');
    	parent::showLogin();
	}

	protected function showInsufficientRights($rightrequired) {
		header("HTTP/1.1 403 Forbidden");
		parent::showInsufficientRights($rightrequired);
	}	

	protected function showLogout() {
		parent::showLogout();
	}

	protected function processLogin() {
		$username = trim($_SERVER["PHP_AUTH_USER"]);

		if (!isset($_SESSION["auth"]) or !isset($_SESSION["auth"]["cache"]["username"]) or $_SESSION["auth"]["cache"]["username"] != $username) {
			$_SESSION["auth"]["cache"]["details"] = $this->getDetailsForUser($username);
			$_SESSION["auth"]["cache"]["rights"] = $this->getRightsForUser($username);
			$_SESSION["auth"]["cache"]["username"] = $username;
		}

		$this->authenticateduser = $username;
		$this->user = $_SESSION["auth"]["cache"]["details"];
		$this->rights = $_SESSION["auth"]["cache"]["rights"];
		return true;
	}

	public function getUsersWithRight($right) {
		if (strpos($right,'.') !== false) $right = substr($right, 0, strpos($right,'.'));
		if ($right == "support") {
			$res = $this->db->query("SELECT htaccessuser FROM cfg_adminusers WHERE supportuserid IS NOT NULL");
		} else {
			$tabname = preg_replace("/[^0-9a-z]+/i", "_", strtolower($right));
			$this->db->setErrorSuppression();
			$res = $this->db->query("SELECT htaccessuser FROM cfg_adminusers WHERE permissions_".$tabname." IS NOT NULL AND permissions_".$tabname." != 'no access'");
			$this->db->setErrorSuppression(false);
		}
		$users = array();
		while ($row = $this->db->getRow($res)) {
			$users[] = $row["htaccessuser"];
		}
		return $users;
	}

	public function getDetailsForUser($username) {
		$user = $this->db->queryRow("SELECT * FROM cfg_adminusers WHERE htaccessuser=%s", $username);
		if (!$user) return false;
		$ret = array();
		$ret["username"] = $username;
		$ret["displayname"] = $user["name"];
		$ret["email"] = $user["email"];
		if (!empty($user["supportuserid"])) $ret["supportkey"] = $user["supportuserid"];
		return $ret;
	}

	public function getRightsForUser($username) {
		$user = $this->db->queryRow("SELECT * FROM cfg_adminusers WHERE htaccessuser=%s", $username);
		$this->db->query("DESCRIBE cfg_adminusers");
		$fields = array();
		while ($row = $this->db->getRow()) {
			if (preg_match("/permissions_([a-z0-9_]+?)(_role)?$/i", $row["Field"], $m) and $user[$row["Field"]] != "no access") {
				if (preg_match("/^enum\((.+)\)$/", $row["Type"], $n)) {
					$vals = Common::parseCSV($n[1]);
					if (sizeof($vals[0]) > 2) {
						$this->incompatiblerights[] = $m[1];
					} else{
						$ret[] = $m[1];
					}
				} else {
					$this->incompatiblerights[] = $m[1];
				}
			}
		}
		if (!empty($user["supportuserid"])) $ret[] = "support";
		return $ret;
	}

	public function getAllUsers() {
		$matchingusers = array();
		$res = $this->db->query("SELECT htaccessuser FROM cfg_adminusers ORDER BY htaccessuser");
		while ($user = $this->db->getRow()) {
			$matchingusers[] = $user["username"];
		}
		return $matchingusers;
	}

	public function getAllDetailKeys() {
		trigger_error("Detail keys are not available in v3 compatibility mode", E_USER_ERROR);
	}
	public function setPassword($username, $password) {
		trigger_error("Authentication is read-only in v3 compatibility mode", E_USER_ERROR);
	}

	public function deleteUser($username) {
		trigger_error("Authentication is read-only in v3 compatibility mode", E_USER_ERROR);
	}

	public function setDetails($data, $username=false) {
		trigger_error("Authentication is read-only in v3 compatibility mode", E_USER_ERROR);
	}

	public function grantRight($right, $username=false) {
		trigger_error("Authentication is read-only in v3 compatibility mode", E_USER_ERROR);
	}

	public function revokeRight($right, $username=false) {
		trigger_error("Authentication is read-only in v3 compatibility mode", E_USER_ERROR);
	}

	public function setRights($rights, $username=false) {
		trigger_error("Authentication is read-only in v3 compatibility mode", E_USER_ERROR);
	}

	public function logout($redirect=true) {
		trigger_error("Logout not possible in v3 compatibility mode", E_USER_ERROR);
	}
}
