<?php
/**
 * Authentication helper: Gatepass API
 *
 * Authenticates users using the Gatepass HTTP API.
 *
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once(dirname(__FILE__)."/auth");
require_once($_SERVER['CORE_PATH'] . "/helpers/gatepass/api");

class AuthGatepass extends Auth {

	protected $_db, $_gatepass, $_rightsnamespace, $_rightskey, $_errors, $_gatepassHost;

	// Constructor
	public function AuthGatepass (&$db, $urlprefix, $urlreqtok, $urlaccesstok, $urlauthorise, $consumerkey, $consumersecret) {
		parent::Auth();
		$this->_db = $db;
		$this->_gatepass = new GatepassAPI($urlprefix, $urlreqtok, $urlaccesstok, $urlauthorise, $consumerkey, $consumersecret);
		$this->_rightsnamespace = false;
		$this->_rightskey = false;
		$this->_errors = array();

		// parse host from urlprefix
		$parts = parse_url($urlprefix);
		if (empty($parts['host'])) {
			throw new InvalidArgumentException('urlprefix has no host');
		}
		$this->_gatepassHost = $parts['host'];

		// Get user details from session if available, to avoid unnecessary Gatepass API requests
		if (isset($_SESSION["auth"]["cache"])) {
			$this->authenticateduser = $_SESSION["auth"]["cache"]["authenticateduser"];
			$this->user = $_SESSION["auth"]["cache"]["user"];
			if (isset($_SESSION["auth"]["cache"]["rights"])) {
				$this->rights = $_SESSION["auth"]["cache"]["rights"];
			}
		}
	}

	public function getGatepassHost() {
		return $this->_gatepassHost;
	}

	public function getCurrentUserId() {
		return $this->user['gatepass']['userid'];
	}

	public function setGatePassUserAgent($organisation, $productname, $version) {
		$this->_gatepass->setUserAgent($organisation, $productname, $version);
	}

	// Check that the user is logged in and, optionally, has the rights specified in $requiredrights
	public function checkRights($requiredrights = false, $redirectonbad = true) {
		if (!$this->authenticateduser) return $this->processLogin();
		if (!$requiredrights) return true;
		if (!$this->_rightskey) return $this->_error("checkRights: Cannot check specific rights - no rights-key is set");
		return parent::checkRequiredRights($requiredrights, $redirectonbad);	
	}

	// Present login screens and attempt to log the user in
	public function processLogin() {
		if (!$this->_gatepass->authorise()) {
			?>
			<!DOCTYPE html public "-//w3c//dtd html 4.01 transitional//en" "http://www.w3.org/tr/1999/rec-html401-19991224/loose.dtd">
			<html>
			<head>
			<title>No account</title>
			</head>
			<body><h1>No account</h1><hr><p>You do not have an account on this application.  Please contact your administrator for assistance.</p>
			<p><?=$this->_gatepass->getLastError()?></p>
			</body>
			</html>
			<?php
			exit;
		}
		$gatepassuser = $this->_gatepass->getCurrentUser();
		$this->_setVar("authenticateduser", $gatepassuser['accesstoken']);
		if (!$data = $this->_getLatestData($gatepassuser['accesstoken'])) {
			return $this->_error("processLogin: Could not fetch latest data from Gatepass");
		}
		$this->_setVar("user", $data);
		return true;
	}


	// Store the data key used to store the rights of the user in Gatepass
	// If this to false, storing rights will be disabled.
	public function setRightsField($namespace=false, $key=false) {
		if (!(is_string($namespace) or !$namespace)) {
			return $this->_error("setRightsField: invalid namespace (expected string or boolean)");
		}
		if (!(is_string($key) or !$key)) {
			return $this->_error("setRightsField: invalid key (expected string or boolean)");
		}
		if ((!$namespace and $key) or ($namespace and !$key)) {
			return $this->_error("setRightsField: one of namespace and key supplied, but not the other");
		}
		$this->_rightsnamespace = $namespace;
		$this->_rightskey = $key;
		return true;
	}

	// Find all users in the local DB that have a specified right
	public function getUsersWithRight($right) {
		if (!$this->_rightskey) {
			return $this->_error("getUsersWithRight: no rights-key is set");
		}
		$matchingusers = array();
		$this->_db->query("SELECT accesstoken, rights FROM `".$this->_dbtable."`");
		while ($user = $this->_db->getRow()) {
			if ($this->hasRights($right, explode(",", $user["rights"]))) $matchingusers[] = $user["accesstoken"];
		}
		return $matchingusers;
	}

	// Find all users in the local DB
	public function getAllUsers() {
		$matchingusers = array();
		$this->_db->query("SELECT id FROM `".$this->_dbtable."` ORDER BY id");
		while ($user = $this->_db->getRow()) {
			$matchingusers[] = $user["id"];
		}
		return $matchingusers;
	}

	// Get an array of all user-information keys stored in the database
	public function getAllDetailKeys() {
		$fields = array();
		$this->_db->query("SELECT details FROM `".$this->_dbtable."`");
		while ($dets = $this->_db->getRow()) {
			$dets = unserialize($dets["details"]);
			if (!empty($dets)) foreach($dets as $key=>$val) $fields[$key] = 1;
		}
		$keys = array_keys($fields);
		sort($keys);
		return $keys;
	}

	// Get all information stored on a particular user
	public function getDetailsForUser($accesstoken = false) {
		if (empty($accesstoken)) {
			if (!$this->authenticateduser) {
				return $this->_error("setDetails: Cannot get details of current user - no user is logged in");
			}
			$accesstoken = $this->authenticateduser;
		}
		$user = $this->_db->queryRow("SELECT details FROM `".$this->_dbtable."` WHERE {accesstoken}", array("accesstoken"=>$accesstoken));
		if ($user) {
			$details = ($user["details"]) ? unserialize($user["details"]) : array();
			return $details;
		} else {
			return $this->_error("getDetailsForUser: accesstoken not found");;
		}
	}

	// Get all rights belonging to a particular user
	public function getRightsForUser($accesstoken) {
		if (!$this->_rightskey) return $this->_error("getRightsForUser: no rights-key is set");
		if (!$this->_getLatestData($accesstoken)) {
			return $this->_error("getRightsForUser: Could not get latest data from Gatepass");
		}
		$rights = $this->_db->querySingle("SELECT rights FROM `".$this->_dbtable."` WHERE {accesstoken}", array("accesstoken"=>$accesstoken));
		return ($rights) ? explode(",",$rights) : false;
	}

	// Set user information, both in local DB and in Gatepass
	public function setDetails($data, $accesstoken=false) {
		if (empty($accesstoken)) {
			if (!$this->authenticateduser) {
				return $this->_error("setDetails: Cannot set details of current user - no user is logged in");
			}
			$accesstoken = $this->authenticateduser;
		}

		// Update Gatepass
		if (!is_array($data)) {
			return $this->_error("setDetails: supplied data was not an array (actual type: ".gettype($data).")");
		}
		if (!$this->_setGatepassUser($accesstoken)) {
			return $this->_error("setDetails: Could not change gatepass user");
		}

		foreach ($data as $namespace => $dataset) {
			if (!is_array($dataset)) {
				$err = "setDetails: supplied data was not in the correct format.  Expected:
				
				Array (
					[namespace] => Array(
						[key]=> [newvalue],
						[key]=> [newvalue]
						...
					),
					[namespace] => Array(
						[key]=> [newvalue],
						[key]=> [newvalue]
						...
					),
					...
				)";
				return $this->_error($err);
			}
			foreach ($dataset as $key => $value) {
				if (!$this->_gatepass->setData($namespace, $key, $value)) {
					return $this->_error("setDetails: Gatepass error when uploading '".$key."'");
				}
			}
		}

		// Update local DB
		return $this->_getLatestData($accesstoken);
	}
	
	// Grant a specific right to a particular user
	public function grantRight($right, $accesstoken=false) {
		if (!$this->_rightskey) return $this->_error("grantRight: no rights-key is set");;

		// Generate array of new rights
		$newrights = array();
		if (!$accesstoken) {
			if (!$this->authenticateduser) {
				return $this->_error("grantRight: Cannot grant rights to current user - no user is logged in");
			}
			$accesstoken = $this->authenticateduser;
			if (!in_array($right, $this->rights)) {
				$newrights = $this->rights;
				$newrights[] = $right;
				$newrights = join(",", $newrights);
			}
		} else {
			$existingrights = explode(",", $this->_db->querySingle("SELECT rights FROM ".$this->_dbtable." WHERE accesstoken='".$this->_db->sqlenc($accesstoken)."'"));
			if (!in_array($right, $existingrights)) {
				$existingrights[] = $right;
				$newrights = join(",", $existingrights);
			}
		}

		// Store new rights
		return $this->setRights($newrights, $accesstoken);
	}

	// Remove a specific right from a particular user
	public function revokeRight($right, $accesstoken=false) {
		if (!$accesstoken) {
			if (!$this->authenticateduser) {
				return $this->_error("revokeRight: Cannot revoke rights of current user - no user is logged in");
			}
			$accesstoken = $this->authenticateduser;
			$existingrights = $this->rights;
		} else {
			$existingrights = explode(",", $this->_db->querySingle("SELECT rights FROM ".$this->_dbtable." WHERE accesstoken='".$this->_db->sqlenc($accesstoken)."'"));
		}
		$newrights = $existingrights;
		if (in_array($right, $newrights)) {
			array_splice($newrights, array_search($right, $newrights), 1);
		}
		return $this->setRights($newrights, $accesstoken);
	}

	// Set all rights for a particular user
	public function setRights($newrights, $accesstoken=false) {

		// Fetch old rights for version checking and update session
		if (!$accesstoken) {
			if (!$this->authenticateduser) {
				return $this->_error("setRights: Cannot set rights of current user - no user is logged in");
			}
			$accesstoken = $this->authenticateduser;
			$params = array("accesstoken"=>$accesstoken, "rights"=>$newrights);
		} else {
			$params = array("accesstoken"=>$accesstoken, "rights"=>$newrights);
		}

		// Update Gatepass
		if (!$this->_setGatepassUser($accesstoken)) {
			return $this->_error("setRights: Could not change gatepass user");
		}
		if (!$this->_gatepass->setData($this->_rightsnamespace, $this->_rightskey, $params["rights"])) {
			return $this->_error("setRights: Gatepass error when uploading new rights");
		}

		// Update local DB
		return $this->_getLatestData($accesstoken);
	}

	// Show a screen explaining that the user does not have sufficient rights
	// to do what they were trying to do.
	protected function showInsufficientRights($rightrequired) {
		header("HTTP/1.1 403 Forbidden");
		header("Content-type: text/html");
		parent::showInsufficientRights($rightrequired);
	}


	// Fetch latest data for all local users from gatepass, and update local cache
	protected function _getBatchLatestData($userIds = array(), $lastUpdated = null) {

		// Fetch user data
		$this->_gatepass->setOutputFormat("php");
		$data = $this->_gatepass->getUpdatedProfiles($userIds, $lastUpdated);
		if (!$data) return $this->_error("_getLatestData: Could not fetch batch data");
		return $data;
	}

	// Fetch latest data from gatepass, and update local cache
	private function _getLatestData($accesstoken) {

		$sameUser = $accesstoken == $this->authenticateduser;

		// Set correct gatepass user
		if (!$this->_setGatepassUser($accesstoken)) {
			return $this->_error("_getLatestData: Could not change gatepass user");
		}

		// Fetch user data
		$this->_gatepass->setOutputFormat("php");
		$data = $this->_gatepass->getProfile();
		if (!$data) return $this->_error("_getLatestData: Could not fetch data for $accesstoken");

		// Update class properties
		if ($this->_rightskey) {
			$rights = isset($data[$this->_rightsnamespace][$this->_rightskey])? $data[$this->_rightsnamespace][$this->_rightskey] : '';
			unset($data["rights"]);
		}
		if ($sameUser) {
			if ($this->_rightskey) {
				$this->_setVar("rights", explode("\n", $rights));

				// gatepass stores the check type delimited with newlines but perms are delimited by comma
				$rights = str_replace("\n", ',', $rights);
			}
			$this->_setVar("user", $data);
		}
		// Update database
		$gatepassuser = $this->_gatepass->getCurrentUser();
		$this->_db->query("REPLACE INTO `".$this->_dbtable."` SET id='".$this->_db->sqlenc($data['gatepass']['userid'])."', displayname='".$this->_db->sqlenc($data['gatepass']['displayname'])."', accesstoken='".$this->_db->sqlenc($accesstoken)."', tokensecret='".$this->_db->sqlenc($gatepassuser['toksecret'])."', lastdownloadtime=NOW(), details='".$this->_db->sqlenc(serialize($data))."'".($this->_rightskey?(", rights='".$this->_db->sqlenc($rights)."'"):""));
		return $data;
	}

	// Set gatepass client user.  If the new user is different to the current user
	// (i.e. if we are changing user) the function sets the gatepass conflict date appropriately)
	private function _setGatepassUser($accesstoken) {
		$currentuser = $this->_gatepass->getCurrentUser();
		if ($currentuser && ($accesstoken == $currentuser["accesstoken"])) {
			return true;
		}
		$user = $this->_db->queryRow("SELECT id, tokensecret, accesstoken, lastdownloadtime FROM `".$this->_dbtable."` WHERE accesstoken='".$this->_db->sqlenc($accesstoken)."'");
		if (!$user) {
			return $this->_error("_setGatepassUser: Could not switch gatepass user: accesstoken '".$accesstoken."' not found");
		}
		if (empty($user["lastdownloadtime"])) {
			return $this->_error("_setGatepassUser: Could not switch gatepass user: no last download time stored");
		}
		preg_match("/\b(\d{4})\-(\d\d)\-(\d\d)(\s*(\d\d):(\d\d):(\d\d))\b/", $user["lastdownloadtime"], $d);
		if (!$this->_gatepass->setConflictDate(mktime($d[5], $d[6], $d[7], $d[2], $d[3], $d[1]))) {
			return $this->_error("_setGatepassUser: Could not set conflict date to '".$user["lastdownloadtime"]."'");
		}
		return $this->_gatepass->setUser($user['accesstoken'], $user["tokensecret"]);
	}

	// Store a value in both a class property, and the session
	private function _setVar($key, $value) {
		if (!in_array($key, array("user", "rights", "authenticateduser"))) {
			return $this->_error("_setVar: invalid key (".$key."), expected 'user', 'rights', or 'authenticateduser'");
		}
		$this->$key = $value;
		$_SESSION["auth"]["cache"][$key] = $value;
		return true;
	}

	// Queue an error message and return false
	private function _error($str) {
		$this->_errors[] = $str;
		return false;
	}

	// Get the current array of errors
	public function getErrorSequence() {
		return $this->_errors;
	}

	public function updateUser($accesstoken = false) {
		if (!$accesstoken) {
			if (!$this->authenticateduser) {
				trigger_error('No accesstoken supplied and no current user', E_USER_ERROR);
			}
			$accesstoken = $this->authenticateduser;
		}

		return $this->_getLatestData($accesstoken);
	}

	// REVIEW:RS:20091109: This isn't a long term solution, as we'll have gatepass enabled apps which don't have access to memcache
	// AB: Ability to unlock vault secrets, Gatepass can't unlock a secure field without the user cookie that contains the symmetrically encrypted GP password.
	public function retrievePassword($ns, $keyname) {
		if (!$this->_rightskey) {
			return false;
		}
		$pass = $this->getData($ns, $keyname);
		if (!$pass) {
			return false;
		}
		$pass = base64_decode($pass);
		$privkey = openssl_pkey_get_private(GATEPASS_PRIVATE_KEY);
		openssl_private_decrypt($pass, $decrypted, $privkey);
		return $decrypted;
	}

	protected function getMemcached() {
		return GatepassMemcached::getInstance();
	}
	
	protected function getData($namespace, $datakey) {
		return $this->_gatepass->getData($namespace, $datakey);
	}
}

// REVIEW:AB: Change this to an if function_exists() thing.
if (!empty($gatepassv3Compat)) {
	function checkIfAuth($tabname, $username="", $autoerror = true, $validPermissionLevels = array()) {
		global $auth;

		$tabname = preg_replace("/[^0-9a-z]+/i", "_", strtolower($tabname));
		if ($validPermissionLevels) {
			$perms = array();
			foreach ((array)$validPermissionLevels as $level) {
				$perms[] = strtolower($tabname . '.' . $level);
			}
		} else {
			$perms = strtolower($tabname);
			if (strpos($perms, '.') === false) {
				$perms .= '.*';
			}
		}

		foreach ((array)$perms as $perm) {
			if ($auth->checkRights($perm, false)) {
				return true;
			}
		}

		return $auth->checkRights($perms, $autoerror);
	}
}
?>
