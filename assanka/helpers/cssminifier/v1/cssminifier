<?php
/**
 * CSS Minifier
 *
 * Wraps cssmin, allowing easy CSS minification using a standard configuration.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

// Include the cssmin file
require_once 'cssmin-v3.0.1.php';

class AssankaCSSMinifierV1 {

	private static $filterconfiguration = array(
		'ImportImports'					=> false,
		'RemoveComments'				=> true,
		'RemoveEmptyRulesets'			=> true,
		'RemoveEmptyAtBlocks'			=> true,
		'ConvertLevel3AtKeyframes'		=> false,
		'ConvertLevel3Properties'		=> false,
		'Variables'						=> false,
		'RemoveLastDelarationSemiColon'	=> true,
		'SortRulesetProperties'	        => true
	);

	private static $pluginconfiguration = array(
		'Variables'					=> false,
		'ConvertFontWeight'			=> true,
		'ConvertHslColors'			=> true,
		'ConvertRgbColors'			=> true,
		'ConvertNamedColors'		=> true,
		'CompressColorValues'		=> true,
		'CompressUnitValues'		=> true,
		'CompressExpressionValues'	=> true
	);

	/**
	 * Minify a supplied string.
	 *
	 * Comments are stripped, whitespace removed, empty rulesets and @blocks are
	 * removed, and trailing semicolons are likewise removed.  Font-weights are converted
	 * to numbers, colours are renamed to short forms where possible, and unit values are
	 * compressed.
	 *
	 * Rules are then reordered alphabetically for gzipping.
	 *
	 * @param string $input The CSS string to minify
	 *
	 * @return string A minified CSS string
	 */
	public static function minify($input) {
		CssMin::setVerbose(true);
		$minifier = new CssMinifier($input, self::$filterconfiguration, self::$pluginconfiguration);
		return $minifier->getMinified();
	}

	/**
	 * Minify a supplied string, and then format it for visible output.
	 *
	 * The input is minified using all the rules from minify(), but then is formatted for output
	 * in a consistent format.  This is less suitable for production use but can aid in readability
	 * and debugging.
	 *
	 * @param string $input The CSS string to minify
	 *
	 * @return string A minified and formatted CSS string
	 */
	public static function readableMinify($input) {
		$minifiedCSS = self::minify($input);

		$outputTokens = CssMin::parse($minifiedCSS);
		$outputFormatter = new AssankaCleanPreviewCSSFormatter($outputTokens);
		return (string)$outputFormatter;
	}

	/**
	 * Enable or disable comment-stripping.
	 *
	 * @param boolean $enabled Whether to enable or disable comment-stripping
	 * @return void
	 */
	public static function setRemoveComments($enabled) {
		self::setFilterConfiguration('RemoveComments', $enabled);
	}

	/**
	 * Enable or disable conversion of CSS3 properties to browser-specific counterparts.
	 *
	 * @param boolean $enabled Whether to enable or disable property-conversion
	 * @return void
	 */
	public static function setConvertLevel3Properties($enabled) {
		self::setFilterConfiguration('ConvertLevel3Properties', $enabled);
	}

	/**
	 * Enable or disable sorting of CSS properties by name, improving the gzip compression ratio.
	 *
	 * @param boolean $enabled Whether to enable or disable sorting
	 * @return void
	 */
	public static function setReorderRulesForGzip($enabled) {
		self::setFilterConfiguration('SortRulesetProperties', $enabled);
	}

	/**
	 * Whether to enable or disable converting @keyframes at-rule block to browser specific counterparts.
	 *
	 * @param boolean $enabled Whether to convert @keyframes at-rule block to browser specific counterparts.
	 * @return void
	 */
	public static function setConvertLevel3AtKeyframes($enabled) {
		self::setFilterConfiguration('ConvertLevel3AtKeyframes', $enabled);
	}

	private static function setFilterConfiguration($name, $value) {
		self::$filterconfiguration[$name] = $value;
	}
}

if (!class_exists('AssankaCSSMinifier')) {
	if (function_exists('class_alias')) {
		class_alias('AssankaCSSMinifierV1', 'AssankaCSSMinifier');
	} else {
		class AssankaCSSMinifier extends AssankaCSSMinifierV1 { }
	}
}

class AssankaCleanPreviewCSSFormatter extends aCssFormatter {

	/**
	 * Implements {@link aCssFormatter::__toString()}.
	 *
	 * @return string
	 */
	public function __toString() {
		$r = array();
		$level = 0;
		for ($i = 0, $l = count($this->tokens); $i < $l; $i++) {
			$token = $this->tokens[$i];
			$class = get_class($token);
			$indent = str_repeat("\t", $level);

			// Note that this can't be converted to a switch statement as switch uses loose comparison,
			// and several of these values extend each other's classes.
			if ($class === 'CssCommentToken') {
				$lines = array_map('trim', explode("\n", $token->Comment));
				for ($ii = 0, $ll = count($lines); $ii < $ll; $ii++) {
					$r[] = $indent . (substr($lines[$ii], 0, 1) == '*' ? ' ' : '') . $lines[$ii];
				}

			} elseif ($class === 'CssAtCharsetToken') {
				$r[] = $indent . '@charset ' . $token->Charset . ';';

			} elseif ($class === 'CssAtFontFaceStartToken') {
				$r[] = $indent . "@font-face {\n";
				$level++;

			} elseif ($class === 'CssAtImportToken') {
				$r[] = $indent . '@import ' . $token->Import . ' ' . implode(', ', $token->MediaTypes) . ';';

			} elseif ($class === 'CssAtKeyframesStartToken') {
				$r[] = $indent . '@'.$token->AtRuleName.' "' . $token->Name . '" {'."\n";
				$level++;

			} elseif ($class === 'CssAtMediaStartToken') {
				$r[] = $indent . '@media ' . implode(', ', $token->MediaTypes) . " {\n";
				$level++;

			} elseif ($class === 'CssAtPageStartToken') {
				$r[] = $indent . "@page {\n";
				$level++;

			} elseif ($class === 'CssAtVariablesStartToken') {
				$r[] = $indent . '@variables ' . implode(', ', $token->MediaTypes) . " {\n";
				$level++;

			} elseif ($class === 'CssRulesetStartToken' or $class === 'CssAtKeyframesRulesetStartToken') {
				$r[] = $indent . implode(', ', $token->Selectors) . ' {';
				$level++;

			} elseif ($class == 'CssAtFontFaceDeclarationToken'
						or $class === 'CssAtKeyframesRulesetDeclarationToken'
						or $class === 'CssAtPageDeclarationToken'
						or $class == 'CssAtVariablesDeclarationToken'
						or $class === 'CssRulesetDeclarationToken') {
				$declaration = ' ' . $token->Property . ': ';
				if ($this->padding) {
					$declaration = str_pad($declaration, $this->padding, ' ', STR_PAD_RIGHT);
				}
				$r[] = $declaration . $token->Value . ($token->IsImportant ? ' !important' : '') . ';';

			} elseif ($class === 'CssAtFontFaceEndToken'
						or $class === 'CssAtMediaEndToken'
						or $class === 'CssAtKeyframesEndToken'
						or $class === 'CssAtKeyframesRulesetEndToken'
						or $class === 'CssAtPageEndToken'
						or $class === 'CssAtVariablesEndToken'
						or $class === 'CssRulesetEndToken') {
				$level--;

				// Remove previous trailing ';'
				$previousindex = count($r) - 1;
				if ($previousindex >= 0) {
					$previousvalue = &$r[$previousindex];
					if (substr($previousvalue, -1) == ';') $previousvalue = substr($previousvalue, 0, -1);
				}
				$r[] = " }\n";
			}
		}

		return implode('', $r);
	}
}
