<?php
/*
########################################################
Support functions - a few common support functions.

Split from supportlib on 4th October 2007 by WV

04/11/2004
Andrew Betts
Assanka Ltd
########################################################
*/




// This file is deprecated, and should no longer be in use.  This error designed to catch cases where it is still being used.
trigger_error('Deprecated code in use', E_USER_DEPRECATED);



define("DAYOFWEEK_SAT", 6);
define("DAYOFWEEK_SUN", 0);

/*
Support working time difference function.  Takes two times given to it, and returns the difference
in working time according to the support package.

See the appmodel for the support package definitions.

The function requires a starting timestamp and an ending timestamp, as well as optional supportPackage
and request importance variables used to determine what 'working hours' applies to (defaults to standard).
*/
function getWorkingTimeDifference ($starttime, $endtime, $supportpackage = "standard", $requestimportance = "normal", $returnrawseconds = false) {

	// If the support package or importance were supplied as blank strings, reset them to defaults.
	if (empty($supportpackage)) $supportpackage = "standard";
	if (empty($requestimportance)) $requestimportance = "normal";

	// Ensure we have a definition of the support package and importance present in the model
	if (empty(Model::$supportpackageopts[$supportpackage]))
		trigger_error("Support package not defined or not found", E_USER_ERROR);
	$packagedefinition = Model::$supportpackageopts[$supportpackage];
	if (empty($packagedefinition["responsetime"][$requestimportance]))
		trigger_error("Support request importance level not defined in support package", E_USER_ERROR);

	// Calculate the weekday and weekend working hours for the specified package
	$workinghours = $packagedefinition["workinghours"];
	$weekdayworkinghours = $weekendworkinghours = 0;
	for ($i = 0; $i < 24; $i++) {
		$weekdayworkinghours += !empty($workinghours["weekday"][$i]);
		$weekendworkinghours += !empty($workinghours["weekend"][$i]);
	}
	$timeaccruesoutofworkinghours = ($packagedefinition["responsetime"][$requestimportance]["outofworkinghours"] != -1);

	// If there is no possible way of accruing time, always return 0.
	if ($packagedefinition["responsetime"][$requestimportance]["inworkinghours"] == -1 or
		(($weekdayworkinghours + $weekendworkinghours) == 0 and $packagedefinition["responsetime"][$requestimportance]["outofworkinghours"] == -1)) {
		if ($returnrawseconds) return 0;
		else return "0 (out of service hours)";
	}

	// If the time is set to accumulate even during non-working hours for this package/importance,
	// return a difference based entirely of the number of seconds.
	if ($packagedefinition["responsetime"][$requestimportance]["outofworkinghours"] != -1) {
		$accruedseconds = $endtime - $starttime;
		if ($returnrawseconds) return $accruedseconds;
		
		if ($accruedseconds < 60) {
			return ($accruedseconds == 1)?"1 second":$accruedseconds." seconds";
		} elseif ($accruedseconds < 3600) {
			return ($accruedseconds < 120)?"1 minute":round($accruedseconds/60)." minutes";
		} elseif ($accruedseconds < 24 * 3600) {
			return ($accruedseconds < 7200)?"1 hour":round($accruedseconds/3600)." hours";
		} elseif ($accruedseconds < 14 * 24 * 3600) {
			return ($accruedseconds < (48*3600))?"1 day":round($accruedseconds/(24 * 3600))." days";
		} elseif ($accruedseconds < 8 * 7 * 24 * 3600) {
			return round($accruedseconds/(7 * 24 * 3600))." weeks";
		} elseif ($accruedseconds < 365 * 24 * 3600) {
			return round($accruedseconds/(4.357 * 7 * 24 * 3600))." months";
		} else {
			return round($accruedseconds/(365.24 * 24 * 3600))." years";
		}
	}

	// If the time has been requested in seconds, or the applicable timespan only covers up to two weeks,
	// walk through the specified time period and include only the applicable hours/days.
	if ($returnrawseconds || ($endtime - $starttime < (14 * 24 * 3600))) {
		$accruedseconds = 0;
		$weekdayhoursaccrued = $weekendhoursaccrued = 0;

		// Select the starting whole hour and ending whole hour timestamps
		$starthour = ceil($starttime / 3600) * 3600;
		$endhour = floor($endtime / 3600) * 3600;
		if ($endhour < $starthour) $endhour = $starthour;

		// Walk through the intervening timespan, hour by hour.
		for ($i = $starttime; $i <= $endhour; ) {
			$dayofweek = date("w", $i);
			if ($dayofweek == DAYOFWEEK_SAT || $dayofweek == DAYOFWEEK_SUN) $timetype = "weekend";
			else $timetype = "weekday";
			if (!empty($workinghours[$timetype][date("G", $i)])) {

				// If this is the first or last partial hour, add only the applicable part of the hour.
				if ($i < $starthour) {
					if ($endtime > $starthour) $increment = $starthour - $starttime;
					else $increment = $endtime - $starttime;
				} elseif ($i >= $endhour) {
					$increment = $endtime - $endhour;
				} else {
					$increment = 3600;
				}
				$accruedseconds += $increment;
				
				// Update the working days count as appropriate
				${$timetype."hoursaccrued"} += ($increment / 3600);
			}
			
			// Increment appropriately.
			if ($i < $starthour) {
				if ($endtime > $starthour) $i = $starthour;
				else $i = $endhour + 1;
			} elseif ($i >= $endhour) {
				$i = $endhour + 1;
			} else {
				$i += 3600;
			}
		}

		$workingdaysintimespan = 0;
		if ($weekdayworkinghours) $workingdaysintimespan += $weekdayhoursaccrued / $weekdayworkinghours;
		if ($weekendworkinghours) $workingdaysintimespan += $weekendhoursaccrued / $weekendworkinghours;
		
		// Return the time difference as requested
		if ($returnrawseconds) return $accruedseconds;
		if ($accruedseconds < 60) {
			return ($accruedseconds == 1)?"1 second":$accruedseconds." seconds";
		} elseif ($accruedseconds < 3600) {
			return ($accruedseconds < 120)?"1 minute":round($accruedseconds/60)." minutes";
		} elseif ($workingdaysintimespan >= 2) {
			return round($workingdaysintimespan)." days";
		} else {
			return ($accruedseconds < 7200)?"1 hour":round($accruedseconds/3600)." hours";
		}
	}
	
	// For time periods of over two weeks and string display, working time is ignored.
	$accruedseconds = $endtime - $starttime;

	if ($accruedseconds < 8 * 7 * 24 * 3600) {
		return round($accruedseconds/(7 * 24 * 3600))." weeks";
	} elseif ($accruedseconds < 365 * 24 * 3600) {
		return round($accruedseconds/(4.357 * 7 * 24 * 3600))." months";
	} else {
		return round($accruedseconds/(365.24 * 24 * 3600))." years";
	}
}

// Check to see if a specific time is within support hours.
function isTimeInSupportHours($thetime, $supportpackage = "standard", $requestimportance = "normal") {
	
	// If the support package or importance were supplied as blank strings, reset them to defaults.
	if (empty($supportpackage)) $supportpackage = "standard";
	if (empty($requestimportance)) $requestimportance = "normal";
	
	// Ensure we have a definition of the support package and importance present in the model
	if (empty(Model::$supportpackageopts[$supportpackage]))
		trigger_error("Support package not defined or not found", E_USER_ERROR);
	$packagedefinition = Model::$supportpackageopts[$supportpackage];
	if (empty($packagedefinition["responsetime"][$requestimportance]))
		trigger_error("Support request importance level not defined in support package", E_USER_ERROR);

	// If time on this support package/level accumulates even "out of hours", always return true
	if ($packagedefinition["responsetime"][$requestimportance]["outofworkinghours"] != -1) {
		return true;
	}

	// Check the working hours definition to see if the selected time is within working hours
	$dayofweek = date("w", $thetime);
	if ($dayofweek == DAYOFWEEK_SAT || $dayofweek == DAYOFWEEK_SUN) $timetype = "weekend";
	else $timetype = "weekday";
	if (!empty($packagedefinition["workinghours"][$timetype][date("G", $thetime)])) {
		return true;
	}
	
	return false;
}

// Move a file from SUPPORT_FILES_DIR to permanent location and returns the new file name
function moveFileToNewServer($fullfilepath) {
	$postfields = array();
	$postfields["filename"] = end(explode("/",$fullfilepath));
	$postfields["filedata"] = base64_encode(file_get_contents($fullfilepath));

	$ch = curl_init();
	curl_setopt($ch, CURLOPT_VERBOSE, 1);
	curl_setopt($ch, CURLOPT_URL, SUPPORT_FILES_SAVE_HOST."/uploadfile" );
	curl_setopt($ch, CURLOPT_POST, 1 );
	curl_setopt($ch, CURLOPT_POSTFIELDS, $postfields);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
	$newfilename = curl_exec($ch);

	$failed = false;
	if (curl_errno($ch)) {
		trigger_error("cURL error: ".curl_error($ch),E_USER_ERROR);
		$failed = true;
	};
	curl_close($ch);
	if ($failed) {
		return false;
	} else {
		unlink($fullfilepath);
		return $newfilename;
	}
}

// Ensure folder permissions are all set correctly for FCKEditor use in the knowledge editor
function knowledgeBaseCheckPermissions() {
	$folderchecks = array($_SERVER["DOCUMENT_ROOT"]."/lib/tmp/cmsfiles", $_SERVER["DOCUMENT_ROOT"]."/lib/tmp/cmsfiles/File", $_SERVER["DOCUMENT_ROOT"]."/lib/tmp/cmsfiles/Image", $_SERVER["DOCUMENT_ROOT"]."/lib/tmp/cmsfiles/Flash", $_SERVER["DOCUMENT_ROOT"]."/lib/tmp/cmsfiles/Media");
	$old_umask = umask(0);
	foreach ($folderchecks as $path) {
		if (!file_exists($path)) mkdir($path, 0777);
		if (!is_writable($path)) chmod($path, 0777);
	}
	umask($old_umask);
}

?>