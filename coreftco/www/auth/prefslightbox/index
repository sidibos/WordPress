<?php
/**
 * Provides UI for updating user profile in OAC
 *
 * Renders in a lightbox to allow it to be deployed on any site
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

// Load and configure required core libraries
require_once $_SERVER['CORE_PATH'].'/helpers/errorhandler/v5/errorhandler';
require_once $_SERVER['CORE_PATH'].'/helpers/templatemanager/v5/templatemanager';
require_once $_SERVER['CORE_PATH'].'/helpers/logger/v1/logger';
require_once $_SERVER['CORE_PATH'].'/helpers/http/HTTPRequest';
require_once $_SERVER['COREFTCO'].'/helpers/cacheability/cacheability';
require_once $_SERVER['COREFTCO'].'/helpers/auth/v2/ftauthV2';

ErrorHandler::init();
ErrorHandler::setTemplate('html', $_SERVER["DOCUMENT_ROOT"]."/auth/prefslightbox/lib/tem/errortemplate.html");

$logger = new AssankaLoggerV1('coreftco-prefslightbox');
$logger->setLogMethod('file');

$tm = new TemplateManager($_SERVER['DOCUMENT_ROOT']."/auth/prefslightbox/lib/tem");


// Define possible data sets
$sets = array("pseudonym"=>array('pseudonym'));

// Authenticate the user based on FT cookies.  Do not set a PHP session or redirect to registration.
FTAuthV2::useSession(false);
FTAuthV2::disableRedirects();
FTUserV2::setNewInstancesReadFromWriteDBs(true);
$ftuser = FTAuthV2::authenticate();

// Do not allow this script to be cached
Cacheability::noCache();

// If supplied, populate template manager with the return URL
if (!empty($_REQUEST['returnurl'])) $tm->set("returnurl", $_REQUEST['returnurl']);

// Let the template know whether this update is forced upon the user (so copy can be adjusted: eg 'you must set a pseudonym')
$tm->set('isforced', !empty($_REQUEST['force']));

// If user is not logged in, display an error (should not be encountered, as the user should not be given the opportunity to click the link unless logged in)
if (!$ftuser) {
	$tm->set('content', $tm->render('content-notsignedin'));
	exit($tm->render('page'));
}

// Prevent use of async for DAM updates to ensure changes are saved immediately and we avoid race conditions
$ftuser->setAsync(false);

// If the requested set is not recognised, serve the default set
$setname = (empty($_REQUEST['set']) or !isset($sets[$_REQUEST['set']])) ? 'pseudonym' : $_REQUEST['set'];
$fieldlist = $sets[$setname];

// If the user is posting an update, save changes and serve a script to reload the page
$errors = array();
if (!empty($_POST)) {

	// Validation
	$data = array();
	if ($setname == 'pseudonym') {
		if (empty($_POST["pseudonym"])) $errors["pseudonym"] = "Please choose a pseudonym";
		elseif (preg_match("/User\d+/i", $_POST["pseudonym"])) $errors["pseudonym"] = "Please personalise your pseudonym";
		elseif (!$ftuser->canUsePseudonym($_POST["pseudonym"])) $errors["pseudonym"] = "Sorry, this pseudonym is already in use by someone else";
		else $data['pseudonym'] = $_POST['pseudonym'];
	}

	if (empty($errors)) {
		$ftuser->setUserData($data);

		$logdata = $data;
		$logdata['set'] = $setname;
		$logdata['eid'] = $ftuser->get('eid');

		// Send purge Auth request to Inferno using the Alphaville site ID (all FT sites share the same auth namespace so it doesn't matter which one we use)
		if (isset($_SERVER['INFERNO_API_URL'])) {
			$http = new HTTPRequest($_SERVER['INFERNO_API_URL']);
			$http->setMethod('POST');

			// Form the request envelope.  Request does not need to be signed as it's executing the purgeAuth method as the authenticated user
			$postdata = array('site'=>2, 'output'=>array('format'=>'json','themed'=>0,'data'=>1), 'user'=>'FTDam', 'operations'=>array(array('method'=>'purgeAuth')));
			$http->setRequestBody(json_encode($postdata));
			$http->setHeader('Content-Type', 'application/json');

			// Add the user's cookies from this request to the inferno one so it can use the FTDam plugin to authenticate them
			$headers = apache_request_headers();
			if (isset($headers['Cookie'])) $http->setHeader('Cookie', $headers['Cookie']);

			try {
				$resp = $http->send();
				if ($resp->getResponseStatusCode() == 200) {
					$data = $resp->getData('json');
					$logdata['inferno_purge'] = 'purged_'.$data[0];
				} else {
					$logdata['inferno_purge'] = 'http_'.$resp->getResponseStatusCode();
				}
			} catch (Exception $e) {
				$logdata['inferno_purge'] = $e->getMessage();
			}
		} else {
			$logdata['inferno_purge'] = 'api_url_missing';
		}

		$logger->write($logdata);

		// Display a redirect JS response
		$tm->set("content", $tm->render('content-successreload'));
		echo $tm->render('page');
		exit;

	} else {
		$tm->set($_POST);
		foreach($errors as $field=>$error) $tm->set("e_".$field, $error);
	}

// If no POST, pre-fill existing data
} else {
	foreach ($fieldlist as $field) $tm->set($field, $ftuser->get($field));
}

// Serve the appropriate form - with validation errors highlighted if set above
$tm->set("content", $tm->render('content-form['.$setname.']'));
echo $tm->render('page');
