<?php
/**
 * Clippings API interface
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once $_SERVER['CORE_PATH'].'/helpers/http/HTTPRequest';
require_once $_SERVER['CORE_PATH'].'/helpers/logger/v1/logger';
require_once __DIR__.'/../../auth/v2/ftuserV2';
require_once __DIR__.'/clipping';

class ClippingsAPIConnectionV1Exception extends Exception {
	public $commandsent, $servermessage, $response;

	const COMMFAIL = 1;
	const LISTFAIL = 2;
	const NOLIST = 3;
	const NOTAUTHORISED = 4;

	private static $messages = array(
		self::COMMFAIL => 'Failed to communicate with clippings.ft.com',
		self::LISTFAIL => 'Did not successfully decode an array of user lists from the clippings.ft.com API',
		self::NOLIST => 'Could not find Web App Clippings list for the current user',
		self::NOTAUTHORISED => 'Request was not authorized by the clippings service'
	);

	function __construct($code, $servermessage = '', $commandsent = '', HTTPResponse $response = null, Exception $previous = null) {
		$message = self::$messages[$code];
		if ($servermessage) {
			$message = $message . ': ' . $servermessage;
		}

		parent::__construct($message, $code, $previous);

		$this->commandsent   = $commandsent;
		$this->servermessage = $servermessage;

		if ($response) {
			$this->response  = serialize($response);
		}
	}
}

class ClippingsAPIConnectionV1 {
	const APIURL = 'http://clippings.ft.com/lib/api/v1.0/';

	const USERNOTE = 'Clipped from the FT Web App';
	const LISTNAME = 'Web App Clippings';

	private $ftuser = null;
	private $listid = null;

	private static $logger;

	/**
	 * Write a line to the API log
	 *
	 * @param mixed $vars Array or string to write
	 * @return void
	 */
	private static function logWrite($vars) {
		if (!isset(self::$logger)) {
			self::$logger = new AssankaLoggerV1('clippingsapiconn');
			self::$logger->setLogMethod('file');
		}
		self::$logger->write($vars);
	}

	/**
	 * Make an HTTP request to the external API.
	 *
	 * @param string $action The action to execute
	 * @param array  $args   Name and value pairs to pass in the query string
	 * @return HTTPResponse
	 */
	private function makeRequest($action, array $args) {
		$log = $args;
		$args['erightsid'] = $this->ftuser->get('eid');
		if (isset($_SERVER['HTTP_X_VARNISH'])) {
			$args['correlationid'] = $_SERVER['HTTP_X_VARNISH'];
		}
		ksort($args);

		$queryargs = http_build_query($args, '', '&');
		$signature = md5('9124731AC'.$queryargs);
		$queryargs = $queryargs.'&signature='.$signature;

		$urlcmd = self::APIURL.$action.'?'.$queryargs;
		$log['url'] = $urlcmd;

		$http   = new HTTPRequest($urlcmd);
		$http->setTimeLimit(5);
		$http->setMaxRetries(2);

		try {
			$resp = $http->send();
		} catch (HTTPRequestException $e) {
			$log['status'] = 'error';
			$log['err'] = $e->getMessage();
			self::logWrite($log);
			if (!empty($resp) and is_object($resp) and method_exists($resp, 'getBody')) {
				$responseBody = $resp->getBody();
			} else {
				$responseBody = null;
			}
			throw new ClippingsAPIConnectionV1Exception(ClippingsAPIConnectionV1Exception::COMMFAIL, $responseBody, $urlcmd, null, $e);
		}

		$log['status'] = $resp->getResponseStatusCode();
		$log['resptime'] = $resp->getResponseTime();
		self::logWrite($log);

		switch ($resp->getResponseStatusCode()) {
			case 200:
				break;

			case 401:
				throw new ClippingsAPIConnectionV1Exception(ClippingsAPIConnectionV1Exception::NOTAUTHORISED, $resp->getBody(), $urlcmd, $resp);
				break;

			default:
				throw new ClippingsAPIConnectionV1Exception(ClippingsAPIConnectionV1Exception::COMMFAIL, $resp->getBody(), $urlcmd, $resp);
				break;

		}

		return $resp;
	}

	/**
	 * Get the list id of the user list with name 'Web App Clippings', belonging to the current user, for use with the GETLIST and DELETE cases.
	 *
	 * @return void
	 */
	private function retrieveAndSetListId() {
		if ($this->listid !== null) return;
		$userlists = $this->makeRequest('list', array('clippingsIntegration' => true))->getData('json');

		// Helpdesk 28746, on one occasion the returned data was not an array, handle that here.
		if (!is_array($userlists)) {
			$e = new ClippingsAPIConnectionV1Exception(ClippingsAPIConnectionV1Exception::LISTFAIL, null, '', $userlists);
			self::logWrite($e);
			throw $e ;
		}

		foreach ($userlists as $items) {
			if ((($items['list']['name']) === self::LISTNAME) and (($items['list']['owneruserid']) === $this->ftuser->get('eid'))) {
				$this->listid = $items['list']['id'];
			}
		}

		if ($this->listid === null) {
			throw new ClippingsAPIConnectionV1Exception(ClippingsAPIConnectionV1Exception::NOLIST);
		}
	}

	/**
	 * Set the FTUser instance with which to authenticate with the external API.
	 *
	 * @param FTUserV2 $ftuser User to perform actions on behalf of
	 * @return void
	 */
	public function setFTUser(FTUserV2 $ftuser) {
		$this->ftuser = $ftuser;
	}

	/**
	 * Add a clipping.
	 *
	 * @param Clipping $clipping Clipping to add
	 * @return void
	 */
	public function add(ClippingV1 $clipping) {
		$this->makeRequest('add', array(
			'url'         => $clipping->url,
			'title'       => $clipping->title,
			'description' => $clipping->description,
			'datesaved'   => $clipping->datesaved,
			'listname'    => self::LISTNAME,
			'usernote'    => self::USERNOTE
		));
	}

	/**
	 * Delete a clipping.
	 *
	 * @param Clipping $clipping Clipping to delete
	 * @return void
	 */
	public function delete(ClippingV1 $clipping) {
		$this->retrieveAndSetListId();
		$this->makeRequest('delete', array(
			'listid' => $this->listid,
			'url'    => $clipping->url
		));
	}

	/**
	 * Get a list of article and report details to be integrated into the app clippings list and structure.
	 *
	 * Articles are in a key called 'articles' and special reports are in a key called 'sections'.
	 *
	 * @param integer $maxitems The number of items to return, defaulting to unlimited
	 * @return array
	 */
	public function getList($maxitems = false) {
		$this->retrieveAndSetListId();

		$requestdata = array('listid' => $this->listid);
		if ($maxitems and is_numeric($maxitems)) {
			$requestdata['perpage'] = $maxitems;
			$requestdata['pagenum'] = 1;
		}

		$userlist = $this->makeRequest('list', $requestdata)->getData('json');

		// Helpdesk 28823 on one occasion the returned data was not an array, handle that here.
		if (!is_array($userlist)) {
			$e = new ClippingsAPIConnectionV1Exception(ClippingsAPIConnectionV1Exception::LISTFAIL, null, '', $resp);
			self::logWrite($e);
			throw $e;
		}

		// Helpdesk 28830. For empty lists the clippings API does not return a $userlist[0]->items array.
		$returndata = array();
		if (!(isset($userlist[0]['items'])) ) {
			return $returndata;
		}

		// The clippings API /list? method gives back an array containing the single matching object.
		foreach ($userlist[0]['items'] as &$item) {

			// TODO:MCG:20120914: This method should instead return a list object (akin to FTItemList) with objects that are lazy-instantiated on access.
			$returndata[] = new ClippingV1($item['url'], $item);
		}

		return $returndata;
	}
}