<?php
/**
 * FT.com User
 *
 * Class to represent, manage and provide access to details
 * about an FT user.  Can be extended for specific projects
 * and local datastores to supplement the information stored
 * in the main dataset (OAC).  Implements ArrayAccess,
 * Iterator and Countable.  The internal methods required to
 * implement these interfaces are not documented, but do meet
 * the standard for the interface.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once $_SERVER['CORE_PATH'] . "/helpers/database/mysql/v3/mysql";
require_once $_SERVER['COREFTCO'] . "/helpers/auth/ftsession";
require_once $_SERVER['COREFTCO'] . "/helpers/auth/ftauth";
require_once $_SERVER['CORE_PATH'] . "/helpers/messaging/beanstalk/v2/beanstalk";

class FTUserV1 implements ArrayAccess, Iterator, Countable {

	protected $damerror, $data, $dbs, $tables, $session, $validity = 0;
	private $curlcmds = array();
	private static $async = true;

	const VALIDITY_UNKNOWN = 0, VALIDITY_VALID = 1, VALIDITY_INVALID = -1;
	const DAMACCESS_NONE = 0, DAMACCESS_READONLY = 1, DAMACCESS_READWRITE = 2;

	protected $damsources = array(
		'core' => array('auth'=>'OTpDM2R1dkViRQ==', 'damaccess' => self::DAMACCESS_READONLY),
		'assanka' => array('auth'=>'Mjo0NTU0bms0', 'tpname'=>'assanka', 'damaccess' => self::DAMACCESS_READWRITE),
		'mobile' => array('auth'=>'OTpDM2R1dkViRQ==', 'tpname'=>'assanka', 'damaccess' => self::DAMACCESS_READWRITE),
	);

	protected $fields = array(

		// Profile metadata retrieved from DAM
		'etag_assanka' => array('source' => 'assanka', 'sourceName' => 'etag', 'db'=>'oac', 'readonly'=>true),
		'etag_mobile' => array('source' => 'mobile', 'sourceName' => 'etag', 'db'=>'oac', 'readonly'=>true),

		// Assanka metadata used to regulate sync to/from DAM
		'datecreated' => array('source' => 'oac', 'modifier'=>'date', 'db'=>'oac', 'readonly'=>true),
		'datemodified' => array('source' => 'oac', 'modifier'=>'date', 'db'=>'oac', 'readonly'=>true),
		'datelastdamupload' => array('source' => 'oac', 'modifier'=>'date', 'db'=>'oac', 'readonly'=>true),
		'datelastdamdownload' => array('source' => 'oac', 'modifier'=>'date', 'db'=>'oac', 'readonly'=>true),
		'skey' => array('source' => 'oac', 'db'=>'oac'),
		'skeyexpires' => array('source' => 'oac', 'modifier'=>'date', 'db'=>'oac'),

		// Profile data stored in OAC but not synced to DAM
		'biog' => array('source' => 'oac', 'db'=>'oac'),
		'format' => array('source' => 'oac', 'db'=>'oac'),

		// Profile data from DAM core
		'eid' => array('source' => 'core', 'sourceName' => 'erightsId', 'db'=>'oac'),
		'passportid' => array('source' => 'core', 'sourceName' => 'passportId', 'db'=>'oac'),
		'username' => array('source' => 'core', 'sourceName' => 'userName', 'db'=>'oac'),
		'firstname' => array('source' => 'core', 'sourceName' => 'firstName', 'db'=>'oac'),
		'lastname' => array('source' => 'core', 'sourceName' => 'lastName', 'db'=>'oac'),
		'products' => array('source' => 'core', 'db'=>'oac'),
		'levelname' => array('source' => 'core', 'sourceName' => 'products', 'db'=>'oac'),
		'email' => array('source' => 'core', 'sourceName' => 'emailAddress', 'db'=>'oac'),
		'groups' => array('source' => 'core', 'db'=>'oac'),

		// Profile data from DAM thirdparty group 'assanka'
		'location' => array('source' => 'assanka', 'db'=>'oac'),
		'jobtitle' => array('source' => 'assanka', 'db'=>'oac'),
		'company' => array('source' => 'assanka', 'db'=>'oac'),
		'about' => array('source' => 'assanka', 'db'=>'oac'),
		'phone' => array('source' => 'assanka', 'db'=>'oac'),
		'pseudonym' => array('source' => 'assanka', 'sourceName' => 'Pseudonym', 'db'=>'oac'),
		'orgname' => array('source' => 'assanka', 'sourceName'=>'orgName', 'db'=>'oac'),
		'orglocation' => array('source' => 'assanka', 'sourceName'=>'orgLocation', 'db'=>'oac'),
		'annotationslevel' => array('source' => 'assanka', 'sourceName'=>'annotationsLevel', 'db'=>'oac'),

		// E-Dialog data from DAM thirdparty group 'assanka'
		'briefingsemail' => array('source' => 'assanka', 'sourceName' => 'EMAIL', 'db'=>'oac', 'readonly'=>true),
		'subscriptions' => array('source' => 'assanka', 'sourceName' => 'SUBSCRIPTIONS', 'db'=>'oac', 'readonly'=>true),


		/*
		// REVIEW:AB:20100309: This format preference is set by edialog, but is already set by us locally in preference screens in discussions, so will be ignored.  To enable, uncomment this line (and deal with translation between our values 'text' or 'html' and edialog's 'T' or 'H'
		'format' => array('source' => 'assanka', 'sourceName' => 'PREFERREDMIME', 'db'=>'oac'),
		*/

		// Profile data from DAM thirdparty group 'mobile'
		'latesthandset' => array('source' => 'mobile', 'db'=>'oac'),
		'latestnetwork' => array('source' => 'mobile', 'db'=>'oac'),
		'region' => array('source' => 'mobile', 'db'=>'oac'),
		'html5devicetype' => array('source' => 'mobile', 'db'=>'oac'),
		'html5screenresolution' => array('source' => 'mobile', 'db'=>'oac'),
		'html5last5page' => array('source' => 'mobile', 'db'=>'oac'),
		'html5mainview' => array('source' => 'mobile', 'db'=>'oac'),
		'html5userlocation' => array('source' => 'mobile', 'db'=>'oac'),
		'html5adclicks' => array('source' => 'mobile', 'db'=>'oac'),
		'html5adview' => array('source' => 'mobile', 'db'=>'oac'),
		'html5appview' => array('source' => 'mobile', 'db'=>'oac'),
		'html5usetime' => array('source' => 'mobile', 'db'=>'oac'),
		'html5date' => array('source' => 'mobile', 'db'=>'oac'),
		'html5frequency' => array('source' => 'mobile', 'db'=>'oac'),
		'html5pushmarks' => array('source' => 'mobile', 'db'=>'oac'),
	);


	/* Note that the following fields are also present in DAM but ignored in this class
		* alertPreferences: A set of fields from WSOD to do with stock and portfolio alerts
		* lastVisit: Unknown
		* pageHits: Unknown
		* pageHitsLast10: Unknown
	*/

	/**
	 * Create an FTUser
	 *
	 * Creates a new instance from a specified erights ID, the primary key for FT users.
	 *
	 * @param int  $eid      The erights id of the user to instantiate
	 * @param bool $autoload Whether to populate the user from the database (and DAM as required) automatically.  If false, user object will be a shell.  If true, data will be loaded from the DB, and if not present, from DAM.  SKEY will not be verified.
	 * @return FTUser
	 */
	public function __construct($eid, $autoload=false) {
		if (!is_numeric($eid) or $eid <= 0) trigger_error('No erights ID supplied for this user', E_USER_ERROR);
		$this->damerror = false;
		$this->dbs = array("oac"=>FTAuth::getDatabase());
		$this->tables = array("oac"=>"users");
		$this->data = array("eid"=>$eid);
		$this->isloaded = false;
		$this->session = null;
		$this->validity = self::VALIDITY_UNKNOWN;
		if ($autoload) $this->load();
	}

	/**
	 * Updates the user object, first from the local database for the cached user record, otherwise makes a request to DAM
	 *
	 * @param bool $verifyskey Whether to require that the skey variable stored in the class matches that stored in the database/DAM (used by FTAuth to authenticate a user)
	 * @return bool Whether the user exists in either the OAC DB or DAM, and was loaded successfully
	 */
	public function load($verifyskey=FTAuth::SKEY_NOT_REQUIRED) {

		if ($this->loadFromDB($verifyskey)) return true;

		// If no database record, make a synchronous call to DAM (regardless of whether an skey is known, as this is a per-bucket requirement)
		$this->updateFromDam($verifyskey);
		return $this->loadFromDB($verifyskey);
	}

	/**
	 * Loads a single user's data from the the database
	 *
	 * Only queries OAC DB, so if a user has no record in OAC, but does exist in DAM, this method will return false.  However, since it does not query DAM syncronously, it will fail quickly rather than succeeding slowly (as would be the case with load()).
	 *
	 * @param bool $verifyskey Whether to require that the SKEY variable stored in the class matches that stored in the database (used by FTAuth to authenticate a user) and that the SKEY is newer than 24 hours old.
	 * @return bool Whether the user exists in OAC DB, and was loaded successfully
	 */
	protected function loadFromDB($verifyskey = FTAuth::SKEY_NOT_REQUIRED) {
		if ($verifyskey == FTAuth::REQUIRE_SKEY and !$this->data['skey']) trigger_error("SKEY not known", E_USER_ERROR);
		$newdata = array();
		$oacloaded = false;
		$missingdbs = 0;
		foreach ($this->dbs as $dbname => $db) {
			$qry = 'SELECT * FROM '.$this->tables[$dbname].' WHERE {eid}';
			if ($verifyskey and $dbname == 'oac') $qry .= " AND {skey} AND skeyexpires > NOW()";
			$row = $db->queryrow($qry, $this->data);
			if ($row) {
				if ($dbname == 'oac') $oacloaded = true;
				$newdata = array_merge($newdata, $row);
			} else {
				$missingdbs = 1;
				break;
			}
		}
		if ($missingdbs and $oacloaded) {
			$this->saveToDB();
			return $this->loadFromDB($verifyskey);
		} elseif ($newdata and $oacloaded) {
			$this->validity = self::VALIDITY_VALID;
			$this->importDataFrom($newdata);
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Checks that all databases relevent to this user class have been queried
	 *
	 * If not, calls load().  This is useful when users have been
	 * constructed from session data that may have been created by a
	 * different user class, eg a session is started by creating an FTLiveUser,
	 * and that session is resurrected into an FTDisussionsUser
	 *
	 * @return void
	 */
	public function checkData() {
		$dbs = array_flip(array_keys($this->dbs));
		foreach ($this->fields as $k => $fieldInfo) {
			if (isset($this->data[$k]) and isset($dbs[$fieldInfo['db']])) unset($dbs[$fieldInfo['db']]);
		}
		if (count($dbs)) $this->load();
	}



	/**
	 * Makes a request to DAM in the context of the user
	 *
	 * @param string  $source     Name of DAM data group to read/write (core, assanka, mobile etc)
	 * @param array   $newdata    Data to send in a write operation.  If omitted, performs a read operation.
	 * @param integer $verifyskey Whether to send the SKEY with the request (if included, DAM will verify SKEY relates to a current session)
	 * @return mixed Returns true or a data array on success, false on failure (and sets damerror)
	 */
	protected function makeDamRequest($source="core", $newdata = false, $verifyskey=FTAuth::SKEY_NOT_REQUIRED) {
		$this->damerror = false;
		$log = "type:dam eid:".$this->data['eid']." src:".$source." ";
		$sourceinfo = $this->damsources[$source];
		$type = empty($sourceinfo['tpname']) ? 'core' : 'thirdparty';
		if ($verifyskey and !isset($this->data['eid'], $this->data['skey'])) {
			FTAuth::authLog($log."status:missingcreds");
			$this->damerror = "nokeys";
			return false;
		}

		// Assemble the HTTP request
		require_once $_SERVER['CORE_PATH']."/helpers/http/HTTPRequest";
		$http = new HTTPRequest('https://dam.ft.com/dam/e/'.$type.'/'.$this->data['eid']);
		if (isset($_SERVER['DAMENVIRONMENT']) and isset(FTAuth::$environments[$_SERVER['DAMENVIRONMENT']])) $http->resolveTo(FTAuth::$environments[$_SERVER['DAMENVIRONMENT']]['dam.ft.com']);
		if ($verifyskey) $http->setHeader("Set-Cookie", $this->data['skey']);
		$http->setHeader("Authorization", $sourceinfo['auth']);
		$http->setTimeLimit(4);
		$http->allowSslCertErrors();

		// If data to upload has been provided, add it to the request
		if ($newdata) {
			$json = json_encode(array("thirdparty" => $sourceinfo['tpname'], "data"=>$newdata));
			$http->setRequestBody($json);
			$http->setMethod('POST');
		}

		// Perform request
		$log .= "cmd:\"".$http->getCliEquiv()."\" ";
		try {
			$resp = $http->send();
			$this->curlcmds[] = array($http->getCliEquiv(), $resp->getResponseStatusCode(), $source);
		} catch (Exception $e) {
			if ($e->getMessage() == "HTTP request timed out" or $e->getMessage() == "Empty reply from server") {
				FTAuth::authLog($log."status:timeout");
				$this->damerror = "damdown";
				return false;
			} elseif (strpos($e->getMessage(), "Failure executing cURL command") === 0) {
				FTAuth::authLog($log."status:curlerror");
				$this->damerror = "damdown";
				return false;
			}
			$this->curlcmds[] = array($http->getCliEquiv(), 'damdown', $source);
			throw $e;
		}

		// Check for invalid HTTP status codes
		if ($resp->getResponseStatusCode() == 404) {
			FTAuth::authLog($log."status:unknownuser");
			$this->validity = self::VALIDITY_INVALID;
			return false;
		}

		// Check for invalid HTTP status codes
		if ($resp->getResponseStatusCode() != 200 and $resp->getResponseStatusCode() != 409) {
			FTAuth::authLog($log."status:http_".$resp->getResponseStatusCode());
			$this->damerror = "damdown";
			return false;
		}

		$data = $resp->getData('json');
		if ($resp->getBody() and empty($data)) {
			FTAuth::authLog($log."status:unparsable data:\"".str_replace("\n", "", $resp->getBody())."\"");
			$this->damerror = "unparsable";
			return false;
		}

		// Record updated etag on success, or on conflict, if modified data at our end is less than 5 mins old, update our etag to overwrite the FT's version on the next upload
		if ($resp->getResponseStatusCode() == 200 or strtotime($this->data["datemodified"]) > (time() - 300)) {
			if (isset($data["etag"])) {
				$this->data["etag_".$source] = $data["etag"];
			} elseif ($resp->getHeader('ETag')) {
				$this->data["etag_".$source] = $resp->getHeader('Etag');
			}
		}

		// Check for conflict due to out of date ETag
		if ($resp->getResponseStatusCode() == 409) {
			if (isset($data["etag"])) {
				FTAuth::authLog($log."status:conflict etag_expected:".$data["etag"]);
			} else {
				FTAuth::authLog($log."status:conflict");
			}
			$this->damerror = "conflict";
			return false;
		}
		unset($http);

		$this->validity = self::VALIDITY_VALID;
		FTAuth::authLog($log."status:ok");
		if (empty($_SERVER['IS_LIVE'])) FTAuth::authLog('DAM Response: '.$resp->getBody());
		unset($resp);

		return empty($data) ? true : $data;
	}

	/**
	 * Reports the error message associated with the last DAM call.  If the last DAM call was successful, returns false.
	 *
	 * @return string
	 */
	public function getDamError() {
		return $this->damerror;
	}

	/**
	 * Returns references to the databases used by this user object (only the OAC DB unless subclassed)
	 *
	 * @return array
	 */
	public function getDBs() {
		return $this->dbs;
	}

	public function getSources() {
		return $this->damsources;
	}

	/**
	 * Returns names of tables used by the databases in this user object (keys match those from FTUser::getDBs)
	 *
	 * @return array
	 */
	public function getTables() {
		return $this->tables;
	}

	/**
	 * Adds a new field to the set of data that makes up the user profile
	 *
	 * When the FTUser class is subclassed, the subclass should use this method to add fields stored in a local database.  The definition array should include the following keys:
	 *
	 * source - if the field is to be retrieved from DAM, the name of the DAM data group to which it belongs
	 * db - the name of the database connection that should be used to access the field
	 * sourceName - the name of the field in DAM, if different from the field name given in $fieldname
	 * modifier - MySQLConnection prepared statement modifier to add to the field when saving it to the database (eg 'date' to parse the value as a dae and save it in a MySQL date or datetime field.
	 *
	 * @param string $ref        Name to give to the new field
	 * @param array  $definition Associative array of properties as defined above
	 * @return  void
	 */
	protected function addField($ref, $definition) {
		$this->fields[$ref] = $definition;
	}

	/**
	 * Adds a new database connector
	 *
	 * When the FTUser class is subclassed, the subclass should call this method to set up any secondary databases that will store app-specific information.
	 *
	 * @param string          $dbname Convenience name for the connection (referenced when adding fields, see addField)
	 * @param MySQLConnection &$db    Database connection object (specifies a database)
	 * @param string          $table  Name of table within the database to use for accessing the field (defaults to 'users')
	 *
	 * @return void
	 */
	protected function addDatabase($dbname, &$db, $table='users') {
		$this->dbs[$dbname] = &$db;
		$this->tables[$dbname] = $table;
	}

	/**
	 * Removes a field from the set of data that makes up the user profile
	 *
	 * When the FTUser class is subclassed, the subclass should use this method to remove unneeded OAC fields, or other fields added by higher level subclasses (if the subclass of FTUser is itself subclassed)
	 *
	 * @param string $ref Name of field to remove
	 * @return void
	 */
	protected function removeField($ref) {
		unset($this->fields[$ref]);
	}

	/**
	 * Checks the availability of the given pseudonym for this user.
	 *
	 * Returns false if any user (other than the current user) is using the specified pseudonym.  So a user is permitted to use a pseudonym if they are already using it, but not if another user is already using it.
	 *
	 * @param string $pseudonym Proposed new pseudonym
	 * @return bool
	 */
	public function canUsePseudonym($pseudonym) {
		$vars = array('pseudonym' => $pseudonym, 'eid'=>$this->data['eid']);
		return !$this->dbs['oac']->querySingle('SELECT 1 FROM '.$this->tables['oac'].' WHERE {pseudonym} AND eid != {eid|nokey}', $vars);
	}

	/**
	 * Makes a request to DAM for all the user's data and updates the local cache
	 *
	 * Queries DAM using each registered DAM source in turn.  If the user does not have an skey on their profile (normally because they are a mobile user where skeys are not required), then sources that do require an skey are skipped.  Once all sources have been querid, data is saved to OAC and any other registered data stores.  Also sets datelastdamdownload to the current time.
	 *
	 * @param integer $verifyskey Whether to send the user's current SKEY along with the DAM requests
	 * @return bool
	 */
	public function updateFromDam($verifyskey = FTAuth::SKEY_NOT_REQUIRED) {

		// Retrieve data from all DAM sources
		$user = array();
		$products = "";
		foreach ($this->damsources as $source => $auth) {

			// Get the data
			$data = $this->makeDamRequest($source, false, $verifyskey);
			if (!$data and $this->validity == self::VALIDITY_INVALID) return false;

			// If any DAM source fails to respond, abandon the update rather than download incomplete data
			if ($this->getDamError()) {
				return false;
			}

			// Update all data in this object based on the DAM response
			foreach ($this->fields as $fieldName => $fieldInfo) {

				// Skip fields that correspond to a different DAM source to the one in the current iteration
				if ($fieldInfo['source'] != $source) continue;

				// If the DAM request does not contain this field, then skip it
				$sourceName = isset($fieldInfo['sourceName']) ? $fieldInfo['sourceName'] : $fieldName;
				if (!isset($data[$sourceName])) continue;

				// Skip the 'levelname' field, which will be handled separately after this loop
				if ($fieldName == "levelname") continue;

				// Add the data
				$user[$fieldName] = $data[$sourceName];
			}

			// Remember the 'products' field, if it is present, for processing after the DAM requests are finished
			if (isset($data["products"])) {
				$products = $data["products"];
			}
		}

		// Set the 'levelname' field
		$accesslevels = explode(",", $products);
		if (in_array("P2", $accesslevels) or in_array("P4", $accesslevels)) {
			$user["levelname"] = "premium";
		} elseif (in_array("P1", $accesslevels)) {
			$user["levelname"] = "subscribed";
		} else {
			$user["levelname"] = "registered";
		}

		// Error if no EID
		if (!isset($user['eid'])) return false;

		// Error if wrong user returned by DAM
		if ($user['eid'] != $this->data['eid']) {
			FTAuth::authLog('type:usermismatch requested_eid:'.$this->data['eid'].' received_eid:'.$user['eid']);
			return false;
		}

		// Update the local cache
		$this->importDataFrom($user);
		$this->data['datelastdamdownload'] = time();
		$this->saveToDB();
		return true;
	}

	/**
	 * Gets the session variable for this user
	 *
	 * @return  array
	 */
	public function &getSessionVar() {
		if (!$this->session) $this->session = &FTSession::getSession($this->data['eid']);
		return $this->session->getSessionVar();
	}

	/**
	 * Gets a single data item about the current user
	 *
	 * Note that since this class implements ArrayAccess, single fields can also be accessed using array syntax
	 *
	 * @param string $key Name of the key to return
	 * @return  mixed
	 */
	public function get($key) {
		$data = $this->getAll();
		return (isset($data[$key])) ? ($data[$key]) : false;
	}

	/**
	 * Gets all known data about the current user
	 *
	 * @return  array
	 */
	public function getAll() {
		return ($this->data);
	}


	/**
	 * Saves new data to the user record.  Detects changes in the user's DB record and saves changes to the database automatically.
	 *
	 * @param array $data       Array of key/value pairs to add to the user record.
	 * @param bool  $skiperrors Set to true to skip read only fields (otherwise triggers an error)
	 * @return void
	 */
	public function setUserData($data, $skiperrors=false) {
		$damdata = array();
		foreach ($data as $key=>$val) {

			$fielddoesntexist = (!isset($this->fields[$key]));
			$datahasntchanged = (isset($this->data[$key]) and (string)$this->data[$key] == (string)$val);
			if ($fielddoesntexist or $datahasntchanged) {
				unset($data[$key]);
				continue;
			}

			// Error on read only fields
			if ($this->fields[$key]['source'] == 'core' or !empty($this->fields[$key]['readonly'])) {
				if ($skiperrors) {
					unset($data[$key]);
				} else {
					trigger_error('Field \''.$key.'\' is read only', E_USER_ERROR);
				}
			}

			// Only upload to DAM for sources which we have write access to.
			$sourcekey = $this->fields[$key]['source'];
			$source = (isset($this->damsources[$sourcekey])) ? $this->damsources[$sourcekey] : null;
			if ( !is_null($source) and !empty($source['damaccess']) and $source['damaccess'] >= self::DAMACCESS_READWRITE ) {
				$sourcename = empty($this->fields[$key]['sourceName']) ? $key : $this->fields[$key]['sourceName'];
				$damdata[$sourcekey][$sourcename] = $val;
			}
		}
		$this->importDataFrom($data);
		$this->saveToDB();
		if (!empty($damdata)) $this->queueDam('upload', $damdata);
	}

	/**
	 * Updates the given user data in the local databases
	 *
	 * @return bool
	 */
	protected function saveToDB() {
		foreach ($this->dbs as $dbname=>$db) {

			// Fetch current DB data (if user exists in the db)
			$current = $db->queryRow('SELECT * FROM '.$this->tables[$dbname].' WHERE eid = %d', $this->data['eid']);
			$updates = $updatedata = array();

			// Check fields for changes
			foreach ($this->fields as $k => $fieldInfo) {
				if (!empty($fieldInfo['db']) and $fieldInfo['db'] != $dbname) continue;
				if (isset($this->data[$k]) and $this->data[$k] !== "" and (!isset($current[$k]) or $current[$k] != $this->data[$k])) {
					if (in_array($k, array('datecreated', 'datemodified'))) continue;
					$updates[$k] = "{".$k.((!empty($fieldInfo['modifier']))?'|'.$fieldInfo['modifier']:'')."}";
					$updatedata[$k] = $this->data[$k];

					// If a change has been made in a thirdparty DAM field, set modified date
					if ($current and $dbname == 'oac' and isset($this->damsources[$fieldInfo['source']]) and $fieldInfo['source'] != 'core') $updates['datemodified'] = "datemodified=NOW()";
				}
			}

			if (count($updates) or !$current) {

				// Ensure eid is included in query - EID must be included in every database
				$updates['eid'] = '{eid}';
				$updatedata['eid'] = $this->data['eid'];

				// Prepare query - only add datecreated if the datecreated field belongs to this database
				$insertfields = join(', ', $updates);
				if ($this->fields['datecreated']['db'] == $dbname) $insertfields .= ', datecreated=NOW()';
				unset($updates['eid']);
				$updatefields = join(', ', $updates);
				if ($updatefields) {
					$query = 'INSERT INTO '.$this->tables[$dbname].' SET '.$insertfields.' ON DUPLICATE KEY UPDATE ' . $updatefields;
				} else {
					$query = 'INSERT IGNORE INTO '.$this->tables[$dbname].' SET '.$insertfields;
				}

				// Log the varnish ID in the query if present to help correlate log information
				if (isset($_SERVER['HTTP_X_VARNISH'])) $query .= ' /* vid:'.$_SERVER['HTTP_X_VARNISH'].' */';

				$db->query($query, $updatedata);

				// If the datecreated or datemodified fields belong to this database, read them back from the DB
				if ($this->fields['datecreated']['db'] == $dbname) {
					$this->importDataFrom(array('datecreated'=>$db->querySingle('SELECT datecreated FROM '.$this->tables[$dbname].' WHERE eid='.$this->data['eid'])));
				}
				if ($this->fields['datemodified']['db'] == $dbname) {
					$this->importDataFrom(array('datemodified'=>$db->querySingle('SELECT datemodified FROM '.$this->tables[$dbname].' WHERE eid='.$this->data['eid'])));
				}
			}
		}
	}

	/**
	 * Sets whether or not to perform Dam actions asyncronously
	 *
	 * @param bool $async Whether to perform actions asyncronously
	 * @return void
	 */
	public static function setAsync($async) {
		self::$async = (bool)$async;
	}

	/**
	 * Queues the user for upload/download to/from DAM
	 *
	 * @param string $action Either 'upload' or 'download'
	 * @param array  $data   An array of data to be used (not used for download)
	 * @return void
	 */
	public function queueDam($action, array $data=array()) {
		if (self::$async) $this->queueAsyncDam($action, $data);
		else $this->syncDam($action, $data);
	}

	/**
	 * Queues the user for an asyncronous upload/download to/from DAM
	 *
	 * @param string $action Either 'upload' or 'download'
	 * @param array  $data   An array of data to be used (not used for download)
	 * @return void
	 */
	public function queueAsyncDam($action, array $data=array()) {

		// Give uploads a higher priority than downloads, so old data doesn't get downloaded overwriting newer data yet to be uploaded
		// Zero is the highest priority, and anything lower than 1024 is classified as 'urgent' in Beanstalk's stats
		$priorities = array(
			'upload' => 1000,
			'download' => 2000,
		);
		$body = array(
			'action' => $action,
			'user' => $this->data['eid'],
			'data' => $data,
			'queuetime' => microtime(true),
		);
		$mqueue_name = "coreftco-damupdate";
		$mqueue_priorty = (isset($priorities[$action])) ? $priorities[$action] : 100;
		$mqueue_delay = 0;
		$mqueue_ttr = 300;

		$this->dbs['oac']->query("INSERT INTO updates_pending SET body = %s, priority = %d", json_encode($body), $mqueue_priorty);
		$body['dbid'] = $this->dbs['oac']->getInsertId();

		$bs = new BeanstalkPoolV2();
		$bs->useTube($mqueue_name);
		$bs->put(json_encode($body), $mqueue_priorty, $mqueue_delay, $mqueue_ttr);
		$bs->disconnect();
	}

	/**
	 * performs syncronous upload/download to/from DAM
	 *
	 * @param string $action Either 'upload' or 'download'
	 * @param array  $data   An array of data to be used (not used for download)
	 * @return void
	 */
	public function syncDam($action, array $data=array()) {
		switch ($action) {
			case "download":
				$this->updateFromDam();
				break;
			case "upload":
				if (empty($data)) return "No data to upload";
				$this->uploadToDam($data);
				break;
			default:
				return "Couldn't find action ".$action;
		}
		return false;
	}

	/**
	 * Checks whether the user supports the given field
	 *
	 * @param string $fieldName Field name to check
	 * @return boolean
	 */
	public function hasField($fieldName) {
		return isset($this->fields[$fieldName]);
	}

	/**
	 * Sends third party data to DAM
	 *
	 * @param array   $data       The new data to write to DAM
	 * @param integer $verifyskey Whether to send SKEY with DAM request (if included, DAM will verify SKEY corresponds to a current session)
	 * @return bool
	 */
	public function uploadToDam(array $data, $verifyskey=FTAuth::SKEY_NOT_REQUIRED) {
		$hadconflicts = false;
		foreach ($data as $source => $uploaddata) {

			if (isset($this->data["etag_".$source])) $uploaddata['etag'] = $this->data["etag_".$source];

			// Execute upload.  If a conflict results, makeDamRequest will have recorded the new ETag, so just recreate the upload with the new data.
			if (!$this->makeDamRequest($source, $uploaddata, $verifyskey) and $this->getDamError() == 'conflict') {
				$hadconflicts = true;
			}
		}

		if ($hadconflicts) {

			// If a conflict occured but our data is younger than 5 mins, just write it again with the newer version number (which has been recorded by makeDAMRequest)
			if (strtotime($this->data["datemodified"]) > (time() - 300)) $this->uploadToDAM($data, $verifyskey);

			// Otherwise, ignore our old data and get fresh data from dam.
			else $this->updateFromDam();
		} else {
			$this->data['datelastdamupload'] = time();
		}

		// Save new DAM Etags and date of last upload
		$this->saveToDB();
	}

	/**
	 * Merges data into the user record in memory.  Behaves as array_merge, except that empty strings will not overwrite known values.  False will.  Note that this method does not detect changes in data loaded.  To edit a user's data, use setUserData.
	 *
	 * @param array $vars Key/value pairs to add to the user
	 * @return bool
	 */
	public function importDataFrom($vars) {
		$newdata = $this->data;
		$arraynumericindex = 0;

		foreach ($vars as $key=>$value) {
			if ($key == 'eid' and $value != $this->data['eid']) trigger_error("Cannot change EID on user instance.  Create new instance instead", E_USER_ERROR);
			if (!isset($this->fields[$key])) continue;
			if ($value === "") {
				if (!isset($newdata[$key])) $newdata[$key] = $value;
			} else {
				$newdata[$key] = $value;
			}
		}

		$this->data = $newdata;

		// Give the user a default pseudonym if they don't have one already.
		// Don't use firstname, lastname, username or email as this is used for public attribution
		if (empty($this->data['pseudonym'])) {
			$this->data['pseudonym'] = 'User' . $this->data['eid'];
		}

		// Update session
		$session = &$this->getSessionVar();
		$session['user'] = empty($session['user']) ? $this->data : array_merge($session['user'], $this->data);
	}

	/**
	 * Returns Javascript that sets a description of the user into the Assanka.auth.user object in the format described in http://wiki.assanka.com/wiki/The_FT_platform#Javascript_namespacing
	 *
	 * @return	string
	 */
	public function getPublicUserState() {

		// Determine user's display name (to display to the user themselves, or to use in emailing the user or sending email on behalf of the user.  Not to be used to attribute actions to the user publicly - use the pseudonym only.)
		$dispname = $this->get('pseudonym');
		if (!trim($dispname)) $dispname = $this->get('firstname').' '.$this->get('lastname');
		if (!trim($dispname)) $dispname = $this->get('email');

		// Add user details to output array
		$op = array();
		$op['pseudonym'] = $this->get('pseudonym');
		$op['dispname'] = $dispname;
		$op['email'] = $this->get('email');
		$op['eid'] = $this->get('eid');

		return $op;
	}

	public function getPublicUserStateJS() {
		$ret = "";
		$ret .= "if (typeof Assanka == \"undefined\") Assanka = {};";
		$ret .= "Assanka.auth = Assanka.auth || {};";
		$ret .= "Assanka.auth.user = ".$this->getPublicUserStateJSON().";";
		return $ret;
	}

	public function getPublicUserStateJSON() {
		return json_encode($this->getPublicUserState());
	}

	public function getDamCurlCmds() {
		return $this->curlcmds;
	}

	public function getValidity() {
		return $this->validity;
	}


	/* Implementation of ArrayAccess */

	public function offsetExists($offset) { return isset($this->data[$offset]); }
	public function offsetGet($offset) { return (isset($this->data[$offset])) ? $this->data[$offset] : null; }
	public function offsetSet($offset, $value) { $this->setUserData(array($offset=>$value)); }
	public function offsetUnset($offset) { $this->setUserData(array($offset=>null)); }


	/* Implementation of Iterator */

	protected $currentkey;
	public function current() { return ($this->valid()) ? $this->data[$this->currentkey] : null; }
	public function key() { return $this->currentkey; }
	public function valid() { return array_key_exists($this->currentkey, $this->data); }
	public function next() {
		next($this->data);
		$this->currentkey = key($this->data);
		return $this->current();
	}
	public function rewind() {
		reset($this->data);
		$this->currentkey = key($this->data);
	}


	/* Implementation of Countable */

	public function count() { return count($this->data); }
}

if (!class_exists('FTUser')) class_alias('FTUserV1', 'FTUser');