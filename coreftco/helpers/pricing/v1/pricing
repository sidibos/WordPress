<?php
/**
 * Pricing
 *
 * Acts as an aggregation layer / middleware for performing
 * operations using PricingQuotes, particularly anything requiring
 * access to multiple PricingQuotes, such as parsing an overnight
 * markets template, downloading batch data from MarkIT (which is
 * then searched and used by individual PricingQuotes to populate
 * themselves), and recording debug log information.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once __DIR__.'/pricingquote';

class PricingV1 {

	private static $quotecache = array();
	private static $pricingquoteclassname = 'PricingQuoteV1';

	const POPULATE_EMPTY = 0, POPULATE_CACHEFIRST = 1, POPULATE_LIVE = 2;

	/**
	 * Set the pricingquote class as appropriate
	 *
	 * @param string $classname Replacement class
	 * @return void
	 */
	public static function setPricingQuoteClassname($classname) {
		if (!class_exists($classname)) trigger_error('Class not found', E_USER_ERROR);
		self::$pricingquoteclassname = $classname;
	}

	/**
	 * Fetch a PricingQuote for a specified symbol
	 *
	 * If the PricingQuote is in the cache, it will be returned from there, otherwise a new PricingQuote is created.  PricingQuotes are cached automatically for the duration of script execution.
	 *
	 * @param string $symbol   Symbol to fetch
	 * @param bool   $populate Whether to populate the quote with data.  Note that to *force* a refresh, call refresh() on the PricingQuote object itself.
	 * @return PricingQuoteV1
	 * @see PricingQuoteV1::fetch
	 */
	public static function getQuote($symbol, $populate = self::POPULATE_CACHEFIRST) {
		$symbol = strtoupper(trim($symbol));
		if (isset(self::$quotecache[$symbol])) {
			$quote =& self::$quotecache[$symbol];
		} else {
			$quote = new self::$pricingquoteclassname($symbol);
		}
		if ($populate === self::POPULATE_LIVE and $quote->get('meta', 'downloadtime') < (time() - 2)) {
			$quote->refresh();
		} elseif ($populate !== self::POPULATE_EMPTY and $quote->getValidity() === PricingQuoteV1::VALIDITY_UNKNOWN) {
			$quote->fetch();
		}
		if (!isset(self::$quotecache[$symbol])) self::$quotecache[$symbol] =& $quote;
		return $quote;
	}

	/**
	 * Clear the object cache of PricingQuotes
	 *
	 * Clears the object cache for this script execution.  Does not clear data stored in memcache by the PricingQuote itself.  For long-running scripts, this method should be called at least as frequently as the PricingQuote::MEMCACHE_TTL interval, to ensure that new data available in memcache is picked up.
	 * 
	 * @return void
	 */
	public static function clearQuoteCache() {
		self::$quotecache = array();
	}

	/**
	 * Read a string, parse for placeholders such as {snapshot/chgpct:n225:nik}, where the
	 * format is {<property>:<symbol>}, and replace with actual data, looking up symbols
	 * as necessary.  <property> should be a group and data key separated by a forward
	 * slash.  Legacy WSOD property names are also supported.
	 *
	 * @param string $string Template string
	 * @return string
	 */
	public static function parseTemplate($string) {
		return preg_replace_callback('/\{([^:}]*):([^}]*)}/Ui',array('Pricing','replaceToken'),$string);
	}

	/**
	 * Replacer function for parseTemplate - for each placeholder found by parseTemplate,
	 * look up the necessary data and return it for insertion into the template string.
	 *
	 * @param array $match Replacer array
	 * @return string
	 */
	private static function replaceToken($match) {
		list($whole, $property, $symbol) = $match;
		$data = self::getQuote($symbol);
		if ($data->getValidity() == PricingQuoteV1::VALIDITY_INVALID) return '[Symbol not found: '.$symbol.']';
		return ($data->get($property)) ? $data->get($property) : "[Unknown key: ".$property."]";
	}


	/* Former public methods now deprecated */

	public static function logDebugMessages($newval) { trigger_error('Function removed', E_USER_DEPRECATED); }
	public static function logWrite($line) { trigger_error('Function removed', E_USER_DEPRECATED); }
	public static function setLogFilename($file) { trigger_error('Function removed', E_USER_DEPRECATED); }
	public static function updateLastWSODDownloadTime() { trigger_error('Function removed', E_USER_DEPRECATED); }
	public static function getLastWSODDownloadTime() { trigger_error('Function removed', E_USER_DEPRECATED); }
	public static function getMemcache() { trigger_error('Function removed', E_USER_DEPRECATED); }
}

if (!class_exists('Pricing')) class_alias('PricingV1', 'Pricing');