<?php
/**
 * Can manage data in a double keyed MySQL based cache store
 *
 * 'Temporary' class until redmine #12101 is implemented
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once __DIR__ . '/KeyValueAccessInterface';

class MySQLKeyValueStore implements KeyValueAccessInterface {

	private $_cacheTable = 'blobstore', $_readDB, $_writeDB;


	public function __construct($readDB, $writeDB = null) {
		$this->_readDB = $readDB;
		$this->_writeDB = $writeDB;
	}


	/**
	 * Getter for blob content
	 *
	 * @param string $key The key used for lookup
	 * @return blob       Data stored against that key
	 */
	public function get($key) {
		return $this->_readDB->querySingle("SELECT `data` FROM `" . $this->_cacheTable . "` WHERE `key` = %s", $key);
	}


	/**
	 * Existence checker for key
	 *
	 * @param string $key The key used for check
	 * @return boolean    Whether or not data is stored against that key
	 */
	public function exists($key) {
		$result = $this->_readDB->query("SELECT 1 FROM `blobstore` WHERE `key` = %s", $key);
		return ($result->count() > 0);
	}


	/**
	 * Getter for blob content
	 *
	 * @param string  $key  Unique key for the data being set for later lookup
	 * @param blob    $data Data to be stored
	 * @param integer $ttl  Time to live (in seconds) defaults to null, which indicates the data should be stored indefinitely
	 * @return void
	 */
	public function set($key, $data, $ttl = null) {
		$parameters = array('key' => $key, 'ttl' => $ttl, 'data' => $data);
		$this->_writeDB->query('REPLACE INTO `' . $this->_cacheTable . '` (`key`, `data`, `ttl`) VALUES ({key|nokey}, {data|nokey}, {ttl|nokey});',
			$parameters);
	}
}
