#!/usr/bin/php
<?php
/**
 * Polls the database for updated user information, and sends updates to DAM when they are made.
 *
 * Cannot send the updates in real time, due to problems with DAM
 * not always successfully updating (meaning we have to output an
 * error message, impacting on the user experience)
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

// Include daemon global file
require_once $_SERVER['COREFTCO']."/processes/global";

// Instantiate the daemon class
$d = new DaemonV2(array(
	'maxinstances' => 4,
	'startingdaemoninstances' => 4,
	'name' => 'damupdate',
	'description' => 'Syncronises changes to FT user profiles to and from their DAM API',
	'args' => array(
		'dbonly' => 'Only check database, do not connect to beanstalk'
	)
));
$l = new AssankaLoggerV1('damupdate');
$l->setLogMethod('file');

$args = $d->getCliArgs();
$justdodbcheck = !empty($args['dbonly']);

if (!$justdodbcheck) {
	$l->write("Waiting for events from beanstalk");
	$bs = new BeanstalkPoolV2();
	$bs->watch("coreftco-damupdate");
}

function dbCheck() {
	global $dbread;
	return $dbread->queryRow("SELECT * FROM updates_pending ORDER BY priority ASC LIMIT 1");
}

while (true) {
	$l->write("Waiting for events");
	$timeout = 600;
	try {
		$job = $dbitem = null;
		while ((!$justdodbcheck and $job = $bs->reserve($timeout)) or $dbitem = dbCheck()) {
			if ($dbitem) {
				$l->write("Using database for item ".$dbitem['updateid']);
				$json = $dbitem['body'];
			} else {
				$json = $job->getBody();
			}
			if (!($body = json_decode($json, true))) {
				$l->write("Failed to decode JSON");
				if ($job) $job->bury();
				continue;
			}
			if ($dbitem) {
				$body['dbid'] = $dbitem['updateid'];
				$dbitem = null;
			}
			if (empty($body['user']) or !is_numeric($body['user'])) {
				$l->write("Couldn't find numeric user id");
				if ($job) $job->bury();
				continue;
			}

			// Ignore downloads that has been pending for too long - active sessions are re-queued for download every 60 mins, and
			// new sessions would trigger a fresh download request, so there is no need to diligently retain elderly queued items.
			if ($body['action'] == 'download' and (microtime(true) - $body['queuetime']) > 600) {
				$l->write('Job '.$body['dbid'].' ('.$body['action'].') ignored as it is too old ('.number_format(microtime(true) - $body['queuetime'], 3)."s)");
				if ($job) $job->delete();
				$dbwrite->query("DELETE FROM updates_pending WHERE updateid = %d", $body['dbid']);
				continue;
			}

			$user = FTAuthV2::createUser($body['user'], true);
			$l->write('Job '.$body['dbid'].', user: '.$body['user'].', action: '.$body['action']);
			$error = $user->syncDam($body['action'], $body['data']);
			if ($error) {
				$l->write('Error: '.$error);
				if ($job) $job->bury();
			} elseif ($user->getDamError()) {
				$l->write('Dam error: '.$user->getDamError());
				if ($job) $job->release(10000, 60);
			} else {
				$l->write('Job '.$body['dbid'].' successful, time taken = '.number_format(microtime(true) - $body['queuetime'], 3)."s");
				if ($job) $job->delete();
				$dbwrite->query("DELETE FROM updates_pending WHERE updateid = %d", $body['dbid']);
			}
			unset($user);
			FTSessionV2::clearObjectCache();
		}
	} catch (BeanstalkException $e) {
		$log = 'Beanstalk exception: ';
		$log .= ($e->getMessage() == 'Protocol error') ? $e->getContext() : $e->getMessage();
		$d->writeLog($log);
		sleep(60);
	}
	if ($justdodbcheck) break;
}

$l->write('Complete');
