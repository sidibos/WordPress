#!/usr/bin/php
<?php
/**
 * Execute queued requests to the FT API
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

// Include daemon global file
require_once $_SERVER['COREFTCO']."/processes/global";

// Instantiate the daemon class
$d = new DaemonV2(array(
	'maxinstances' => 8,
	'startingdaemoninstances' => 4,
	'name' => 'processApiQueue',
	'description' => 'Sends asyncronously queued API requests to api.ft.com'
));
$l = new AssankaLoggerV1('processApiQueue');
$l->setLogMethod('file');

$l->write("Waiting for events from beanstalk");
$bs = new BeanstalkPool();
$bs->watch("coreftco-ftapi-queuedrequests");

// Create an API connection
$conn = new FTAPIConnectionV1();

// Disable cache reading to prevent loading of existing cached response (any new live response will still be written to cache)
$conn->setCacheMode(FTAPIConnection::CACHE_NONE);

while (true) {
	$l->write("Waiting for events");
	$timeout = 600;
	try {
		$job = null;
		while ($job = $bs->reserve($timeout)) {
			$json = $job->getBody();
			$log = array('pid'=>getmypid(), 'job'=>$job->getID());
			if (!($request = json_decode($json, true))) {
				$l->write("Failed to decode JSON: ".$json);
				$job->bury();
				continue;
			}
			$age = microtime(true) - $request['queuetime'];
			$log['path'] = $request['path'];
			if (isset($request['livettl'])) $log['livettl'] = $request['livettl'];
			$log['queuelag'] = number_format($age, 2);

			// Ignore requests that has been pending for too long - as currently all API methods are read only, no data will be lost
			// by skipping requests that are very old, and they will be requeued automatically when the content is next accessed
			if ($age > 600) {
				$log['status'] = 'TOO_OLD';
				$l->write($log);
				$job->delete();
				continue;
			}

			// Make the specified request in order to populate cache
			if ($request['method'] == 'GET' and $conn->get($request['path'], $request['args'])) {
				$log['status'] = 'DONE';
				$l->write($log);
			} elseif ($request['method'] == 'POST' and $conn->post($request['path'], $request['args'], $request['enctype'])) {
				$log['status'] = 'DONE';
				$l->write($log);

			} else {

				// If API does not return valid data, mark the failure.  The failure reason will be logged separately in the API log (api.log) by the API connection object.
				$log['status'] = 'FAILED';
				$l->write($log);
			}
			$job->delete();
		}
	} catch (BeanstalkException $e) {
		$log = 'Beanstalk exception: ';
		$log .= ($e->getMessage() == 'Protocol error') ? $e->getContext() : $e->getMessage();
		$l->write($log);
		sleep(60);
	}
}

$l->write('Complete');
