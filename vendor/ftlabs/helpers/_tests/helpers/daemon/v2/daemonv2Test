<?php
/**
 * Test for DaemonV2
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All rights reserved]
 */


class daemonv2Test extends PHPUnit_Framework_TestCase {
	private $daemonoutputfile;
	protected function setUp() {

		// Only need to kill the unending daemons as others should quit once they've finished
		exec("killall -q unendingDaemon");
		exec("killall -q unendingReplacingDaemon");
		$this->daemonoutputfile = dirname(__FILE__)."/daemonoutput";
	}

	protected function tearDown() {
		if (file_exists($this->daemonoutputfile)) unlink($this->daemonoutputfile);
		exec("killall -q unendingDaemon");
		exec("killall -q unendingReplacingDaemon");
	}

	public function testDebugModeKeepsSamePidThroughout() {
		$output = $this->_getJSON('testDaemon --debug');
		$this->assertEquals($output['startpid'], $output['endpid'], "Daemon has changed pid whilst in debug mode");
	}

	public function testdaemonModeChangesPidAfterDetach() {
		$output = $this->_getJSON('testDaemon --daemon');
		$this->assertNotEquals($output['startpid'], $output['endpid'], "Daemon has kept its pid when it should have forked");
	}

	public function testStoppingDaemonPreventsFutherExecution() {
		$output = $this->_waitforDaemon('multiDaemon --stop');
		$this->assertEmpty(file_get_contents($this->daemonoutputfile), "Process not stopped");
	}

	public function testRestartingDaemonSpawnsNewProcesses() {
		$output = $this->_waitforDaemon('multiDaemon --restart');
		$pids = array_unique(explode("\n", trim(file_get_contents($this->daemonoutputfile))));
		$this->assertCount(4, $pids, "Wrong number of unique proccesses forked");
	}

	public function testHelpArgs() {
		$output = shell_exec(dirname(__FILE__)."/testDaemon --help");
		$this->assertFalse(file_exists($this->daemonoutputfile), "Process not stopped");

		$this->assertContains("Philip Daemon", $output, "daemon name missing");
		$this->assertContains("This is a mock daemon for testing with", $output, "daemon description missing");
		$this->assertContains("--bar", $output, "argument name missing");
		$this->assertContains("This is declared but never actually used", $output, "argument description missing");
		$this->assertContains("--restart", $output, "standard argument name missing");
	}

	/**
	 * This test takes longer than a second because it checks wether a daemon can be limited to a second
	 *
	 * @medium
	 * @return void
	 */
	public function testTimeLimitingDaemon() {
		$output = $this->_getJSON('limitedDaemon --daemon');
		$timetaken = $output['endtime'] - $output['starttime'];

		// Allow a tolerance of 1 second when working out how long the daemon was running for, the daemon shouldn't run for less than a second, and it should run in less then 2 seconds realistically.
		$this->assertGreaterThan(0.9, $timetaken, "Daemon was killed too quickly");
		$this->assertLessThan(2, $timetaken, "Daemon was allowed to run for too long");
	}

	public function testCLIArgsAreParsed() {

		// Don't include any spaces in the value as then it would be treated as multiple arguments
		$barval = "Hiki_iaʻu_ke_ʻai_i_ke_aniani;_ʻaʻole_nō_lā_au_e_ʻeha.";
		$output = $this->_getJSON("testDaemon --foo --debug --notdeclared --bar=".escapeshellarg($barval));
		$this->assertArrayHasKey('foo', $output['CLIArgs'], "foo key missing from cliargs");
		$this->assertArrayHasKey('bar', $output['CLIArgs'], "bar key missing from cliargs");
		$this->assertArrayHasKey('notused', $output['CLIArgs'], "notused key missing from cliargs");
		$this->assertTrue($output['CLIArgs']['foo'], "Foo is missing from command line arguments");
		$this->assertEquals($output['CLIArgs']['bar'], $barval, "Bar is set to wrong value in command line arguments");
		$this->assertFalse(isset($output['CLIArgs']['debug']), "--debug argument should be handled by daemon class, but is returned to app");
		$this->assertFalse(isset($output['CLIArgs']['notdeclared']), "Undeclared argument being returned by CLIArgs");
	}

	/**
	 * Note: may take more than a second
	 *
	 * @medium
	 * @return void
	 */
	public function testStoppingDaemonStopsExistingDaemons() {
		for ($i = 0; $i < 4; $i++) {
			exec(dirname(__FILE__)."/unendingDaemon --daemon");
		}
		$oldpids = $this->_getRunningPids("unendingDaemon");
		$this->_waitforDaemon("unendingDaemon --stop");
		$newpids = $this->_getRunningPids("unendingDaemon");

		$this->assertEquals(4, count($oldpids), "Wrong number of instances running before stop");
		$this->assertEquals(0, count($newpids), "Wrong number of instances running after stop");
	}


	/**
	 * Note: may take more than a second
	 *
	 * @medium
	 * @return void
	 */
	public function testRestartingDaemonStopsExistingDaemons() {
		for ($i = 0; $i < 5; $i++) {
			exec(dirname(__FILE__)."/unendingDaemon --daemon");
		}
		$oldpids = $this->_getRunningPids("unendingDaemon");
		exec(dirname(__FILE__)."/unendingDaemon --restart");
		$newpids = $this->_getRunningPids("unendingDaemon");

		$this->assertEquals(5, count($oldpids), "Wrong number of instances running before restart");
		$this->assertEquals(3, count($newpids), "Wrong number of instances running after restart");
		$this->assertEmpty(array_intersect($oldpids, $newpids), "Same pid used before and after restart");
	}


	/**
	 * Note: may take more than a second
	 *
	 * @medium
	 * @return void
	 */
	public function testNumberOfInstancesNeverExceedsMaxInstances() {

		// Start the max number allowed
		for ($i = 0; $i < 5; $i++) {
			exec(dirname(__FILE__)."/unendingDaemon --daemon");
		}
		$oldpids = $this->_getRunningPids("unendingDaemon");

		// Try to start some more
		for ($i = 0; $i < 3; $i++) {
			exec(dirname(__FILE__)."/unendingDaemon --daemon");
		}
		$newpids = $this->_getRunningPids("unendingDaemon");

		$this->assertEquals(5, count($newpids), "Wrong number of instances running");
		$this->assertEmpty(array_diff($oldpids, $newpids), "New processes replaced old ones when replaceexisting is set to false");
	}

	/**
	 * Note: may take more than a second
	 *
	 * @medium
	 * @return void
	 */
	public function testStartingNewInstancesReplacesOldOnes() {

		// Start the max number allowed
		for ($i = 0; $i < 3; $i++) {
			exec(dirname(__FILE__)."/unendingReplacingDaemon --daemon");
		}
		$oldpids = $this->_getRunningPids("unendingReplacingDaemon");
		$this->assertEquals(3, count($oldpids), "Wrong number of instances running");

		// Try replacing the existing instances one by one
		for ($i = 1; $i <= 3; $i++) {
			exec(dirname(__FILE__)."/unendingReplacingDaemon --daemon");
			$newpids = $this->_getRunningPids("unendingReplacingDaemon");
			$this->assertEquals(3, count($newpids), "Wrong number of instances running after replacing $i");
			$this->assertEquals($i, count(array_diff($oldpids, $newpids)), "Wrong number of pids have changed");
		}

	}

	public function testRunAs() {
		$this->markTestIncomplete("Need to check whether the runas setting works.");
	}

	private function _getRunningPids($command) {
		$raw = shell_exec("ps aux | grep $command | grep -v grep | awk '{print $2}'");
		if (empty($raw)) return array();
		return explode("\n", trim($raw));
	}

	/**
	 * Waits for a process and all its child processes to have finished.
	 * Note: normally daemons are written so that they never finish, but for testing purposes it is easier if they do stop at some point.
	 *
	 * @param string $command The command to run
	 * @return void
	 */
	private function _waitforDaemon($command) {

		// COMPLEX:20120615:LB: strace with "-f" waits for all the child process.  "-e signal" reduces the output significantly, but not completely, so any remaing strace output is piped to /dev/null
		exec("strace -e signal -f ".dirname(__FILE__).'/'.$command." 2> /dev/null");

	}

	private function _getJSON($command) {
		$this->_waitforDaemon($command);
		$raw = file_get_contents($this->daemonoutputfile);
		$output = json_decode($raw, true);
		$this->assertNotNull($output, "Daemon didn't return any JSON (probably a fault in the test)");
		if (isset($output['error'])) $this->assertNull($output['error'], $output['error']);
		return $output;
	}

}