<?php
/**
 * Access control helper: Dotted rights
 *
 * Provides a holder and validator for permissions formed of heirarchical rights, expressed as x.y.z.  Rights held are passed into the constructor in either a string or an array.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

class AccessControl_DottedRights {

	// Properties to store the rights held, and those which can be checked against those held, plus an admin contact for access denied pages.
	private $rights = array();
	private $possiblerights = array();
	private $admincontact = array();

	// Set to true to include rights the user already has (and which are required for the feature) in the list of rights required when displaying access denied pages
	private $showheld = false;

	const REQUIRE_ALL = -1;
	const REQUIRE_ANY = 1;

	/**
	 * Create a DottedRights checker
	 *
	 * Specifies the rights against which required rights will be checked.
	 *
	 * @param mixed $rights Array or comma delimited string of rights *held*.
	 * @return AccessControl_DottedRights
	 */
	public function __construct($rights) {
		if (is_string($rights)) $rights = preg_split("/[\s,]+/", $rights);
		if (is_array($rights)) {
			foreach ($rights as $right) {
				$this->rights[] = trim($right);
			}
		}
	}

	/**
	 * Specify whether rights the user already has are displayed when denying access
	 *
	 * By default, when a user is denied access to a feature, the page will tell them only the rights that don't have and need, not the ones that that they need and have.  Set this to true to display all rights required by the feature, even if some of them are already held (they will be shown as such and highlighted in a reasurring green!)
	 *
	 * @param bool $newval Whether to display rights held as well as those not held (default true)
	 * @return void
	 */
	public function showHeldRights($newval=true) {
		$this->showheld = ($newval == true);
	}

	/**
	 * Returns true if the rights required match the stored rights
	 *
	 * Rights required may be specified as an array or comma delimited string.  If multiple rights are given, all must be held in order for the check to pass.  However, if any held right is a parent of a required right, that right will be deemed held.  If a required right is expressed with a wildcard suffix, the held right may contain one or more segments.  Examples:
	 *
	 * users.authors.edit => Rights held must include users, users.authors or users.authors.edit
	 * uesrs => Rights must include users
	 * users.* => Rights must include a right that begins with users., or just users
	 *
	 * @param mixed $rightsrequired Array or comma delimited string of rights *required*.
	 * @param int   $require        Whether to require all the rights (REQUIRE_ALL) or just one (REQUIRE_ANY)
	 * @return bool Whether the required rights are held
	 */
	public function hasRights($rightsrequired, $require = self::REQUIRE_ALL) {
		if (is_string($rightsrequired)) $rightsrequired = explode(",", $rightsrequired);
		foreach ($rightsrequired as $rightrequired) {
			$rightrequired = trim($rightrequired);
			if (!$this->isCheckable($rightrequired)) throw new Exception('Cannot check a right that is not declared');
			$isvalid = false;
			while ($rightrequired) {
				if (substr($rightrequired, strlen($rightrequired) - 2, 2) == ".*") {
					$rightprefix = rtrim($rightrequired, "*");
					if (is_array($this->rights)) {
						foreach ($this->rights as $rightheld) {
							if (strpos($rightheld, $rightprefix) === 0) {
								$isvalid = true;
								break;
							}
						}
					}
					$rightrequired = rtrim($rightrequired, "*.");
				} else {
					if (in_array($rightrequired, $this->rights)) {
						$isvalid = true;
						break;
					}
					$rightrequired = (preg_match("/^(.*?)\.[^\.]+$/", $rightrequired, $m)) ? $m[1] : false;
				}
			}
			if (!$isvalid and $require == self::REQUIRE_ALL) break;
			if ($isvalid and $require == self::REQUIRE_ANY) break;
		}
		return $isvalid;
	}

	/**
	 * Alias of hasRights
	 *
	 * @param mixed $rightrequired Array or comma delimited string of rights *required*.
	 * @return bool Whether the required rights are held
	 */
	public function hasRight($rightrequired) { return $this->hasRights($rightrequired); }

	/**
	 * Outputs an access denied page to the browser if the specified rights are not held
	 *
	 * Checks whether the required rights are held, and if so, returns nothing.  If they are not, outputs an HTML page describing the rights that are missing, and (if set using setAdministratorContact), the contact details of a person who can be moaned at and who (preferably) has the right to change other people's rights.
	 *
	 * @param mixed $rightsrequired Array or comma delimited string of rights *required*.
	 * @param int   $require        Whether to require all the rights (REQUIRE_ALL) or just one (REQUIRE_ANY)
	 * @return void
	 */
	public function requireRights($rightsrequired, $require = self::REQUIRE_ALL) {
		require_once($_SERVER['CORE_PATH']."/helpers/templatemanager/v4/templatemanager");
		if (!$this->hasRights($rightsrequired, $require)) {
			$tm = new TemplateManager(dirname(__FILE__)."/templates");
			if (is_string($rightsrequired)) $rightsrequired = explode(",", $rightsrequired);
			$tm->set('require', $require);
			foreach ($rightsrequired as $right) {
				$data = array("right"=>$right, "isheld"=>$this->hasRights($right));
				if ($data['isheld'] and !$this->showheld) continue;
				$tm->add("rights", $data);
			}
			$tm->set($this->admincontact);
			exit($tm->render('denied_dottedrights'));
		}
	}

	/**
	 * Alias of requireRights
	 *
	 * @param mixed $rightrequired Array or comma delimited string of rights *required*.
	 * @return void
	 */
	public function requireRight($rightrequired) { return $this->requireRights($rightrequired); }

	/**
	 * Requires that ALL the rights to be held
	 *
	 * @param mixed $rightsrequired Array or comma delimited string of rights *required*.
	 * @return void
	 */
	public function requireAllRights($rightsrequired) { return $this->requireRights($rightsrequired, self::REQUIRE_ALL); }

	/**
	 * Requires one or more of the rights to be held
	 *
	 * @param mixed $rightsrequired Array or comma delimited string of rights *required*.
	 * @return void
	 */
	public function requireAnyRights($rightsrequired) { return $this->requireRights($rightsrequired, self::REQUIRE_ANY); }

	/**
	 * Stores the details of a person whose contact details can be given in the event that an access denied page is output to the browser.
	 *
	 * @param string $name  Name of administrator contact, preferably in the form 'firstname surname'
	 * @param string $email Valid email address of the administrator contact
	 * @param string $phone Optional phone number of the administrator contact
	 * @return void
	 */
	public function setAdministratorContact($name, $email, $phone=false) {
		$this->admincontact = array("name"=>$name, "email"=>$email, "phone"=>$phone);
	}

	/**
	 * Declares a list of rights as checkable
	 *
	 * Rights may not be required using requireRights or hasRights unless they have been declared.  This ensures that any system that uses rights does not have rights buried in code that it is not possible to grant to a user.
	 *
	 * @param mixed $rights Array or comma delimited list of rights to add to the list of possible rights
	 * @return void
	 */
	public function declareRights($rights) {
		if (is_string($rights)) $rights = explode(",", $rights);
		if (!is_array($rights)) throw new Exception('Invalid rights string');
		foreach ($rights as $right) {
			$right = trim($right);
			while ($right) {
				if (!in_array($right, $this->possiblerights)) $this->possiblerights[] = $right;
				if (strpos($right, ".") !== false) {
					$right = preg_replace("/^(.*?)\.?[^\.]+$/", "$1", $right);
				} else {
					break;
				}
			}
		}
	}

	/**
	 * Removes one or more rights from the list of checkable rights
	 *
	 * Rights may not be required using requireRights or hasRights unless they have been declared.  This ensures that any system that uses rights does not have rights buried in code that it is not possible to grant to a user.
	 *
	 * @param mixed $rights Array or comma delimited list of rights to remove from the list of possible rights
	 * @return void
	 */
	public function removeRights($rights) {
		if (is_string($rights)) $rights = explode(",", $rights);
		if (!is_array($rights)) throw new Exception('Invalid rights string');
		foreach ($rights as $right) {
			$right = trim($right);
			if (($key = array_search($right, $this->possiblerights)) !== false) {
				unset($this->possiblerights[$key]);
			}
		}
	}

	/**
	 * Returns true if a given right is in the list of possible rights (ie has been declared)
	 *
	 * @param string $right A single right (wildcard endings allowed)
	 * @return void
	 */
	private function isCheckable($right) {
		$right = trim(trim($right), ".*");
		return in_array($right, $this->possiblerights);
	}
}