<?php

/**
 * Use PDO to Mock an Assanka MySQL Database
 *
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once $_SERVER['CORE_PATH'] . '/vendor/autoload.php';

require_once dirname(__FILE__).'/../helpers/database/query/v1/query';

/**
 * A complete Mock of the FTLabs\MySqlResult type.  This can be used directly with the connection class, however, it makes more sense to pass results to consumers than have an object make a query, and then process it.  This means we can mock query results and pass the results to the object that 'does stuff' with the data.
 *
 * But for those who don't like separation of concerns @see MockMySqlConnectionV4.
 *
 * To use:
 *
 * ```PHP
 *
 * $mysqlResult = new MockMySqlResultV4(array(
 *          array(1, "field_1_data", "field_2_data", "field_3_data"),
 *          array(2, "field_1_data", "field_2_data", "field_3_data"),
 *          array(3, "field_1_data", "field_2_data", "field_3_data")
 *      ), array(
 *          "affectedRows" => integer_number_of_rows_query_affected,
 *          "insertId"	   => integer_id_of_inserted_value_if_insert,
 *          "errorNo"	   => integer_mysql_error_number,
 *          "errorMsg"	   => string_mysql_error_message,
 *          "queryExpr"	   => string_query_expression,
 *          "timeTaken"    => 0.7731,				// Microseconds
 *          "dateExecuted" => 1360167008.7731   // PHP microtime(true)
 *      ));
 *
 * ```
 *
 * The first element should be an array of arrays.  The arrays that are contained in the array should represent records.
 *
 * If you need to use MySqlResultV4#setReturnObject you need to specify the names of the columns as well as a numeric index:
 *
 * ```PHP
 * $mysqlResult = new MockMySqlResultV4(array(
 *          array(
 *               0 => 1, 1 => "field_1_data", 2 => "field_2_data", 3 => "field_3_data",
 *               "id" => 1, "field_1" => "field_1_data", "field_2" => "field_2_data", "field_3" => "field_3_data"
 *          	),
 *          array(
 *               0 => 2, 1 => "field_1_data", 2 => "field_2_data", 3 => "field_3_data",
 *               "id" => 2, "field_1" => "field_1_data", "field_2" => "field_2_data", "field_3" => "field_3_data"
 *          	),
 *          array(
 *               0 => 3, 1 => "field_1_data", 2 => "field_2_data", 3 => "field_3_data",
 *               "id" => 3, "field_1" => "field_1_data", "field_2" => "field_2_data", "field_3" => "field_3_data"
 *          	)
 *      ), array(
 *          "affectedRows" => 3,              // Integer_number_of_rows_query_affected
 *          "insertId"	   => 0,              // Integer_id_of_inserted_value_if_insert (0 if none: http://www.php.net/manual/en/mysqli.insert-id.php)
 *          "errorNo"	   => 0,              // Integer_mysql_error_number,
 *          "errorMsg"	   => "",             // string_mysql_error_message,
 *          "queryExpr"	   => "SELECT * FROM test_db LIMIT 3;", //string_query_expression
 *          "timeTaken"    => 0.7731,				// Microseconds
 *          "dateExecuted" => 1360167008.7731   // PHP microtime(true)
 *      ));
 *
 * ```
 */
class MockMySqlResultV4 extends FTLabs\MySqlResult {

	/**
	 * @var array The Result data.
	 */
	private $_data;

	public function __construct($resultObject, array $resultDetails) {

		// The resultobject that the real MySqlResult expects is a 'mysqli_result' type.  (Which is also an Iterator).
		// COMPLEX:SG:20130206: We are only mocking the Result object in cases where it interacts directly with the resultobject.  Unfortunately the MySqlResult relies heavily on the fact that $resultObject is a 'mysqli_result' type.  Here we pass in null to the parent constructor so that an error is thrown if we try and access the results from the parent type here.
		parent::__construct(null, $resultDetails);

		$this->_data = $resultObject;
	}

	function rewind() {
	 	$this->currentKey = -1;
	 	$this->next();
	}

	function current() {
		return $this->current;
	}

	function key() {
		return $this->currentKey;
	}

	function next() {
		$this->currentKey++;

		if (isset($this->_data[$this->currentKey])) {
			$this->current = $this->_data[$this->currentKey];
		} else {
			$this->current = false;
		}
	}

	function valid() {
		return isset($this->_data[$this->currentKey]);
	}

	function count() {
		return count($this->_data);
	}

	/**
	 * Fetch a single 'cell' of data from the first row returned from a query
	 *
	 * @param integer $columnoffset Index of column to fetch, where 0 is the leftmost column. Optional, defaults to 0.
	 * @return array A row of data as key/value pairs
	 */
	public function getSingle($columnoffset = 0) {
		if (!count($this)) return null;

		// The method getSingle has some possibly unexpected side effects that should be investigated.  In the implemetation.  The internal pointers are not advanced.
		$this->next();
		$values = array_values($this->current());
		return $values[$columnoffset];
	}

	/**
	 * Return all results as a numeric array of rows, each row an associative array
	 *
	 * Entirre resultset is loaded into memory - use only on small resultsets
	 *
	 * @return array Array containing one element per row in the resultset
	 */
	public function getAllRows() {
		return $this->_data;
	}


}


class MockMySQLConnectionV4 extends FTLabs\MySqlConnection {
	private $_db;

	public function __construct(PDO $pdo = null) {
		if ($pdo === null) {
			$this->_db = new PDO('sqlite::memory:');

		} else {
			$this->_db = $pdo;
		}

		// Throw Exception
		$this->_db->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	}

	protected function isConnected() {
		return true;
	}

	protected function sqlenc($val) {
		return $val;
	}

	public function rawQuery($query) {
		$output = $this->_db->query($query);

		if ($this->_db->errorCode() != '00000') {
			throw new AssankaException($query . print_r($output, 1) . print_r($this->_db->errorInfo(), true));
		}
		return $output;
	}

	/**
	 * Mirrors the internal runQuery, the internal runQuery is private, therefore it is not overridden.
	 */
	protected function runQuery($queryExpr) {
		assert('$queryExpr instanceof PDOStatement');
		$queryExpr->execute();

		if (stristr($queryExpr->queryString, "insert") === FALSE) {
			return $queryExpr->fetchAll(PDO::FETCH_ASSOC);
		}

		return $this->_db->lastInsertId();
	}

	public function query() {

		$queryExpr = call_user_func_array(array($this, 'parse'), func_get_args());

		if (empty($queryExpr)) {

			// TODO:SG:20130206: This is directly copied from the connection class.  Really this should be abstracted?
			// Attempt to determine why the query is empty.
			switch (preg_last_error()) {
				case PREG_NO_ERROR:
					$error = "No PREG error.";
					break;
				case PREG_INTERNAL_ERROR:
					$error = "Internal PREG error.";
					break;
				case PREG_BACKTRACK_LIMIT_ERROR:
					$error = "Backtrack limit exhasuted.";
					break;
				case PREG_RECURSION_LIMIT_ERROR:
					$error = "Too much recursion.";
					break;
				case PREG_BAD_UTF8_ERROR:
					$error = "Bad UTF8.";
					break;
				case PREG_BAD_UTF8_OFFSET_ERROR:
					$error = "Bad UTF8 offset.";
					break;
				default:
					$error = "Unknown PREG error.";
					break;
			}
			throw new FTLabs\MySqlQueryException("Query is empty: ".$error, 0, null, get_defined_vars());
		}

		// Prepare a PDOStatement using the $queryExpr. Prepare is basically doing the same thing parse does above.  Normally you pass in an SQL statement with tokens.  When you execute the statement you pass in the values that should be replaced. Then, internally, the data is escaped and coalesced to the correct type.  However here we're not doing this.  However using a PDOStatement gives us better control over the data returned rather than using the PDO object itself for error messages etc.
		$statement = $this->_db->prepare($queryExpr);

		$start = microtime(true);
		$resultObject = $this->runQuery($statement);
		$end = microtime(true);

		$errorInfo = $statement->errorInfo();
		try {
			$lastInsertId = $this->_db->lastInsertId();
		} catch (PDOException $e){
			$lastInsertId = NULL;
		}

		$resultDetails = array(
			'queryExpr' => $statement->queryString,
			'insertId' => $lastInsertId,
			'timeTaken' => $end - $start,
			'dateExecuted' => $start,
			'errorNo' => $errorInfo[0],
			'errorMsg' => print_r($errorInfo, true),
			'affectedRows' => $statement->rowCount()
		);

		return new MockMySqlResultV4($resultObject, $resultDetails);
	}
}
