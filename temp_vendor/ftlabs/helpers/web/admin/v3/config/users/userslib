<?php
/*
########################################################
Library functions for user management

06/01/2005
Andrew Betts
Assanka Ltd
########################################################
*/

require_once($_SERVER["DOCUMENT_ROOT"]."/lib/inc/global");
if (!isset($_SERVER["ADMIN_AREA_PATH"])) trigger_error("Required constant ADMIN_AREA_PATH not set in environment", E_USER_ERROR);
if (!isset($_SERVER["CORE_PATH"])) trigger_error("Required constant CORE_PATH not set in environment", E_USER_ERROR);
if (!isset($_SERVER["PASSWD_PATH"])) trigger_error("Required constant PASSWD_PATH not set in environment", E_USER_ERROR);

require_once($_SERVER["CORE_PATH"]."/web/admin/v3/auth");
checkIfAuth("config");

// Update an htpasswd entry for a user
function updateHtpasswd($user, $newuser, $newpass) {
	$users = readHtpasswd();
	reset($users);

	// Attempt to detect the format the password should be generated in
	if (count($users)) {
		if (strlen(current($users)) < 25) $format = "basic";
		else $format = "digest";
	} else {
		if ($_SERVER["AUTH_REALM_NAME"]) $format = "digest";
		else $format = "basic";
	}
	
	// Check to see if this user exists already...
	if (!htpasswdUserExists($user)) {
		$users[$user] = "";
	}

	// Generate a new password with a random salt
	if ($newpass and array_key_exists($user, $users)) {
		if ($format == "digest") {
			if ($newuser and ($newuser != $user)) {
				if (array_key_exists($newuser, $users)) return false;
				$userrealmstring = $newuser.":".$_SERVER["AUTH_REALM_NAME"].":";
			} else {
				$userrealmstring = $user.":".$_SERVER["AUTH_REALM_NAME"].":";
			}
			$users[$user] = md5($userrealmstring.$newpass);
		} else {
			$jumble = md5(rand(0,1200).time().rand(0,1200).getmypid().rand(0,1200)); 
			$salt = substr($jumble, 0, 2);
			$cp = crypt($newpass,$salt);
			$users[$user] = $cp;
		}
	}

	// New username?
	if ($newuser && ($newuser != $user)) {
		if (array_key_exists($newuser, $users)) return false;
		$users[$newuser] = $users[$user];
		unset($users[$user]);
	}

	// Write changes to disk
	writeHtpasswd($users);
}

// Remove a user from the htpasswd file if they exist
function htpasswdRemoveUser($user) {
	$users = readHtpasswd();
	if (array_key_exists($user, $users)) unset($users[$user]);
	writeHtpasswd($users);
}

// Check to see if a user is already present in the htpasswd file
function htpasswdUserExists($user) {
	$users = readHtpasswd();
	return array_key_exists($user, $users);
}

// read in the htpasswd file, generating an array of users=>passwords
function readHtpasswd() {
	$fp = fopen($_SERVER["DOCUMENT_ROOT"].$_SERVER["PASSWD_PATH"], "r") or trigger_error("Unable to open the .htpasswd file for reading", E_USER_ERROR);
	$users = array();
	$format = false;
	while (!feof($fp)) {
		$line = fgets($fp, 1024);
		if (trim($line)) {
			$bits = explode(":", trim($line));
			if (count($bits) == 3) {
				if ($format and ($format != "digest")) trigger_error("Mixed password types in the .htpasswd file", E_USER_ERROR);
				if (!$_SERVER["AUTH_REALM_NAME"]) trigger_error("Passwords in .htpasswd stored in digest format but AUTH_REALM_NAME not set", E_USER_ERROR); 
				if (!$format) $format = "digest";
				$users[$bits[0]] = $bits[2];
			} else if (count($bits) == 2) {
				if ($format and ($format != "basic")) trigger_error("Mixed password types in the .htpasswd file", E_USER_ERROR);
				if (!$format) $format = "basic";
				$users[$bits[0]] = $bits[1];
			} else {
				trigger_error(".htpasswd user row could not be recognised", E_USER_ERROR);
			}
		}
	}
	fclose($fp);
	return $users;
}

// Write out a users array to an htpasswd file
function writeHtpasswd($users) {
	$fp = fopen($_SERVER["DOCUMENT_ROOT"].$_SERVER["PASSWD_PATH"], "w") or trigger_error("Unable to open the .htpasswd file for writing", E_USER_ERROR);
	reset($users);

	if (!$users or !count($users)) {
		fwrite($fp, "");
		fclose($fp);
		return true;
	}
	
	// Attempt to detect the format the password should be generated in
	if (strlen(current($users)) < 25) $format = "basic";
	else $format = "digest";

	$op = "";
	foreach($users as $username=>$password) {
		if ($username and $password) {
			if ($format == "digest") {
				$op .= $username.":".$_SERVER["AUTH_REALM_NAME"].":".$password."\n";
			} else {
				$op .= $username.":".$password."\n";
			}
		}
	}
	fwrite($fp, $op);
	fclose($fp);
}

// Grab the available permission levels from the database, returning an array
// in the format $perms["name"] = array("fieldname"=>"permissions_config_role",
// values=>("no access"=>"no access", "access"=>"access")).
function getAvailablePerms() {
	global $db;
	$perms = array();
	$res = $db->query("DESCRIBE cfg_adminusers");
	while ($field = $db->fetchrow($res)) {
		if (preg_match("/^permissions_(.+?)(_role)?$/", $field["Field"], $matches)) {
			$sectionname = $matches[1];
			$optionsarray = explode("','", substr($field["Type"], 6, strlen($field["Type"])-8));
			foreach ($optionsarray as $key=>$value) {
				unset($optionsarray[$key]);
				$optionsarray[$value] = $value;
			}
			$perms[$sectionname]["fieldname"] = $field["Field"];
			$perms[$sectionname]["values"] = $optionsarray;
		}
	}
	return $perms;
}