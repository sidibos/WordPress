#!/usr/bin/php
<?php
/*
########################################################
Generates traffic flow maps

04/11/2004
Andrew Betts
Assanka Ltd
########################################################
*/

// Extract necessary paths from the command line to avoid calling as a web
// call, thus avoiding passing username/password
if (empty($_SERVER["DOCUMENT_ROOT"])) $_SERVER["DOCUMENT_ROOT"] = $_SERVER["argv"][1];
if (empty($_SERVER["CORE_PATH"])) $_SERVER["CORE_PATH"] = $_SERVER["argv"][2];
if (empty($_SERVER["HTTP_HOST"])) $_SERVER["HTTP_HOST"] = $_SERVER["argv"][3];
if (empty($_SERVER["ADMIN_AREA_PATH"])) $_SERVER["ADMIN_AREA_PATH"] = $_SERVER["argv"][4];
if (empty($_SERVER["CORE_WEB_ALIAS"])) $_SERVER["CORE_WEB_ALIAS"] = $_SERVER["argv"][5];
if (empty($_SERVER["SITENAME"])) $_SERVER["SITENAME"] = $_SERVER["argv"][6];
require_once($_SERVER["DOCUMENT_ROOT"]."/lib/inc/global");

// Set options
$exclude = "POST ".$_SERVER["ADMIN_AREA_PATH"]."|GET ".$_SERVER["ADMIN_AREA_PATH"]."|GET ".$_SERVER["CORE_WEB_ALIAS"]."|POST ".$_SERVER["CORE_WEB_ALIAS"]."|GET /lib/|GET /post/|fckeditor|squirrelmail|horde";
$procfile = $_SERVER["DOCUMENT_ROOT"]."/lib/tmp/stats/status.xml";

// Exit if another 'generate' is running for this project, by checking whether the status file is present and locked.
if (!$filehandle = @fopen($procfile, "a+")) exit;
if (!flock($filehandle, LOCK_EX+LOCK_NB)) exit;

// Attempt to detect if 'dot' and 'visitors' are installed, and exit if not present.
$returnstring = exec("/usr/local/bin/visitors -v 2>&1");
if (strpos($returnstring, "Visitors") === false) trigger_error("Flowmap: visitors executable not found in /usr/local/bin/", E_USER_ERROR);
$returnstring = exec("/usr/local/bin/dot -V 2>&1");
if (strpos($returnstring, "version") === false) trigger_error("Flowmap: dot executable not found in /usr/local/bin/", E_USER_ERROR);

// For backwards compatibility with a large number of projects with the RAWSTATSDIR set incorrectly,
// parse the stats directories.
$rawstatsdir = RAWSTATSDIR;
if (preg_match("/\/access_log$/", $rawstatsdir)) $rawstatsdir = substr($rawstatsdir, 0, -strlen("/access_log"));

// If the status file has a size (ie we're taking over from another process), clear it.
writeProgress($procfile, 0);

// Loop through the flowmaps directory, selecting any files to process, and
// generate the flowmap before starting another iteration.
while ($filepath = findFileToProcess($_SERVER["DOCUMENT_ROOT"]."/lib/tmp/stats/")) {
	$logsToProcess = array();

	// Grab the filename from the file path
	$filename = substr($filepath, -14);

	// Create the .dot file
	if (file_exists($filepath.".dot")) unlink($filepath.".dot");
	$dotfile = $filepath.".dot";
	
	// Create the name of a tempfile for later use
	$tempfile = $filepath.".gentemp";
	
	// Note that processing has started, recording the time
	$logStart = time();
	writeProgress($procfile, 1, 0, 0, $filename, 0);

	// Read the parameters
	$start = substr($filename,4,2)."/".substr($filename,0,4);
	$end = substr($filename,10,2)."/".substr($filename,6,4);
	$dates = datearray($start, $end);
	$paths = substr($filename,12,2) - 1;

	// Add date possibilities to the grep 'include' part
	$include = "";
	foreach ($dates as $date) $include.="|".date("M/Y",getStatsStartDate($date));
	$include = substr($include,1,strlen($include)-1);

	// Specify site prefixes
	$prefix = "";
	foreach ($SITEHOSTS as $host) $prefix.=" --prefix http://$host ";
	
	// Now build an array of all access logs in the appropriate dir
	exec("nice -n 19 find ".escapeshellarg($rawstatsdir)." -name ".escapeshellarg(RAWSTATSBASENAME."*")." |nice -n 19 grep -v \~", $accessLogs);
	
	// Iterate through the list of access logs, checking to see if they
	// need to be used in this operation.  This is done by fetching the
	// first and last lines in the file, extracting the date, and
	// comparing to the supplied dates.
	for ($i=0; $i<count($accessLogs); $i++) {
		$execStartMatches = array();
		$execEndMatches = array();
		exec("head -n 1 ".escapeshellarg($accessLogs[$i]), $execStartMatches);
		preg_match("/\[(\d{2})\/([a-zA-Z]{3})\/(\d{1,4}):[\d: -+]*\]/", $execStartMatches[0], $matches);
		if (strtotime("1 ".$matches[2]." ".$matches[3]) <= strtotime(substr($end,0,2)."/01/".substr($end,3,4))) {
			exec("tail -n 1 ".escapeshellarg($accessLogs[$i]), $execEndMatches);
			preg_match("/\[(\d{2})\/([a-zA-Z]{3})\/(\d{1,4}):[\d: -+]*\]/", $execEndMatches[0], $matches);
			if (strtotime("1 ".$matches[2]." ".$matches[3]) >= strtotime(substr($start,0,2)."/01/".substr($start,3,4))) {
				$logsToProcess[] = $accessLogs[$i];
			}
		}
	}

	writeProgress($procfile, 2, 1, count($logsToProcess)+1, $filename, time()-$logStart);

	
	// We now have a list of access files; process them into a temp file,
	// one by one for slightly increased granularity
	for ($i=0; $i<count($logsToProcess); $i++) {
		$cmd = "nice -n 19 cat ".escapeshellarg($logsToProcess[$i])." |nice -n 19 egrep -v ".escapeshellarg($exclude)." |nice -n 19 egrep ".escapeshellarg($include)." |nice -n 19 /bin/sed \"s/\/ HTTP/ HTTP/g\"|nice -n 19 /bin/sed \"s/\/\\\" /\\\" /g\" >>".escapeshellarg($tempfile);
		exec($cmd, $retval);
		if ($retval) {
			deleteTempFiles($dotfile, $tempfile, $procfile);
			trigger_error("Whilst stepping through logfiles using cmd \n\n $cmd \n\n an unexpected return value ($retval) was received.", E_USER_ERROR);
		}
		writeProgress($procfile, 2, $i+2, count($logsToProcess)+1, $filename, time()-$logStart);
	}

	writeProgress($procfile, 3, 0, 0, $filename, time() - $logStart);

	// Generate the appropriate dot file
	$cmd = "nice -n 19 /usr/local/bin/visitors -V ".$prefix." --max-trails ".$paths." ".$tempfile." >".$dotfile;
	exec($cmd, $retval);
	if ($retval) {
		deleteTempFiles($dotfile, $tempfile, $procfile);
		trigger_error("Whilst running 'visitors' using \n\n $cmd \n\n an unexpected return value was received.", E_USER_ERROR);
	}
	writeProgress($procfile, 4, 0, 0, $filename, time() - $logStart);
	
	// Post-process the dot file to clean up oddities; correct invisibly thin lines,
	// and add arrowheads which are an appropriate size for each line
	exec("nice -n 19 sed -i -e 's/setlinewidth.0.\\\"/setlinewidth(0.5)\\\"/g' -e 's/setlinewidth.0\\.5.\\\"\\] \\[arrowsize\\=[0-9]*\\]/setlinewidth(0.5)\"] [arrowsize=0.3]/g' -e 's/setlinewidth.\\([0-2]\\).\\\"\\] \\[arrowsize\\=[0-9]*\\]/setlinewidth(\\1)\"] [arrowsize=0.5]/g' -e 's/setlinewidth.\\([3-5]\\).\\\"\\] \\[arrowsize\\=[0-9]*\\]/setlinewidth(\\1)\"] [arrowsize=1.25]/g' -e 's/setlinewidth.\\([7-9]\\).\\\"\\] \\[arrowsize\\=[0-9]*\\]/setlinewidth(\\1)\"] [arrowsize=2]/g' -e 's/setlinewidth.\\(1[0-5]\\).\\\"\\] \\[arrowsize\\=[0-9]*\\]/setlinewidth(\\1)\"] [arrowsize=3]/g' -e 's/setlinewidth.\\(1[6-9]\\).\\\"\\] \\[arrowsize\\=[0-9]*\\]/setlinewidth(\\1)\"] [arrowsize=4]/g' -e 's/setlinewidth.\\([2-9][0-5]\\).\\\"\\] \\[arrowsize\\=[0-9]*\\]/setlinewidth(\\1)\"] [arrowsize=6.2]/g' ".$dotfile);

	// Then change the font:
	exec("sed -i -e 's/fontname=\\\"Helvetica\\\"/fontname=\\\"\\/assanka\\/web\\/admin\\/v3\\/fonts\\/arial.ttf\\\"/g' ".$dotfile);

	$dotoptions = "-Goutputorder=edgesfirst -Nfillcolor=gray100 -Nstyle=\"rounded,filled,setlinewidth(1)\" -Earrowhead=normal -Eheadclip=true -Etailclip=false -Nfontsize=10 -Nheight=0.2";
	
	// Render directly to PNG
	$rendercmd = "nice -n 19 /usr/local/bin/dot ".$dotfile." ".$dotoptions." -Tpng >".$filepath;

	exec($rendercmd,$retval);
	if ($retval) trigger_error("Whilst running 'dot' using \n\n $rendercmd \n\n an unexpected return value was received.", E_USER_ERROR);
	
	deleteTempFiles($dotfile, $tempfile, false);
	
	sleep(5);
}

// Close the locked handle and delete the status file
deleteTempFiles(false, false, $procfile);
fclose($filehandle);






function deleteTempFiles($dotfile, $tempfile, $procfile) {

	// Delete temporary files used during generation; moved to a
	// function so temporary files can be deleted when errors occur
	if ($dotfile and file_exists($dotfile)) unlink($dotfile);
	if ($tempfile and file_exists($tempfile)) unlink($tempfile);
	
	// The status.xml file is never fully deleted to avoid expensive
	// 404 file loading.
	if ($procfile and file_exists($procfile)) writeProgress($procfile, 0);
}

/* Fetch an array of months (inclusive) between start and end. Then derive
the raw AWStats filenames for the appropriate log files, and pull all the
data into one long array. */
function datearray($start = "now", $end = "now") {

	$start = str_replace("/", "", $start);
	$end = str_replace("/", "", $end);

	if(!is_numeric($start) and strlen($start) != 6) $start = strftime("%m%Y");
	if(!is_numeric($end) and strlen($end) != 6) $end = strftime("%m%Y");

	$startmonth = substr($start,0,2);
	$startyear = substr($start,2,4);
	$endmonth = substr($end,0,2);
	$endyear = substr($end,2,4);

	if ($endyear.$endmonth < $startyear.$startmonth) trigger_error("End date was before start date whilst loading statistics",E_USER_ERROR);

	$offset=0;
	do {
		$month = strftime("%m%Y",mktime(0,0,0,$startmonth+$offset,1,$startyear));
		$datearray[] = $month;
		$offset++;
	} while ($offset < 100 and $month != $endmonth.$endyear);

	return $datearray;
}

function getStatsStartDate($date = "now") {
	$date = str_replace("/","",$date);
	if(!is_numeric($date) and strlen($date)!=6) $date=strftime("%m%Y");

	$datemonth = substr($date,0,2);
	$dateyear = substr($date,2,4);

	return mktime(0,0,0,$datemonth,1,$dateyear);
}

// Loop through the stats folder until a file is found to process, and then return the path to it.
// If no file is found, return false.
function findFileToProcess($path) {
	if (substr($path, strlen($path) - 1) == "/") $path = substr($path, 0, strlen($path) - 1);
	if (!$dir = opendir($path)) return false;
	while (false !== ($file = readdir($dir))) {
		
		// Use is_numeric first for speed purposes before checking validity of the file
		if (is_numeric($file)) {
			if ((filesize($path."/".$file) == 0) and preg_match("/^[0-9]{14}$/", $file, $matches)) {
				return $path."/".$file;
			}
		}
	}
	closedir($dir);
	return false;
}

function writeProgress($file, $stage, $thisstep = false, $maxsteps = false, $statid = false, $logTime = false) {
	global $filehandle;
	$theXML = "<?php\nheader( 'Cache-Control: no-cache' );\nheader( 'Pragma: no-cache' );\n?>";
		
	if ($stage == 0) {
		$theXML = "<response></response>";
	} else {
		$theXML = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n";
		$theXML .= "<response>\n<stage>".$stage."</stage>\n<thisstep>".$thisstep."</thisstep>\n<maxsteps>".$maxsteps."</maxsteps>\n<pid>".$statid."</pid>\n<logtime>".$logTime."</logtime>\n</response>";
	}
	ftruncate($filehandle, 0);
	fwrite($filehandle, $theXML);
}

?>
