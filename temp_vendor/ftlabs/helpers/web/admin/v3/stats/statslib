<?php
/*
########################################################
Statistics library:  

This contains functions to process raw AWStats log files
and output the data as an array for processing elsewhere

September 2004
Robert Shilston
Assanka Ltd
########################################################
*/

// Link in core files so stats files only have to include this lib
require_once($_SERVER["DOCUMENT_ROOT"]."/lib/inc/global");
if (!isset($_SERVER["CORE_PATH"])) trigger_error("Required constant CORE_PATH not set in environment", E_USER_ERROR);
require_once($_SERVER["CORE_PATH"]."/web/admin/v3/auth");

// Ensure the user has access to the stats section
checkIfAuth("statistics", (($_SERVER["PHP_AUTH_USER"])?$_SERVER["PHP_AUTH_USER"]:$_SERVER["REMOTE_USER"]));

// Increase memory limit, as some of the log file processes eat up memory
ini_set("memory_limit", "64M");
set_time_limit(120);

// Provide a function to get the access level of the current user
function getStatsAccessLevel() {
	global $db;
	
	$result = $db->query("SELECT permissions_statistics_role FROM cfg_adminusers WHERE htaccessuser='".$db->sqlenc(($_SERVER["PHP_AUTH_USER"])?$_SERVER["PHP_AUTH_USER"]:$_SERVER["REMOTE_USER"])."'", true);
	if(!is_resource($result)) $result = $db->query("SELECT permissions_statistics FROM cfg_adminusers WHERE htaccessuser='".$db->sqlenc(($_SERVER["PHP_AUTH_USER"])?$_SERVER["PHP_AUTH_USER"]:$_SERVER["REMOTE_USER"])."'", true);
	if(is_resource($result) && $db->numresults($result)) {
		$authuserstatslevel = $db->singleresult($result);
	} else {
		$authuserstatslevel = "no access";
	}
	
	return $authuserstatslevel;
}

// Outputs the premium guide blurb
function outputPremiumGuideAndExit(&$page) {
	$page->addContent("content", $page->loadExternalContent($_SERVER["CORE_PATH"]."/web/admin/v3/stats/html/premiumguide"));
	$page->render();
	exit;
}

// Returns the number of visitors between a range of dates
function getVisitors($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_VISITOR"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_VISITOR", "END_VISITOR", $offset);

			// Explode to "Host - Pages - Hits - Bandwidth - Last visit date"
			$rawdata = explode("\n",$rawdata);

			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
					if ($bits[0]) {
						if (empty($data[$bits[0]])) $data[$bits[0]] = array("ip"=>$bits[0], "pages"=>0, "hits"=>0, "bandwidth"=>0, "lastvisit"=>0);
						$data[$bits[0]]["pages"]+=$bits[1];
						$data[$bits[0]]["hits"]+=$bits[2];
						$data[$bits[0]]["bandwidth"]+=$bits[3];
						if ($bits[4]>$data[$bits[0]]["lastvisit"]) $data[$bits[0]]["lastvisit"]=$bits[4];
					}
			}
		}
	}
	// Return array
	return $data;
}

// Return an array of keywords used on search engines to locate the site
function getKeywords($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_SEARCHWORDS"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_SEARCHWORDS", "END_SEARCHWORDS", $offset);

			// Explode to "Phrase - Occurences"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = array("query"=>$bits[0], "hits"=>0);
					$data[$bits[0]]["hits"]+=urldecode($bits[1]);
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetch an array of referers to the site
function getReferers($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_PAGEREFS"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_PAGEREFS", "END_PAGEREFS", $offset);

			// Explode to "External Site - Pages - Hits"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = array("referrer"=>$bits[0], "pages"=>0, "hits"=>0);
					//$data[$bits[0]]["pages"]+=$bits[1];
					$data[$bits[0]]["hits"]+=$bits[2];
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetch an array of search engine referals to the site
function getSearchEngines($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_SEREFERRALS"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_SEREFERRALS", "END_SEREFERRALS", $offset);

			// Explode to "SEREFERRALS - Pages - Hits"
			$rawdata = explode("\n",$rawdata);

			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = array("engine"=>$bits[0], "pages"=>0, "hits"=>0);
					$data[$bits[0]]["pages"]+=$bits[1];
					$data[$bits[0]]["hits"]+=$bits[2];
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetch an array of browsers used to view the site
function getBrowser($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_BROWSER"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_BROWSER", "END_BROWSER", $offset);

			// Explode to "Browser - Visits"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if (empty($data[$bits[0]])) $data[$bits[0]] = 0;
				$data[$bits[0]]+=$bits[1];
			}
		}
	}
	// Return array
	return $data;
}

// Fetch an array of operating systems used to view the site
function getOS($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_OS"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_OS", "END_OS", $offset);

			// Explode to "OS - Visits"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = 0;
					$data[$bits[0]]+=$bits[1];
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetch an array of file types accessed on the site
function getFileTypes($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_FILETYPES"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_FILETYPES", "END_FILETYPES", $offset);

			// Explode to "Files type - Hits - Bandwidth - Bandwidth without compression - Bandwidth after compression"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = array("extension"=>$bits[0], "hits"=>0, "bandwidth"=>0);
					$data[$bits[0]]["extension"]=$bits[0];
					$data[$bits[0]]["hits"]+=$bits[1];
					$data[$bits[0]]["bandwidth"]+=$bits[2];
					//$data[$bits[0]]["withoutcompression"]+=$bits[3];
					//$data[$bits[0]]["withcompression"]+=$bits[4];
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetches an array of the most popular pages on the site
function getPages($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_SIDER"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_SIDER", "END_SIDER", $offset);

			// Explode to " URL - Pages - Bandwidth - Entry - Exit"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = array("page"=>$bits[0], "hits"=>0, "bandwidth"=>0, "entry"=>0, "exit"=>0);
					$data[$bits[0]]["hits"]+=$bits[1];
					$data[$bits[0]]["bandwidth"]+=$bits[2];
					$data[$bits[0]]["entry"]+=$bits[3];
					$data[$bits[0]]["exit"]+=$bits[4];
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetches an array of average session lengths
function getSession($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array("0s-30s"=>array("duration"=>0), "30s-2mn"=>array("duration"=>1), "2mn-5mn"=>array("duration"=>2), "5mn-15mn"=>array("duration"=>3), "15mn-30mn"=>array("duration"=>4), "30mn-1h"=>array("duration"=>5), "1h+"=>array("duration"=>6));
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_SESSION"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_SESSION", "END_SESSION", $offset);

			// Explode to "Range - Visits"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = 0;
					$data[$bits[0]]["visits"] += $bits[1];
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetches an array of hits by day for processing
function getDays($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";

		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_DAY"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_DAY", "END_DAY", $offset);

			// Explode to "Date - Pages - Hits - Bandwidth - Visits"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					$data["pages"][$bits[0]]=$bits[1];
					$data["hits"][$bits[0]]=$bits[2];
					$data["bandwidth"][$bits[0]]=$bits[3];
					$data["visits"][$bits[0]]=$bits[4];
				}
			}
		}
	}
	// Return array
	return $data;
}

// Fetches an array of the most common error codes logged
function getErrorCodes($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	foreach (datearray($start, $end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_ERRORS"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_ERRORS", "END_ERRORS", $offset);

			// Explode to "Status code - Hits - Bandwidth"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data["hits"][$bits[0]])) $data["hits"][$bits[0]] = $bits[1];
					else $data["hits"][$bits[0]]+=$bits[1];
					if (empty($data["bandwidth"][$bits[0]])) $data["bandwidth"][$bits[0]] = $bits[2];
					else $data["bandwidth"][$bits[0]]+=$bits[2];
				}
			}
		}
	}

	// Return array
	return $data;
}

// Fetches an array of the most common 404 pages
function get404Pages($start = "now", $end = "now", $sitename = AWSTATSNAME, $dir = AWSTATSDIR) {
	$data = array();
	foreach (datearray($start,$end) as $thismonth) {
		$filename = $dir."awstats".$thismonth.".".$sitename.".txt";
		if (file_exists($filename)) {
			// First, get the map of data, so that direct IO can be used:
			$map = getMap($filename);

			// Locate the entry corresponding to BEGIN_DAY
			$offset = $map["POS_SIDER_404"];

			// Read the data from the file
			$rawdata = readString($filename, "BEGIN_SIDER_404", "END_SIDER_404", $offset);

			// Explode to "URL - Hits - Referrer"
			$rawdata = explode("\n",$rawdata);
			foreach ($rawdata as $line) {
				$bits = explode(" ",$line);
				if ($bits[0]) {
					if (empty($data[$bits[0]])) $data[$bits[0]] = array("page"=>$bits[0], "hits"=>0, "referrer"=>"");
					$data[$bits[0]]["hits"]+=$bits[1];
					$data[$bits[0]]["referrer"]=$bits[2];
				}
			}
		}
	}

	// Return array
	return $data;
}

// Returns an array containing details and status of all traffic flow maps.
function getFlowmaps($flowmapdir = "/lib/tmp/stats") {
	$flowmaps = array();
	$status = array();
	$path = $_SERVER["DOCUMENT_ROOT"].$flowmapdir;
	
	if (file_exists($path."/status.xml") and is_readable($path."/status.xml")) {
		$statusstring = file_get_contents($path."/status.xml");
		if (preg_match("/<stage>(.*?)<\/stage>\n<thisstep>(.*?)<\/thisstep>\n<maxsteps>(.*?)<\/maxsteps>\n<pid>(.*?)<\/pid>/", $statusstring, $matches)) {
			$status = array("stage"=>$matches[1], "step"=>$matches[2], "totalsteps"=>$matches[3], "filename"=>$matches[4]);
		}
	}
	$theXML = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n";
	$theXML .= "<response>\n<stage>".$stage."</stage>\n<thisstep>".$thisstep."</thisstep>\n<maxsteps>".$maxsteps."</maxsteps>\n<pid>".$statid."</pid>\n<logtime>".$logTime."</logtime>\n</response>";
	
	$flowmapfiles = array();
	if ($dir = opendir($path)) {
		while (false !== ($file = readdir($dir))) {
			if (!is_file($path."/".$file) or ($file[0] == ".")) continue;
			if (preg_match("/^[0-9]{14}$/", $file)) $flowmapfiles[$file] = $path."/".$file;
		}
		closedir($dir);
	}

	foreach ($flowmapfiles as $file=>$path) {
		$flowmap = array();
		$flowmap["start"] = substr($file, 0, 6);
		$flowmap["startlong"] = date("M Y", mktime(0, 0, 0, substr($file, 4, 2), 1, substr($file, 0, 4)));
		$flowmap["end"] = substr($file, 6, 6);
		$flowmap["endlong"] = date("M Y", mktime(0, 0, 0, substr($file, 10, 2), 1, substr($file, 6, 4)));
		$flowmap["paths"] = substr($file, 12, 2);
		$flowmap["generated"] = filemtime($path);
		$flowmap["generatedlong"] = date("jS M Y", $flowmap["generated"]);
		if (@filesize($path) > 0) $flowmap["complete"] = true;
		else $flowmap["complete"] = false;
		if (!empty($status["filename"]) and $status["filename"] = $file) {
			$flowmap = array_merge($flowmap, $status);
		}
		$flowmap["filename"] = $file;
		$flowmaps[] = $flowmap;
	}
	
	return $flowmaps;
}

// Misc functions: Below this point are various functions to help.  It's unlikely these need to be altered.

// Open the log file, and return the location of each data
// section, as reported by the log file.  This is not validated
// but is sorted by order through the file
function getMap($filename = AWSTATSLOG) {
	
	// Search for appropriate entries
	$map = readString($filename, "BEGIN_MAP", "END_MAP", 0);

	// Explode into an array:
	$lines = explode("\n",$map);

	// Then make into a keyed array:
	foreach ($lines as $line) {
		$bits = explode(" ",$line);
		$sections[$bits[0]] = $bits[1];
	}
	natsort($sections);
	
	return $sections;
}

// Remove admin parts of the site and items in /lib
function removePrivateAndLibData($data) {

	$v3coreset = false;
	if (!empty($_SERVER["ADMIN_AREA_PATH"]) and !empty($_SERVER["CORE_WEB_ALIAS"])) $v3coreset = true;

	foreach ($data as $key=>$values) {
		if ($v3coreset) {
			if ((strpos($values["page"], $_SERVER["ADMIN_AREA_PATH"]."/") === 0) or (strpos($values["page"], $_SERVER["CORE_WEB_ALIAS"]."/") === 0) or (strpos($values["page"], "/lib/") === 0)) unset($data[$key]);

		// Include old methods of comparison for backwards compatibility; can probably be cleaned up in future.
		} else {
			if ((strpos($values["page"], "/lib/") === 0) or (strpos($values["page"], "/administration/") === 0) or (strpos($values["page"], "/admin/") === 0)) unset($data[$key]);
		}
	}

	return $data;
}

// Start the traffic flow map generator if it's not already running.
function startFlowMapGenerator() {
	exec("bash -c \"exec nohup setsid nice -n 19 php ".$_SERVER["CORE_PATH"]."/web/admin/v3/stats/flowmap/generate ".escapeshellarg($_SERVER["DOCUMENT_ROOT"])." ".escapeshellarg($_SERVER["CORE_PATH"])." ".escapeshellarg($_SERVER["HTTP_HOST"])." ".escapeshellarg($_SERVER["ADMIN_AREA_PATH"])." ".escapeshellarg($_SERVER["CORE_WEB_ALIAS"])." ".escapeshellarg($_SERVER["SITENAME"])." > /dev/null 2>&1 &\"");
}

// Reads a section of a file, delimited by startstring and stopstring, with an optional offset
function readString($filename, $startstring, $stopstring, $offset=0) {
	$handle = fopen($filename, "r");
	$filesize = filesize($filename);
	$readchunk = 2048;

	while ((strpos($contents,$stopstring)===false) AND (($offset + $readchunk) < $filesize)) {
		fseek($handle, $offset);
		$contents .= fread($handle, $readchunk);
		$offset += $readchunk;
	}

	// Then read the last little bit, if needed:
	if (strpos($contents,$stopstring)===false) {
		fseek($handle, $offset);
		$contents .= fread($handle, $filesize - $offset);
	}

	// Close the file:
	fclose($handle);
	
	// Search for appropriate entries
	$startpos = strpos($contents,$startstring);
	$endpos = strpos($contents,$stopstring);

	if ($startpos===false) trigger_error("Start string not found",E_USER_NOTICE);
	if ($endpos===false) trigger_error("End string not found",E_USER_NOTICE);

	if ($startpos===false OR $endpos===false) {
		return false;
	} else {
		// Trim as appropriate
		$startpos = strpos($contents,"\n",$startpos);
		$string = trim(substr(substr($contents, $startpos+1, $endpos-$startpos-2),0,$endpos-$startpos-1));

		if ($string) {
			return $string;
		} else {
			return false;
		}
	}
}

// Need to get an array of months between start and end (nb: date range is fully inclusive)
// Then workout the raw AWStats filenames for the appropriate log files, and pull all the
// data into one long array.
function datearray($start = "now", $end = "now") {

	$start = str_replace("/","",$start);
	$end = str_replace("/","",$end);

	if(!is_numeric($start) and strlen($start)!=6) $start=strftime("%m%Y");
	if(!is_numeric($end) and strlen($end)!=6) $end=strftime("%m%Y");

	$startmonth = substr($start,0,2);
	$startyear = substr($start,2,4);
	$endmonth = substr($end,0,2);
	$endyear = substr($end,2,4);

	if ($endyear.$endmonth < $startyear.$startmonth) trigger_error("End date was before start date whilst loading statistics",E_USER_ERROR);

	$offset=0;
	do {
		$month = strftime("%m%Y",mktime(0,0,0,$startmonth+$offset,1,$startyear));
		$datearray[] = $month;
		$offset++;
	} while ($offset<100 and $month!=$endmonth.$endyear);

	return $datearray;
}

function getStatsStartDate($date = "now") {
	$date = str_replace("/","",$date);
	if(!is_numeric($date) and strlen($date)!=6) $date=strftime("%m%Y");

	$datemonth = substr($date,0,2);
	$dateyear = substr($date,2,4);

	return mktime(0,0,0,$datemonth,1,$dateyear);
}

function getStatsEndDate($date = "now") {
	$date = str_replace("/","",$date);
	if(!is_numeric($date) and strlen($date)!=6) $date=strftime("%m%Y");

	$datemonth = substr($date,0,2);
	$dateyear = substr($date,2,4);

	return mktime(0,0,0,$datemonth+1,-1,$dateyear);
}

function checkDateFilters(&$startdate, &$enddate, &$page, $enddateonly=false) {
	if (!$startdate && !$enddateonly) {
		$page->alert("The start date was not recognised; please enter the start date in mm/yyyy format.  Your start date setting is being ignored.", "warning");
	}
	if (!$enddate) {
		$page->alert("The end date was not recognised; please enter the end date in mm/yyyy format.  Your end date setting is being ignored.", "warning");
		$enddate = time();
	}
	if (!$enddateonly) {
		if ($startdate > $enddate) {
			$page->alert("The start date was after the end date; it has been set to the same month as the end date.", "warning");
			$startdate = $enddate;
		}
		if (!$startdate) $startdate = strtotime("-1 month", $enddate) + 1;
	}
	$enddate = strtotime("+1 month", strtotime(date('m/01/Y', $enddate))) - 1;
	if (!$enddateonly) $startdate = strtotime(date('m/01/Y', $startdate)) + 1;
}


function processDayStats ($end=0, $resolution="months", $sitename=AWSTATSNAME, $dir=AWSTATSDIR) {
	if (!$end) $end = time();
	
	// Work out the start date based on the end date and resolution
	switch ($resolution) {
		case "months":
			$start = strtotime("-12 months", $end) + 1;
			break;
		case "weeks":
			$start = strtotime("-6 months", $end) + 1;
			break;
		default:
			$start = strtotime("-1 month", $end) + 1;
			break;
	}
	
	// Get the information by date
	$data = getDays(date("mY", $start), date("mY", $end), $sitename, $dir);

	// The data is now in a format of results for every day in the date range.
	// We want to cycle through this with the correct resolution, aggregating
	// results.  (eg $data["pages"][20051231])
	$processeddatestats = array();
	$processdate = $start;
	while ($processdate < $end) {
		$datestoadd = array();
		
		// Use the timestamp at the start of this date period as the date key
		$datekey = $processdate;
		
		// According to the requested resolution, add the days to process this cycle
		switch ($resolution) {
			case "months":
				$enddate = strtotime("+1 month", $processdate);
				while ($processdate < $enddate) {
					$datestoadd[] = date("Ymd", $processdate);
					$processdate = strtotime("+1 day", $processdate);
				}
				break;
			case "weeks":
				$enddate = strtotime("+1 week", $processdate);
				while ($processdate < $enddate) {
					$datestoadd[] = date("Ymd", $processdate);
					$processdate = strtotime("+1 day", $processdate);
				}
				break;
			default:
				$datestoadd[] = date("Ymd", $processdate);
				$processdate = strtotime("+1 day", $processdate);
				break;
		}
		
		// Add a basic zero value for this timestamp
		$processeddatestats[$datekey] = array("date"=>$datekey, "hits"=>0, "pages"=>0, "visits"=>0, "bandwidth"=>0);
		
		// Now cycle through the days in this cycle, adding them to the timestamp.
		foreach ($datestoadd as $datetoadd) {
			if ($data["hits"][$datetoadd]) {
				$processeddatestats[$datekey]["hits"] += $data["hits"][$datetoadd];
				$processeddatestats[$datekey]["pages"] += $data["pages"][$datetoadd];
				$processeddatestats[$datekey]["visits"] += $data["visits"][$datetoadd];
				$processeddatestats[$datekey]["bandwidth"] += $data["bandwidth"][$datetoadd];
			}
		}
	}
	return $processeddatestats;
}

// This function takes an array of data, later to be used to construct
// a table, and the data table it is due to be inserted into; it then
// reads the column to sort by (and the direction to sort in) from the
// table, and sorts the data appropriately. NOTE: Data keys and
// column names should already match, and top-level keys in the array
// will be lost!  $data[TIMECODE]["hits"][1] => $data[0]["hits"][1]
function sortArrayBasedTable(&$array, &$datatable, $sortby=false, $sortdir=false) {
	$sb = (($sortby)?$sortby:$datatable->sortby);
	$sd = (($sortdir)?$sortdir:$datatable->sortdir);
	
	if (!count($array)) return;
	
	$arraytosort = array();

	// Check for whether the data type is numeric in order to use fastest sort at all times
	$dataisnumeric = true;
	$datacheck = 0;
	foreach ($array as $data) {
		$datacheck++;
		if ($datacheck > 10) break;
		if (!is_numeric($data[$sb])) $dataisnumeric = false;
	}
	$sortcheck = end($array);
	if (!is_numeric($sortcheck[$sb])) $dataisnumeric = false;
	
	// For numeric data, track largest potential key to avoid integer overflow.  Slower.
	if ($dataisnumeric) {
		$maxvalue = 0;
		foreach ($array as $data) {
			$arraytosort[$data[$sb]] = $data;
			$maxvalue = max($data[$sb], $maxvalue);
		}
	
		// Check for key integer overflow and if so use string sort by padding and converting to string
		if ($maxvalue >= 2147483647) {
			$printfstring = "a%0".strlen((string)$maxvalue)."s";
			$arraytosort = array();
			foreach ($array as $data) {
				$arraytosort[sprintf($printfstring, $data[$sb])] = $data;
			}
		}

	// For strings use the normal string sort
	} else {
		foreach ($array as $data) {
			$arraytosort[$data[$sb]] = $data;
		}
	}
	
	if ($sd == "ASC") {
		ksort($arraytosort);
	} else {
		krsort($arraytosort);
	}
	$array = $arraytosort;
}

// Outputs a date string blurb for use in the informational sidebar
function getStatsDateString($start, $end) {
	return "<div class=\"paddedcontent\">The data displayed covers the period <strong>".date($_SERVER["PHPDATE"], $start)."</strong> to <strong>".date($_SERVER["PHPDATE"], $end)."</strong>.</div>";
}

// From the PHP manual, comment by king dot macro at gmail dot com
function gethostbyaddr_timeout($ip, $dns="208.67.222.222", $timeout=1)
{
	// random transaction number (for routers etc to get the reply back)
	$data = rand(0, 99);

	// trim it to 2 bytes
	$data = substr($data, 0, 2);

	// request header
	$data .= "\1\0\0\1\0\0\0\0\0\0";

	// split IP up
	$bits = explode(".", $ip);

	// error checking; Assanka change: simply return unmodified IP.
	if (count($bits) != 4) return $ip;

	// there is probably a better way to do this bit...
	// loop through each segment
	for ($x=3; $x>=0; $x--)
	{
		// needs a byte to indicate the length of each segment of the request
		switch (strlen($bits[$x]))
		{
			case 1: // 1 byte long segment
				$data .= "\1"; break;
			case 2: // 2 byte long segment
				$data .= "\2"; break;
			case 3: // 3 byte long segment
				$data .= "\3"; break;
			default: // segment is too big, invalid IP; Assanka change: return unmodified IP.
				return $ip;
		}
		
		// and the segment itself
		$data .= $bits[$x];
	}
	
	// and the final bit of the request
	$data .= "\7in-addr\4arpa\0\0\x0C\0\1";
	
	// create UDP socket
	$handle = @fsockopen("udp://$dns", 53);
	
	// send our request (and store request size so we can cheat later)
	$requestsize = @fwrite($handle, $data);

	@socket_set_timeout($handle, $timeout, 0);

	// hope we get a reply
	$response = @fread($handle, 1000);
	@fclose($handle);
	if ($response == "")
		return $ip."3";

	// find the response type
	$type = @unpack("s", substr($response, $requestsize+2));
	if ($type[1] == 0x0C00)  // answer
	{

		// set up our variables
		$host="";
		$len = 0;

		// set our pointer at the beginning of the hostname
		// uses the request size from earlier rather than work it out
		$position=$requestsize+12;

		// reconstruct hostname
		do {

			// get segment size
			$len = unpack("c", substr($response, $position));

			// null terminated string, so length 0 = finished
			if ($len[1] == 0)

				// return the hostname, without the trailing .
				return substr($host, 0, strlen($host) -1);

			// add segment to our host
			$host .= substr($response, $position+1, $len[1]) . ".";

			// move pointer on to the next segment
			$position += $len[1] + 1;
		} while ($len != 0);

		// error - return the hostname we constructed (without the . on the end)
		return $ip;
	}
	return $ip;
}

?>
