<?php
/**
 * Handle retrieving and storing user data from a database.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once($_SERVER['CORE_PATH'].'/helpers/authentication/v2/interfaces');

/**
 * Implement a basic extension of the standard user datastore interface
 * which supports loading data from - and storing data back to - a database.
 * Currently does not use MemCache.
 */
class DatabaseUser implements AssankaUserDataStoreInterface {

	private static $_dbread, $_dbwrite;
	private static $_usertable = 'users', $_userfield = 'email', $_passwordfield = 'password', $_passwordresetfield;
	private static $_passwordsalt = 'Bz03;fF';

	private $_data, $_usesession = false, $_usedsession = false;

	/**
	 * Constructor
	 *
	 * Constructor requiring the basic connection details required for database use - a database connection object, the table name where the user is stored, and the id to use when looking up the user.  The database handle must support reading, and may support writing (see setWriteDatabaseConnectorHandle)
	 *
	 * @param string  $userlogin       The login/identifier of the user to use
	 * @param boolean $usesessioncache Whether to use session-cached details if available
	 *
	 * @return DatabaseUser		The new DatabaseUser object
	 */
	public function __construct($userlogin, $usesessioncache = true) {
		if (empty($userlogin)) throw new AssankaException('Cannot create a DatabaseUser without an identifier', 0, null, $userlogin);

		if ($usesessioncache and session_id()) $this->_usesession = true;

		if ($this->_usesession and !empty($_SESSION['AuthDatabase']) and $_SESSION['AuthDatabase']['userlogin'] == $userlogin) {
			$this->_data = $_SESSION['AuthDatabase']['userdata'];
			$this->_usedsession = true;
		} else {
			$this->_data = self::$_dbread->queryRow('SELECT * FROM '.$this->_sqlFieldEnc(self::$_usertable).' WHERE '.$this->_sqlFieldEnc(self::$_userfield).'=%s', $userlogin);
			if ($this->_usesession and $this->_data) {
				$_SESSION['AuthDatabase'] = array('userlogin'=>$userlogin, 'userdata'=>$this->_data);
			}

			// Support lookups by a reset code if the field has been set
			if (!empty($_REQUEST['authrc']) and $userlogin == $_REQUEST['authrc'] and !empty(self::$_passwordresetfield)) {
				$this->_data = self::$_dbread->queryRow('SELECT * FROM '.$this->_sqlFieldEnc(self::$_usertable).' WHERE '.$this->_sqlFieldEnc(self::$_passwordresetfield).'=%s', $userlogin);
			}
		}

		if (!$this->_data) throw new AssankaException("Cannot create DatabaseUser: user not found", 0, null, $userlogin);
	}

	/**
	 * getData
	 *
	 * Returns all the data available for the user - except the password hash - or, if requested, returns only a specified column.
	 *
	 * @param string $key An optional data key name - if supplied and that key is not recognised as a valid column, returns null.
	 *
	 * @return mixed	Returns an array of data, or an individual data item, as requested.
	 */
	public function getData($key = false) {
		if ($key) {
			if (isset($this->_data[$key])) return $this->_data[$key];
			return null;
		}

		$cleanedarray = $this->_data;
		unset($cleanedarray[self::$_passwordfield]);
		return $cleanedarray;
	}

	/**
	 * verifyPassword
	 *
	 * Checks whether the supplied password for a user is correct by comparing it to the hashed version stored with the user.  If the password verification fails, and the session store is enabled, the session store is cleared to prevent the invalid user being logged back in - unless explicitly requested.
	 *
	 * @param string $password        The password to verify
	 * @param bool   $logoutonfailure (Optional) Whether the user should be logged out if the verification check fails - defaults to yes as this is usually the desired behaviour.
	 *
	 * @return boolean Whether the password is correct
	 */
	public function verifyPassword($password, $logoutonfailure = true) {
		$passwordverified = ($this->_hashPassword($password) == $this->_data[self::$_passwordfield]);
		if (!$passwordverified and $this->_usesession and $logoutonfailure) {
			$_SESSION['AuthDatabase'] = false;
		}
		if ($this->_usesession) $this->_usedsession = false;
		return $passwordverified;
	}

	/**
	 * setData
	 *
	 * Updates data for the user, either with an entirely updated array or with individual keys.  If a new password is supplied it will be hashed automatically before storing - see setPasswordDetails.  If an array is supplied with not every known key set, null will be used for unset keys.  User IDs cannot be updated.
	 *
	 * @param string $key   The key to update - supply a false value if all values are to be updated.
	 * @param mixed  $value The new data; if updating an individual key, the data should be a scalar value; if updating all keys, the data should be an array.
	 *
	 * @return boolean Whether the user was saved successfully
	 */
	public function setData($key, $value) {
		if ($key and $value !== null and !is_scalar($value)) throw new AssankaException("Non-scalar data provided for single key", 0, null, $value);
		if (!$key and ($value === null or is_scalar($value))) throw new AssankaException("Scalar data provided for full user", 0, null, $value);

		// Handle individual keys
		if ($key) {
			if ($key == 'id') return false;
			if ($key == self::$_passwordfield) $value = $this->_hashPassword($value);
			$queryref = self::$_dbwrite->query('UPDATE '.$this->_sqlFieldEnc(self::$_usertable).' SET '.$this->_sqlFieldEnc($key).'=%s WHERE '.$this->_sqlFieldEnc(self::$_userfield).'=%s', $value, $this->_data[self::$_userfield]);
			$success = $queryref->getErrorNo() ? false : true;
			if ($success) {
				$this->_data[$key] = $value;
				if ($this->_usesession) $_SESSION['AuthDatabase']['userdata'][$key] = $value;
			}
			return $success;
		}

		// An array of data has been supplied.  Pre-process the array; remove the id and hash the password if necessary
		if (isset($value['id'])) unset($value['id']);
		if (isset($value[self::$_passwordfield]) and $value[self::$_passwordfield] != $this->_data[self::$_passwordfield]) $value[self::$_passwordfield] = $this->_hashPassword($value[self::$_passwordfield]);

		// Build up the query string
		$querystringparts = array();
		$querydata = array();
		foreach ($value as $k => $v) {
			$querystringparts = $this->_sqlFieldEnc($k) . '=%s';
			$querydata[] = $v;
		}
		if (!$querystringparts) return false;

		// Add known keys if not set
		foreach ($this->_data as $k=>$v) {
			if ($k == 'id' or $k == self::$_passwordfield) continue;
			if (!isset($value[$k])) $querystringparts = $this->_sqlFieldEnc($k).'=NULL';
		}

		// Update the record
		$querydata[] = $this->_data[self::$_userfield];
		self::$_dbwrite->query('UPDATE ' . $this->_sqlFieldEnc(self::$_usertable) . ' SET ' . implode(', ', $querystringparts) . ' WHERE ' . $this->_sqlFieldEnc(self::$_userfield) . ' = %s', $querydata);
		$success = $queryref->getErrorNo() ? false : true;

		if ($success) {
			$newdata = $value;
			$newdata['id'] = $this->_data['id'];
			if (!isset($newdata[self::$_passwordfield])) $newdata[self::$_passwordfield] = $this->_data[self::$_passwordfield];
			$this->_data = $newdata;
			if ($this->_usesession) {
				$_SESSION['AuthDatabase']['userlogin'] = $newdata[self::$_userfield];
				$_SESSION['AuthDatabase']['userdata'] = $newdata;
			}
		}
		return $success;
	}

	/**
	 * wasReauthenticatedUsingSession
	 *
	 * Checks whether the user was logged in via the session cache - if enabled - or whether a full login was made.
	 *
	 * @return boolean Whether the user was generated from cache
	 */
	public function wasReauthenticatedUsingSession() {
		return $this->_usedsession;
	}


	/* Static methods */

	/**
	 * Sets database connector handles
	 *
	 * Sets up the  database handlers required for database use - a reference to a database connection object, and optionally another reference to database connection object to be used for writing.  If the second reference is not supplied, the first database handle supplied will be used for writing if necessary.
	 *
	 * @param FTLabs\MySqlConnection $databaseconnectorhandle      A database connection handle, with an active database selected
	 * @param FTLabs\MySqlConnection $writedatabaseconnectorhandle (Optional) A database connection handle suitable for writing, with an active database selected
	 *
	 * @return void
	 */
	public static function setDatabaseConnectors(FTLabs\MySqlConnection $databaseconnectorhandle, FTLabs\MySqlConnection $writedatabaseconnectorhandle = null) {
		self::$_dbread = $databaseconnectorhandle;
		self::$_dbwrite = ($writedatabaseconnectorhandle === null ? self::$_dbread : $writedatabaseconnectorhandle);
	}

	/**
	 * Set up table details for authentication use.
	 *
	 * @param string $usertablename      (Optional) The name of the user table in the active database
	 * @param string $userloginfield     (Optional) The name of the field used to lookup user logins
	 * @param string $passwordfield      (Optional) The name of the field where hashed passwords are stored.
	 * @param string $passwordresetfield (Optional) The name of a field which can be used to store password reset codes for forgotten passwords - if this is supplied the functionality will be enabled.  Should be able to store at least 12 characters.
	 *
	 * @return void
	 */
	public static function setUserTableDetails($usertablename = false, $userloginfield = false, $passwordfield = false, $passwordresetfield = false) {
		if ($usertablename) self::$_usertable = $usertablename;
		if ($userloginfield) self::$_userfield = $userloginfield;
		if ($passwordfield) self::$_passwordfield = $passwordfield;
		if ($passwordresetfield) self::$_passwordresetfield = $passwordresetfield;
	}

	/**
	 * setPasswordHashSalt
	 *
	 * Sets the md5 salt.  (Passwords are stored as md5(userid . salt . password)).
	 *
	 * @param string $salt The salt for hashing passwords
	 *
	 * @return void
	 */
	public static function setPasswordHashSalt($salt) {
		self::$_passwordsalt = $salt;
	}

	/**
	 * A getter for the user login field.
	 *
	 * @return mixed The name of the user login field, or false if it hasn't been set
	 */
	public static function getUserLoginFieldName() {
		return empty(self::$_userfield)?false:self::$_userfield;
	}

	/**
	 * A getter for the password field.
	 *
	 * @return mixed The name of the password field, or false if it hasn't been set
	 */
	public static function getPasswordFieldName() {
		return empty(self::$_passwordfield)?false:self::$_passwordfield;
	}

	/**
	 * A getter for the password reset field.
	 *
	 * @return mixed The name of the password reset field, or false if it hasn't been set
	 */
	public static function getPasswordResetFieldName() {
		return empty(self::$_passwordresetfield)?false:self::$_passwordresetfield;
	}

	private function _hashPassword($password) {
		return md5($this->_data['id'].self::$_passwordsalt.$password);
	}

	private function _sqlFieldEnc($field) {
		return '`'.str_replace('`', '``', $field).'`';
	}
}
