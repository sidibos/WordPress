<?php
/**
 * Represents a user known to Assanka Gatepass and provides methods for reading and writing to their Gatepass account
 *
 * Gatepass stores data in datasets, some of which are accessible to
 * applications.  The user's core Gatepass data and their 'basics' dataset
 * are always available, and are both read-only.  Your application
 * (identified by its Gatepass consumer key and secret) may also have
 * its own dataset in Gatepass to which it has read/write access.
 *
 * Common keys that you might want to retrieve from a GatepassUser include:
 *
 * basics/fullname
 * basics/givenname
 * basics/familyname
 * basics/nickname
 * basics/email
 * gatepass/userid  (Gatepass internal user ID)
 * gatepass/idents  (Comma-delimited list of GUIDs identifying this user)
 * gatepass/displayname  (prefer this over basics values for a user's caonical name)
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once $_SERVER['CORE_PATH'].'/helpers/authentication/v2/interfaces';
require_once $_SERVER['CORE_PATH'].'/helpers/gatepass/api';

class GatepassUser implements AssankaUserDataStoreInterface {

	/**
	 * Oauth configuration for this Gatepass application
	 */
	private static $gphost, $usessl, $consumerkey, $consumersecret;

	/**
	 * Resource handle for Gatepass API (instance of GatepassAPI class)
	 */
	private static $gpapi;

	/** 
	 * Storage for Gatepass data about the current user.
	 */
	private $userid, $data;

	/**
	 * How long to cache Gatepass data in Memcache
	 */
	const MEMCACHE_TTL = 1800;

	/**
	 * Create a GatepassUser
	 *
	 * The GatepassUser object is a handle providing access to the Gatepass account for a particular Gatepass user.  It must therefore be instantiated using the ID of the user whose account you wish to access and manipulate.  To find out the Gatepass ID of the currently logged in user, use an appropriate authentication interface class such as GatepassAuth.
	 *
	 * @param integer $userid The Gatepass user ID of the user
	 * @param integer $flags  Bitwise flags as described in AssankaUserDataStoreInterface
	 * @return GatepassUser
	 */
	public function __construct($userid, $flags=0) {
		if (!is_numeric($userid)) throw new AssankaException("Cannot create GatepassUser: invalid userid", 0, null, $userid);
		$this->userid = $userid;
		if (!($flags & (self::POPULATE_EMPTY | self::POPULATE_LIVE))) {
			$this->data = $this->loadFromCache();
		}
		if (!($flags & self::POPULATE_EMPTY) and (!$this->data or ($flags & self::POPULATE_LIVE))) {
			$this->getData();
		}
	}

	/**
	 * Retrieve some data from the user's Gatepass account
	 * 
	 * You may choose to retrieve a single value, an entire dataset or the user's entire GP profile (limited to those parts that are visible to your application).  If retrieving a dataset or the full profile, all allowable fields will be included in the response, with null values if necessary, so that you know what fields are settable.
	 *
	 * @param string $keypath Key of the Gatepass data point to retrieve, as either a dataset and fieldname separated by a forward slash, or just a dataset name to retrieve an entire dataset as a keyed array, or an empty string false or null to return all accessible datasets.
	 * @return mixed Either a single data value or an array of values
	 */
	public function getData($keypath='') {
		if (strpos($keypath, '/') !== false) {
			list($ns, $key) = explode('/', $keypath, 2);
			if (isset($this->data[$ns][$key])) return $this->data[$ns][$key];
			if ($data = self::gpapi()->getData($this->userid, $ns, $key)) {
				if (!isset($this->data[$ns])) $this->data[$ns] = array();
				$this->data[$ns][$key] = $data;
				$this->saveInCache($data, $ns, $key);
			}
		} elseif ($ns = $keypath) {
			if (isset($this->data[$ns])) return $this->data[$ns];
			if ($data = self::gpapi()->getData($this->userid, $ns)) {
				$this->data[$ns] = $data;
				$this->saveInCache($data, $ns);
			}
		} else {
			if (!empty($this->data)) return $this->data;
			if ($data = self::gpapi()->getData($this->userid)) {
				$this->data = $data;
				$this->saveInCache($data);
			}
		}
		return $data;
	}

	/**
	 * Write some data to the user's Gatepass account
	 * 
	 * You may choose to write a single value, a full dataset or the user's entire GP profile (limited to those parts that are writable by your application).  Data written will overwrite data already on the profile, including deleting fields that you have not set if you are writing an entire dataset or profile.  Where you are writing the whole profile, the keys in the top level of your $value array must be the names of valid datasets that your application has permission to write.  The values of each of these elements should be a further array, where the keys are valid fieldnames within that dataset.
	 *
	 * @param string $keypath Key of the Gatepass data point to write, as either a dataset and fieldname separated by a forward slash, or just a dataset name to write an entire dataset as a keyed array, or an empty string false or null to write all accessible datasets.
	 * @param mixed  $value   The value to write - either a scalar for writing a single data point, or a keyed array if writing a dataset or profile.
	 * @return void
	 */
	public function setData($keypath, $value) {
		if (strpos($keypath, '/') !== false) {
			list($ns, $key) = explode('/', $keypath, 2);
			$this->saveInCache($value, $ns, $key);
			self::gpapi()->setData($this->userid, $ns, $key, $value);
		} elseif ($ns = $keypath) {
			$this->saveInCache($value, $ns);
			foreach ($value as $key => $val) {
				self::gpapi()->setData($this->userid, $ns, $key, $val);
			}
		} else {
			$this->saveInCache($val);
			foreach ($value as $ns => $data) {
				foreach ($data as $key=>$val) {
					self::gpapi()->setData($this->userid, $ns, $key, $val);
				}
			}
		}
	}

	/**
	 * Load the user's GP data from Memcache
	 * 
	 * Where a user's GP data has been retrieved by another instance of this class (probably on a prior HTTP request) and lodged in Memcache, it can be retrieved directly from there to avoid a more expensive call to the Gatepass API.  This method retrieves the entire cached profile.
	 *
	 * @return array Gatepass profile data, organised by dataset.
	 */
	private function loadFromCache() {
		return self::getMemcache()->get('GatepassUser/'.$this->userid);
	}

	/**
	 * Save a user's profile data (or some element of it) in Memcache
	 * 
	 * Once data has been retrieved from Gatepass API, it may be saved in Memcache to avoid a similarly expensive lookup on a subsequent request.  This method allows for caching of an entire profile, a full dataset, or a single field-value.  Where the whole profile is stored, it will entirely replace the current contents of memcached for this user.  Where a dataset is passed, the existing cached profile will first be retrieved, then the specified values will entirely overwrite that part of the cached profile which comprises the specified dataset.  Where a key and dataset are given, the existing cached profile will first be retrieved, then the specified value will entirely overwrite the existing value for the specified key.  In either of these cases where a partial update is being made, the read and subsequent write to memcached are not performed as a single atomic operation.
	 *
	 * @param mixed  $val Value to write.  Either a single scalar value, a keyed array of scalar values, or a keyed array (keys mapping to datasets) containing further keyed arrays (fields within those datasets)
	 * @param string $ns  Dataset name, if applicable
	 * @param string $key Key (field) name, if applicable
	 * @return void
	 */
	private function saveInCache($val, $ns=false, $key=false) {
		$data = $this->loadFromCache();
		if ($key) {
			$data[$ns][$key] = $val;
		} elseif ($ns) {
			$data[$ns] = empty($data[$ns]) ? $val : array_merge($data[$ns], $val);
		} else {
			foreach ($val as $ns=>$fields) {
				$data[$ns] = empty($data[$ns]) ? $fields : array_merge($data[$ns], $fields);
			}
		}
		self::getMemcache()->set('GatepassUser/'.$this->userid, $data, self::MEMCACHE_TTL);
	}


	/* Static methods */

	/**
	 * Gets the active memcached pool
	 *
	 * @return Memcached
	 */
	public static function getMemcache() {
		static $memcache = false;
		if (!$memcache) {
			$memcache = new Memcached;
			$memcache->addServer('memcachea', 11211);
			$memcache->addServer('memcacheb', 11211);
			$memcache->setOption(Memcached::OPT_COMPRESSION, false);
		}
		return $memcache;
	}

	/**
	 * Set the Gatepass host
	 * 
	 * Normally gatepass.assanka.com, though this will vary if you wish to use a development or staging Gatepass server.  Need only be set once, and will apply to all instances of GatepassUser.  Should just be a hostname, but if a URL including a protocol scheme is given, the protocol will be stripped automatically.  For convenience if the protocol specified was https, useSSL will be called automatically.  Therefore these invocations are equivilent:
	 *
	 * GatepassUser::setHost('https://gatepass.assanka.com');
	 *
	 * GatepassUser::setHost('gatepass.assanka.com');
	 * GatepassUser::useSSL();
	 *
	 * @param string $hostname Hostname as described above
	 * @return void
	 */
	public static function setHost($hostname) {
		if (preg_match("/^http(s)?\:\/\/(.*)$/", $hostname, $m)) {
			$hostname = $m[2];
			if (!empty($m[1])) self::useSSL();
		}
		self::$gphost = $hostname;
	}

	/**
	 * Set your application's Gatepass consumer key
	 * 
	 * The OAuth consumer key and secret identifies your application to Gatepass, and provides access to datasets which are designated as available to your app.
	 *
	 * @param string $key    The Oauth consumer key
	 * @param string $secret The OAuth consumer secret
	 * @return void
	 */
	public static function setConsumerKey($key, $secret) {
		self::$consumerkey = $key;
		self::$consumersecret = $secret;
	}

	/**
	 * Sets whether Gatepass API requests should be sent over SSL
	 * 
	 * gatepass.assanka.com supports SSL.  Development and staging server versions of Gatepass usually do not.  Default is no SSL.
	 *
	 * @param boolean $newval (default true)
	 * @return void
	 */
	public static function useSSL($newval=true) {
		self::$usessl = ($newval == true);
	}

	/**
	 * Sets your application's OpenSSL private key for decoding encrypted data
	 * 
	 * Where your application hs access to datasets that store encrypted data such as passwords, these are encrypted and stored by Gatepass specifically for your application using your application's public key.  By setting the private key, encrypted data will be decrypted automatically on receipt, becfore it is returned by GetData.
	 *
	 * @param string $keystring An OpenSSL private key string.
	 * @return void
	 */
	public static function setPrivateKey($keystring) {
		self::gpapi()->setPrivateKey($keystring);
	}

	/**
	 * GatepassAPI resource handle
	 *
	 * Returns a reference to a GatepassAPI object, which may be used by any active instance of GatepassUser.
	 *
	 * @return GatepassAPI
	 */
	private static function gpapi() {
		if (!self::$gpapi) {
			if (empty(self::$gphost) or empty(self::$consumerkey) or empty(self::$consumersecret)) {
				throw new AssankaException('Cannot connect to Gatepass - required parameters not set', 0, null, get_defined_vars());
			}
			self::$gpapi = new GatepassAPI(self::$consumerkey, self::$consumersecret);
		}
		self::$gpapi->setHost(self::$gphost);
		self::$gpapi->useSSL(self::$usessl);
		self::$gpapi->setUserAgent('Assanka', 'GatepassUser', '1.0');
		return self::$gpapi;
	}
}
