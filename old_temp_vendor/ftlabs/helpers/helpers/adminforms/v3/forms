<?php
/**
 * Display an HTML form
 *
 * Displays an HTML form within an Assanka core framework interface.  Fields are added via the use of the field group classes, such as Simplefieldgroup and activetablefieldgroup.
 *
 * @codingstandard ftlabs-phpcs
 * @copyright The Financial Times Limited [All Rights Reserved]
 */

require_once $_SERVER['CORE_PATH']."/helpers/validator/v1/validator";

class inputform {

	public $formname;
	private $method, $href, $onsubmit, $accesskeys, $fields, $groups;

	/**
	 * Create an inputform
	 *
	 * @param string $name Name for the form.  Added to the HTML prefixed with 'frm' as the name and id of the FORM element.
	 * @return  void
	 */
	function __construct($name) {
		$this->formname = $name;
		$this->method = "POST";
		$this->onsubmit = false;
		$this->accesskeys = array();
		$this->fields = array();
		$this->groups = array();
		$this->href = ($pos = strpos($_SERVER["REQUEST_URI"], "?")) ? substr($_SERVER["REQUEST_URI"], 0, $pos) : $_SERVER["REQUEST_URI"];
	}

	/**
	 * Set the method on the FORM
	 *
	 * @param string $method GET or POST
	 * @return  void
	 */
	function setMethod($method) {
		if ($method == "GET" or $method == "POST") $this->method = $method;
	}

	/**
	 * Set the href of the FORM
	 *
	 * @param string $href HREF for the form
	 * @return  void
	 */
	function setHref($href) {
		$this->href = $href;
	}

	/**
	 * Set JavaScript code to run when the form is submitted
	 *
	 * @param string $js JavaScript code
	 * @return  void
	 */
	function setOnSubmit($js) {
		$this->onsubmit = $js;
	}

	/**
	 * Register the existence of a field on the form
	 *
	 * This method is used by field group classes to register their fields, to ensure there are no accesskey or name/id conflicts.  Should not be called outside of field group classes.
	 *
	 * @param string $name   Name of field
	 * @param array  $params Field definition parameters array
	 * @return  void
	 */
	function registerField($name, $params=array()) {
		if (!in_array($name, array_keys($this->fields))) {
			$this->fields[$name] = $params;
			$accesskeystr = strtolower(strip_tags(isset($params["label"]) ? $params["label"] : $name));
			$accesskey = false;
			for ($i = 0, $s = strlen($accesskeystr); $i < $s; $i++) {
				if (!in_array($accesskeystr[$i], $this->accesskeys) and ctype_alnum($accesskeystr[$i])) {
					$this->accesskeys[] = $accesskeystr[$i];
					return $accesskeystr[$i];
				}
			}
			return null;
		} else {
			trigger_error("Field name '".$name."' already in use in form '".$this->formname."'", E_USER_ERROR);
		}
	}

	/**
	 * Add a fieldgroup to the form
	 *
	 * When you create forms and fieldgroups, the form is passed to the fieldgroup externally, but the field group then registers itself with the form by calling this method.
	 *
	 * @param object &$grpref Reference to a field group class instance
	 * @return  void
	 */
	function addGroup(&$grpref) {
		$this->groups[] = $grpref;
	}

	/**
	 * Return the HTML of the form
	 *
	 * Return an XHTML representation of the form and helptext as separate elements in an associative array (the form output is in 'content' and the helptext elements in 'rightnav'). This can be passed directly to the add() method of a templatemanager if you wish to add the form output directly to an Assanka core framework page.
	 *
	 * @param bool $suppressvalidation Whether to suppress validation markup from the output. By default, validation markup is included if it is available (ususally triggered by a call to checkValidity() on a fieldgroup member of the inputform). Default false.
	 * @return  array  Array containing two elements: 'content' and 'rightnav'
	 */
	function getOutput($suppressvalidation=false) {
		$op = "<form name=\"frm".$this->formname."\" id=\"frm".$this->formname."\" autocomplete=\"off\" enctype=\"multipart/form-data\"";
		if ($this->onsubmit) $op .= " onsubmit=\"".$this->onsubmit."\"";
		if ($this->href) $op .= " method=\"".$this->method."\" action=\"".$this->href."\"";
		$op .= ">";

		// Include a sacrificial field for IE to sometimes mangle (search for
		// ISO-8859-1 on http://tinyurl.com/g3ffj )
		if ($this->method == "POST") $op .= "<input type=\"hidden\" name=\"AntiInternetExplorerHttpPostError\" value=\"ignore\" />";

		for ($i = 0, $s = count($this->groups); $i < $s; $i++) {
			$op .= $this->groups[$i]->output($this, $suppressvalidation);
		}

		$op .= "</form>";
		$ret = array("content"=>$op);

		$op = "";
		foreach ($this->fields as $name=>$params) {
			if (isset($params["helptext"])) $op .= "<div id=\"help".$name."\" class=\"help\">".$params["helptext"]."</div>";
		}
		if ($op) {
			$op = "<h3 id=\"helpheader\">Help</h3>".$op;
			$op .= "<div id=\"nohelpavail\" class=\"help\"><em>There is no help available for this item</em></div>";
			$op .= "<div id=\"nohelp\" class=\"help\" style=\"display: block\"><em>Choose a form field to view context-sensitive help</em></div>";
			$ret["rightnav"] = $op;
		}

		return $ret;
	}
}

/**
 * A set of vertically arranged fields for an Inputform
 *
 * Creates a set of form fields designed to accept name-value data, and adds them to an instance of an Inputform.
 *
 * @author Andrew Betts
 * @copyright Assanka Limited [All Rights Reserved]
 */
class Simplefieldgroup {

	protected $fields, $title, $allvalid, $defaultdefs = false;

	/**
	 * Creates a simplefieldgroup
	 *
	 * @param Inputform &$frmobj A reference to the form to which you wish to add this field group
	 * @return  Simplefieldgroup
	 */
	function __construct(&$frmobj) {
		$frmobj->addGroup($this);
		$this->fields = array();
		$this->allvalid = true;
	}

	/**
	 * Sets the title of the field group
	 *
	 * If set, will display an H4 title bar on the field group.  Separates the field group from other content units on the page. May be set to false to omit the title (default if method is not called). If the field group is the first content unit on the page, it is customary to avoid having a title (although a page title can be inserted as an H2)
	 *
	 * @param string $title The title to display on the field group
	 * @return  void
	 */
	function setTitle($title) {
		$this->title = $title;
	}

	/**
	 * Set default definition data for fields
	 *
	 * Loads a set of definition data into the class, allowing fields to be added to the form without specifying individual definitions for each one.  Sets the default options for addField and addFields calls. Useful to pass a model of your data structure into the simplefieldgroup in one go.
	 *
	 * @param array &$defdata Associative array of field names to arrays containing definition data
	 * @return  void
	 */
	function useDefinitions(&$defdata) {
		if (!is_array($defdata)) trigger_error("Default definition data must be an array", E_USER_ERROR);
		$this->defaultdefs = $defdata;
	}

	/**
	 * Adds a field to the field group
	 *
	 * All types of HTML form fields except radio buttons are supported.  The second argument to this method is an assocaitive aray that defines all the properties of the field, which may include any or all of the following:
	 * <dl>
	 * <dt>label</dt><dd>String, label to apply to field. If omitted, will use field name capitalised.</dd>
	 * <dt>prompt</dt><dd>String, alias of label (but has higher priority than label, so if prompt is present, will override label). </dd>
	 * <dt>type</dt><dd>String, input control for the data type. One of (aliases shown in brackets): text, textarea, check (boolean), integer, float, date, datetime, datetimeseconds, time, timeseconds, hidden, dummy, autocomplete, select (enum), colorpick, password, richtext, imageupload, upload, spacer, percent </dd>
	 * <dt>convertemptytonull</dt><dd>Boolean, whether to convert empty string responses into nulls when returning data from getSubmittedData()</dd>
	 * <dt>length</dt><dd>Integer, maximum length of input. </dd>
	 * <dt>options</dt><dd>If set, provides a set of possible values for the field, where each array element's key is the value to be stored, and the element's value is the text to display to the user when selecting it. Eg. array("new"=>"New request", "existing"=>"Existing request"). An options array may be provided, if desired, for a field that renders as checkboxes or a select box. In the case of a select box, the value returned from getSubmittedData will be the key of the selected option, and the select box will offer no options if no options array is provided. In the case of checkboxes, providing an options array will result in one checkbox being rendered per option, and the return value from getSubmittedData() will be an array of keys corresponding to checked options. Not providing an options array for a checkbox field will result in a single checkbox being rendered, and the return value from getSubmittedData will be 1 or 0. </dd>
	 * <dt>helptext</dt><dd>String, text to display in context-sensitive help area when the field appears in a form and the field is focussed. </dd>
	 * <dt>validation</dt><dd>String, how to validate a candidate value for the field. If the field's type is defined as select, validation will ignore this value and instead check that the value under test is a member of the list of options available. If the type is upload or imageupload, validation will ensure the presence of the submitted file. Otherwise, if one of the keywords shown here is specified, a predefined regular expression will be applied. Finally if the specified string doesn't match a predefined pattern name, it will be used as a regular expression itself. Predefined regular expressions are: postcode, email, url, phone, word. </dd>
	 * <dt>validationmsg</dt><dd>String, text to display if field fails to pass test specified in validation </dd>
	 * <dt>required</dt><dd>Boolean, whether a value should be required in the field. This has no effect on the validation of the value. It is possible to have both an optional field that fails validation because it contains an invalid submitted value, and a required field that is never validated because it is empty, and therefore fails with a standard 'field must be completed' message rather than the contents of validationmsg. </dd>
	 * <dt>existingfile</dt><dd>String. If a required file upload or image upload field is submitted and would fail validation (because the submitted filename does not exist in the uploaddest folder), but the submitted value matches existingfile, it will be allow the form to pass validation (but the value of this particular field will be stripped from the output of getSubmittedData) </dd>
	 * <dt>uploaddest</dt><dd>String. Filesystem path relative to document root where the uploaded file should be stored. </dd>
	 * <dt>maxfilesize</dt><dd>String. Maximum size of file to accept in an upload field. Only applies to fields of type 'upload' and 'imageupload'. Specified in kilobytes, or using a unit suffix. Valid units are B, KB, MB, and GB. The uploader has a practical limit of 100MB. </dd>
	 * <dt>imagecapture</dt><dd>Boolean. Only applies to fields of type 'upload' and 'imageupload'. Whether to add a Java applet to the uploader allowing the user to capture an upload an image directly from their clipboard without having to save it to disk.  Defaults to true for imageupload, false for upload. </dd>
	 * <dt>autocompleteurl</dt><dd>String. URI of an autocomplete handler script that will return a list of possible completions when queried with a qparameter on the query string. </dd>
	 * <dt>richtextcss</dt><dd>String. URI of an a CSS file that should be applied to a rich text editor. </dd>
	 * <dt>richtextstyles</dt><dd>String. URI of an a FCK styles XML file that should be applied to a rich text editor. </dd>
	 * </dl>
	 *
	 * @param string $name       Name of field. Added to DOM as both an ID and name attribute of the INPUT element, but differently in each case. The name attribute of the INPUT is set to  {name} exactly, since it will be transmitted to the server as part of the submission, identifying the data in the field. The ID attribute is set to  frm{formname}_{name}, since  {name} may not be unique across the whole page.
	 * @param array  $definition Associative array of options that may be used to refine the display of the column.
	 * @return  void
	 */
	function addField($name, $definition=array()) {
		if (array_key_exists($name, $this->fields)) {
			trigger_error("Field '".$name."' already exists, ignoring this field.", E_USER_NOTICE);
			return false;
		}
		if (!is_array($definition)) trigger_error("Field definition must be an array", E_USER_ERROR);
		if (empty($definition) and !empty($this->defaultdefs[$name])) $definition = $this->defaultdefs[$name];
		if (!empty($definition["datatype"])) $definition["type"] = $definition["datatype"];
		if (!empty($definition["inputtype"])) $definition["type"] = $definition["inputtype"];
		$this->fields[$name] = $definition;
	}

	/**
	 * Adds lots of fields to the field group
	 *
	 * Add multiple fields to the form, with no definition parameters (default definitions will be used if they are available, see useDefinitions).  Pass as many arguments as you there are fields you wish to add.
	 *
	 * @return  void
	 */
	function addFields() {
		$arglist = func_get_args();
		foreach ($arglist as $arg) $this->addField($arg);
	}

	/**
	 * Populates form fields with data from a associative array.
	 *
	 * Used to display values in fields on page load (from a database record, for example), and to populate data that has been received in a form submission, to enable the class to validate it.  Elements with more than one possible value (ie those represented as checkboxes) should be sub-arrays containing a list of the selected options. Simplefieldgroup will process the data for some data types before it is added to the form fields, as follows:
	 * * Richtext input type fields: data will be encoded for serialisation into the javascript rich text editor source.
     * * date datatype: data will be interpreted as a date and formatted as 4 January 2008.
     * * datetime datatype: data will be interpreted as a date and formatted as 4 January 2008 13:53.
     * * time datatype: data will be interpreted as a time and formatted as 13:58.
     * * datetimeseconds datatype: data will be interpreted as a date and formatted as 4 January 2008 13:58:04.
     * * timeseconds datatype: data will be interpreted as a time and formatted as 13:58:04.
     * * All types except rich text and dummy: HTML special characters will be encoded to entities.
	 *
	 * @param array $data Associative array of data
	 * @return  void
	 */
	function addData($data) {
		foreach ($data as $field=>$val) {
			foreach ($this->fields as $name=>$params) {
				if ($field == $name) {

					// Special cases to encode data correctly for display
					if (isset($params["type"])) {
						switch($params["type"]) {
							case "date":
								$dateval = Common::convertHumanTime($val);
								$val = ($dateval) ? $dateval->format("j M Y", $dateval) : $val;
								break;
							case "datetime":
								$dateval = Common::convertHumanTime($val);
								$val = ($dateval) ? $dateval->format("j M Y H:i", $dateval) : $val;
								break;
							case "datetimeseconds":
								$dateval = Common::convertHumanTime($val);
								$val = ($dateval) ? $dateval->format("j M Y H:i:s", $dateval) : $val;
								break;
							case "percent":
								$val = ($val * 100)."%";
								break;
							case "upload":
							case "imageupload":
								$val = basename($val);
								break;
							case "time":
							case "timeseconds":
							case "richtext":
							case "text":
							case "textarea":
							case "integer":
							case "float":
							case "date":
							case "daterange":
							case "hidden":
							case "dummy":
							case "autocomplete":
							case "colorpick":
							case "password":
							case "select":
							case "enum":
							case "spacer":

								// No filtering
						}
					}

					$this->fields[$name]["value"] = $val;
					break;
				}
			}
		}
	}

	/**
	 * Marks a field as invalid for validation purposes
	 *
	 * In built validation is often insufficient, such as when you wish to validate dependencies between fields (eg 'if you enter a start date, you must also enter an end date').  In such cases you can instruct the simplefieldgroup to set the field to be invalid.
	 *
	 * @param string  $name        Name of field to mark invalid
	 * @param string  $explanation Reason message to display to the user
	 * @param integer $i           If there is more than one field on the form with the same name, this argument allows you to specify which one should be marked invalid.  If not specified, will choose the first field with the specified name.
	 * @return  void
	 */
	function setInputInvalid($name, $explanation, $i = 0) {
		$this->fields[$name]["validationmsg"] = $explanation;
		$this->fields[$name]["isvalid"] = 0;
		$this->fields[$name]['invalids'][$i] = 1;
	}

	/**
	 * Checks that all submitted data passes validity criteria
	 *
	 * Tests any form fields that have no validation result attached, and attaches a validation result to them. Returns the overall validation status of the field group. Note: if checkValidity has already been run, running it a second time will simply return the same result as the first time (even if you have called addData to change the data values), unless it previously returned true and setInputInvalid has been called since.
	 *
	 * Once you have called checkvalidity, if you subsequently call output, the rendered output will contain error markup.
	 *
	 * @return  bool   Whether all fields in the field group pass validation.
	 */
	function checkValidity() {
		$this->allvalid = 1;
		$ignoreTypes = array('hidden', 'dummy', 'spacer');
		foreach ($this->fields as $name=>$field) {
			if (empty($field["type"]) or !in_array($field['type'], $ignoreTypes)) {
				if (isset($field["isvalid"]) and !$field["isvalid"]) {
					$this->allvalid = 0;
				} else {
					if (!isset($field['value'])) {
						$field['value'] = '';
					}
					$values = (!empty($field['multiple']) and is_array($field['value'])) ? $field['value'] : array($field['value']);
					foreach ($values as $k => $value) {
						if ($value === '' or $value === false or $value === null) {
							if (!empty($field["required"]) and empty($field['isvalid'])) {
								$this->fields[$name]["validationmsg"] = "You must enter a value for this field";
								$this->fields[$name]["isvalid"] = 0;
								$this->fields[$name]["invalids"][$k] = 1;
								$this->allvalid = 0;
								continue 2;
							}
							continue;
						}
						$invalidmsg = Validator::checkField($value, $field);
						if ($invalidmsg) {
							$this->fields[$name]["isvalid"] = 0;
							$this->fields[$name]["invalids"][$k] = 1;
							$this->fields[$name]["validationmsg"] = (!empty($field["validationmsg"])) ? $field["validationmsg"] : $invalidmsg;
							$this->allvalid = 0;
						}
					}
				}
			}
		}
		return $this->allvalid;
	}

	/**
	 * Returns normalised data submitted into the fieldgroup
	 *
	 * Retrieves the values submitted into the form as an associative array, and applies some standard filtering. When examining the response from a form POST, you should use addData to add the POST data to the form, and then this method to retrieve the data. This will ensure that the resulting array contains only data that corresponds to this field group, and it also provides some normalisation of the data, detailed below.
	 * * If the field is rendered as a checkbox and has no options array, the value is a boolean
     * * If the field is rendered as checklist, the value is an array listing all the selected keys
     * * If the field is rendered as a select list, the value is the key of the chosen option
     * * If the field contains a date or time data type, the value is returned as a unix timestamp or duration in seconds
     * * If the field is a file uploader, the value is a full filesystem path to the uploaded file
     * * Otherwise, the value is as submitted by the user
	 *
	 * @return array Associative array of data from all the fields in the field group
	 */
	function getSubmittedData() {
		$ret = array();
		foreach ($this->fields as $key=>$field) {
			$ret[$key] = Validator::normalise((isset($_REQUEST[$key])?$_REQUEST[$key]:null), $field);
		}
		return $ret;
	}

	/**
	 * Return an HTML representation of the field group
	 *
	 * This method is called by the Inputform when constructing the entire form.  It does not need to be called by your application.
	 *
	 * @param Inputform &$frmobj            Reference to the caller Inputform object
	 * @param boolean   $suppressvalidation Whether to prevent error messages from being included in the output.  By default errors are displayed if the field group has been checked for validity {@see checkValidity}
	 * @return string The HTML output
	 */
	function output(&$frmobj, $suppressvalidation=false) {
		$table = $hidden = "";
		foreach ($this->fields as $name=>$field) {
			$field["accesskey"] = $frmobj->registerField($name, $field);
			if (empty($field["type"])) $field["type"] = "text";
			$field["prompt"] = (isset($field["prompt"])) ? $field["prompt"] : ((isset($field["label"])) ? $field["label"] : $name);
			if (isset($field["accesskey"])) {
				$field['prompt_plain'] = $field['prompt'];
				$field["prompt"] = preg_replace("/(".$field["accesskey"].")(?=[^>]*(?:<|$))/i", "<u>$1</u>", $field["prompt"], 1);
			}
			$accesskeyattr = ($field["accesskey"]) ? ' accesskey="'.$field["accesskey"].'"' : '';
			$maxlengthattr = (isset($field["length"])) ? ' maxlength="'.$field["length"].'"' : '';
			$validationtags = (isset($field["isvalid"]) and !$field["isvalid"] and !$suppressvalidation) ? " class=\"invalid\" title=\"".htmlspecialchars($field["validationmsg"], ENT_QUOTES)."\"":"";
			$domid = "frm".$frmobj->formname."_".$name;
			$reqclass = (isset($field["required"]) and $field["required"]) ? "reqfield" : "optfield";
			if (!isset($field["value"])) $field["value"] = (isset($field["default"])) ? $field["default"] : "";
			$trClasses = array();
			if (!empty($field['multiple'])) {
				$trClasses[] = 'field-multiple';
			}
			if (!empty($field['hidden'])) {
				$trClasses[] = 'field-hidden';
			}
			$trClasses = $trClasses ? ' class="' . join(' ', $trClasses) . '" ' : '';
			switch($field["type"]) {

				// COMPLEX:AB:20091126: Notice that dummy fields also implement hidden - the lack of a break statement is intentional
				case "dummy":
					$table .= '<tr><td class="formlabel" nowrap>';
					$table .= strlen($field['prompt']) ? $field["prompt"].':' : '';
					$table .= '</td><td class="forminput" style="padding-top: 5px">';
					$table .= $field["value"];
					$table .= '</td></tr>';
				case "hidden":
					if (is_array($field["value"])) {
						for ($i = (count($field["value"]) - 1); $i >= 0; $i--) {
							$hidden .= '<input type="hidden" name="'.$name.'[]" id="'.$domid.'_'.$i.'" value="'.htmlspecialchars($field["value"][$i], ENT_QUOTES, "UTF-8").'" />';
						}
					} else {
						$hidden .= '<input type="hidden" name="'.$name.'" id="'.$domid.'" value="'.htmlspecialchars($field["value"], ENT_QUOTES, "UTF-8").'" />';
					}
					break;
				case "text":
				case "float":
				case "integer":
				case "percent":
				case "date":
				case "daterange":
				case "datetime":
				case "datetimeseconds":
				case "time":
				case "timeseconds":
				case "autocomplete":
					$values = (!empty($field['value']) and is_array($field['value'])) ? $field['value'] : array($field['value']);
					$prompt = $field['prompt'];
					$promptPlain = isset($field['accesskey']) ? $field['prompt_plain'] : $prompt;
					foreach ($values as $k => $value) {
						$table .= '<tr' . $trClasses . '><td class="formlabel '.$reqclass.'" nowrap>';
						if (!empty($field['described'])) {
							$desc = empty($field['descriptions'][$k]) ? $promptPlain : htmlspecialchars($field['descriptions'][$k], ENT_QUOTES);
							$table .= '<input type="text" class="field-description" name="_desc[' . $name . '][]" value="' . $desc . '" /></span>';
							$prompt = $desc;
						}
						$table .= '<label'.(empty($field['invalids'][$k]) ? '' : $validationtags).' for="'.$domid.'">'.$prompt.'</label></td>';
						$table .= '<td class="forminput">';
						$table .= '<input type="text" name="'.$name.(empty($field['multiple'])?'':'[]').'" id="'.$domid.'"'.$accesskeyattr.$maxlengthattr.' value="'.htmlspecialchars($value, ENT_QUOTES, "UTF-8").'" />';
						if ($field["type"] == "autocomplete") {
							$table .= '<script type="text/javascript">$(document).ready(function(){ acp.'.$domid.' = $("#'.$domid.'").autocomplete("'.$field["autocompleteurl"].'", {autoFill:true, cacheLength:10, maxItemsToShow:10, matchSubset:false, smartSelectFirst:true});})</script>';
						}
						if (!empty($field['suffix'])) {
							$table .= $field['suffix'];
						}
						$table .= '</td></tr>';
					}
					break;
				case "password":
					$table .= '<tr><td class="formlabel '.$reqclass.'" nowrap>';
					$table .= '<label'.$validationtags.' for="'.$domid.'">'.$field["prompt"].'</label></td>';
					$table .= '<td class="forminput">';
					$table .= '<input type="password" autocomplete="off" name="'.$name.'" id="'.$domid.'"'.$accesskeyattr.$maxlengthattr.' value="'.htmlspecialchars($field["value"], ENT_QUOTES, "UTF-8").'" />';
					$table .= '</td></tr>';
					break;
				case "textarea":
					$values = (!empty($field['value']) and is_array($field['value'])) ? $field['value'] : array($field['value']);
					foreach ($values as $k => $value) {
						$table .= '<tr' . $trClasses . '><td class="formlabel '.$reqclass.'" nowrap>';
						$table .= '<label'.(empty($field['invalids'][$k]) ? '' : $validationtags).' for="'.$domid.'">'.$field["prompt"].'</label></td>';
						$table .= '<td class="forminput">';
						$table .= '<textarea name="'.$name.(empty($field['multiple'])?'':'[]').'" id="'.$domid.'"'.$accesskeyattr.$maxlengthattr.'>'. htmlspecialchars($value, ENT_QUOTES, "UTF-8").'</textarea>';
						$table .= '</td></tr>';
					}
					break;
				case "richtext":
					if (empty($field["richtexttoolset"])) $field["richtexttoolset"] = "Accessibility";
					$table .= '<tr><td class="formlabel '.$reqclass.'" nowrap>';
					$table .= '<label'.$validationtags.' for="'.$domid.'">'.$field["prompt"].'</label></td>';
					$table .= '<td class="forminput">';
					$table .= '<script type="text/javascript">';
					$table .= 'var oFCKeditor = new FCKeditor("'.$name.'");';
					$table .= 'oFCKeditor.BasePath = "/corestatic/fckeditor/v2.5.1/";';
					$table .= 'oFCKeditor.Width	= "100%";';
					$table .= 'oFCKeditor.Height = 300;';
					$table .= 'oFCKeditor.ToolbarSet = "'.$field["richtexttoolset"].'";';
					$table .= 'oFCKeditor.Value = \''.str_replace(array("'", "\\","\n","\r"), array("&#039;", "\\\\","\\n","\\r"), $field["value"]).'\';';
					if (!empty($field["richtextcss"])) $table .= 'oFCKeditor.Config.EditorAreaCSS = "'.$field["richtextcss"].'";';
					if (!empty($field["richtextstyles"])) $table .= 'oFCKeditor.Config.StylesXmlPath = "'.$field["richtextstyles"].'";';
					$table .= 'oFCKeditor.Create();';
					$table .= '</script>';
					$table .= '</td></tr>';
					break;
				case "enum":
				case "select":
					$table .= '<tr><td class="formlabel '.$reqclass.'" nowrap>';
					$table .= '<label'.$validationtags.' for="'.$domid.'">'.$field["prompt"].'</label></td>';
					$table .= '<td class="forminput">';
					$table .= '<select name="'.$name.'" id="'.$domid.'"'.$accesskeyattr.'>';
					$table .= '<option value=""></option>';
					if (!isset($field["options"]) or !is_array($field["options"])) $field["options"] = array();
					foreach ($field["options"] as $key=>$option) {
						$table .= '<option value="'.htmlspecialchars($key, ENT_QUOTES, "UTF-8").'"' . (($field["value"] == $key)?' selected="selected"':'') . '>'.htmlspecialchars($option, ENT_QUOTES, "UTF-8").'</option>';
					}
					$table .= '</select></td></tr>';
					break;
				case "check":
				case "boolean":
					$table .= '<tr><td class="formlabel" nowrap>';
					$table .= '&nbsp;';
					$table .= '</td>';
					$table .= '<td>';
					$table .= '<input type="checkbox" style="width: 20px; margin: 2px 0 1px 0" name="'.$name.'" id="'.$domid.'_'.(++$i).'" value="'.htmlspecialchars($key, ENT_QUOTES, "UTF-8").'"';
					if (isset($field["value"]) and $field["value"]) $table .= ' checked="checked"';
					$table .= '><label for="'.$domid.'"'.$validationtags.'>'.rtrim($field["prompt"], ":").'</label><br />';
					$table .= '</td></tr>';
					break;
				case "checklist":
					if (!isset($field["value"]) or !is_array($field["value"])) {
						$field["value"] = array();
					}
					$table .= '<tr><td class="formlabel '.$reqclass.'" nowrap>';
					$table .= $field["prompt"];
					$table .= '</td>';
					$table .= '<td>';
					$i = 0;
					foreach ($field["options"] as $key=>$prompt) {
						$table .= '<input type="checkbox" style="width: 20px; margin: 2px 0 1px 0" name="'.$name.'[]" id="'.$domid.'_'.(++$i).'" value="'.htmlspecialchars($key, ENT_QUOTES, "UTF-8").'"';
						if (in_array($key, $field["value"])) $table .= ' checked="checked"';
						$table .= '><label for="'.$domid.'_'.$i.'"'.$validationtags.'>'.rtrim($prompt, ":").'</label><br />';
					}
					$table .= '</td></tr>';
					break;
				case "imageupload":
				case "upload":
					$table .= '<tr><td class="formlabel '.$reqclass.'" nowrap>';
					$table .= '<span'.$validationtags.'>'.$field["prompt"].'</span></td>';
					$table .= '<td>';
					$table .= '<input class="fupload" type="hidden" id="'.$domid.'" name="'.$name.'" value="'.htmlspecialchars($field["value"], ENT_QUOTES, "UTF-8").'"';
					if (isset($field["uploaddest"])) $table .= ' uploaddest="'.$field["uploaddest"].'"';
					if (isset($field["maxfilesize"])) $table .= ' maxfilesize="'.$field["maxfilesize"].'"';
					$table .= ' imagecapture="';
					if (isset($field['imagecapture'])) {
						$table .= ($field['imagecapture']) ? "1" : "0";
					} else {
						$table .= "0";
					}
					$table .= '"';
					$table .= (isset($field["required"]) and $field["required"]) ? ' req="true"' : 'req="false"';
					$table .= ' />';
					$table .= '</td></tr>';
					break;
				case "spacer":
					$table .= '<tr><td>&nbsp;</td><td>&nbsp;</td></tr>';
					break;
				default:
					trigger_error("Not including field: '".$name."' in SimpleFieldGroup as type: '".$field["type"]."' is not supported", E_USER_NOTICE);
					break;
			}
		}
		if ($table) $table = "<div class='form'><table width='100%'>".$table."</table></div>";
		$op = $hidden.$table;
		if ($this->title) $op = "<h4>".$this->title."</h4>".$op;
		return $op;
	}
}

/**
 * Attaches a form to a DataTable, allowing the user to quickly add rows of data, and submits as part of an Inputform
 *
 * Requires an existing DataTable.  Submits all its data in a single form field.  Creates a set of form fields associated with a Datatable object and uses a client-side javascript library to populate the table with multiple records. When the form is submitted, the entire contents of the table is made available to the handling script.
 *
 * @author Andrew Betts
 * @copyright Assanka Limited [All Rights Reserved]
 */
class activetablefieldgroup {
	private $title, $fields, $datakeys, $ajaxurl, $groupname, $tblobj, $data;

	/**
	 * Creates an activetablefieldgroup
	 *
	 * @param Inputform &$frmobj   A reference to the form to which you wish to add this field group
	 * @param DataTable &$tblobj   A reference to a DataTable to which to bind this activetablefieldgroup
	 * @param string    $groupname Unique reference for this field group within the form
	 * @return Simplefieldgroup
	 */
	function __construct(&$frmobj, &$tblobj, $groupname) {
		$frmobj->addGroup($this);
		$this->tblobj = $tblobj;
		$this->groupname = preg_replace("/[^a-z0-9\-]/i", "_", $groupname);
		$this->fields = array();
		$this->datakeys = array();
		$this->data = array();
		$this->ajaxurl = false;
		$this->tblobj->useKeys();
	}

	/**
	 * Sets the title of the field group
	 *
	 * If set, will display an H4 title bar on the field group.  Separates the field group from other content units on the page. May be set to false to omit the title (default if method is not called). If the field group is the first content unit on the page, it is customary to avoid having a title (although a page title can be inserted as an H2)
	 *
	 * @param string $title The title to display on the field group
	 * @return  void
	 */
	function setTitle($title) {
		$this->title = $title;
	}

	/**
	 * Adds a field to the field group
	 *
	 * The second argument to this method is an assocaitive aray that defines all the properties of the field, which may include any or all of the following:
	 * <dl>
	 * <dt>label</dt><dd>String, label to apply to field. If omitted, will use field name capitalised.</dd>
	 * <dt>prompt</dt><dd>String, alias of label (but has higher priority than label, so if prompt is present, will override label). </dd>
	 * <dt>type</dt><dd>String, input control for the data type. One of (aliases shown in brackets): text, textarea, check (boolean), integer, float, date, datetime, datetimeseconds, time, timeseconds, hidden, autocomplete, select (enum), colorpick, password, imageupload, upload, percent </dd>
	 * <dt>length</dt><dd>Integer, maximum length of input. </dd>
	 * <dt>options</dt><dd>If set, provides a set of possible values for the field, where each array element's key is the value to be stored, and the element's value is the text to display to the user when selecting it. Eg. array("new"=>"New request", "existing"=>"Existing request")</dd>
	 * <dt>helptext</dt><dd>String, text to display in context-sensitive help area when the field appears in a form and the field is focussed. </dd>
	 * <dt>required</dt><dd>Boolean, whether a value should be required in the field.</dd>
	 * <dt>existingfile</dt><dd>String. If a required file upload or image upload field is submitted and would fail validation (because the submitted filename does not exist in the uploaddest folder), but the submitted value matches existingfile, it will be allow the form to pass validation (but the value of this particular field will be stripped from the output of getSubmittedData) </dd>
	 * <dt>uploaddest</dt><dd>String. Filesystem path relative to document root where the uploaded file should be stored. </dd>
	 * <dt>maxfilesize</dt><dd>String. Maximum size of file to accept in an upload field. Only applies to fields of type 'upload' and 'imageupload'. Specified in kilobytes, or using a unit suffix. Valid units are B, KB, MB, and GB. The uploader has a practical limit of 100MB. </dd>
	 * <dt>autocompleteurl</dt><dd>String. URI of an autocomplete handler script that will return a list of possible completions when queried with a q parameter on the query string. </dd>
	 * </dl>
	 *
	 * @param string $name       Added to DOM as both an ID and name attribute of the INPUT element, but differently in each case. The name attribute of the INPUT is set to  {name}  exactly, since it will be transmitted to the server as part of the AJAX submission, identifying the data in the field. The ID attribute is set to  frm{formname}_{groupname}_{name}, since  {name} may not be unique across the whole page.
	 * @param array  $definition Associative array of options that may be used to refine the display of the column.
	 * @return  void
	 */
	function addField($name, $definition=array("type"=>"text")) {
		if (array_key_exists($name, $this->fields)) {
			trigger_error("Field '".$name."' already exists, ignoring this field.", E_USER_NOTICE);
			return false;
		}
		if (!is_array($definition)) trigger_error("Field definition must be an array", E_USER_ERROR);
		$this->fields[$name] = $definition;
	}

	/**
	 * Sets a handler URL for an AJAX handler script
	 *
	 * Sets the URL to which the activetable should POST new row submissions, and retrieve the resulting row HTML for insertion into the table. If not set, will assume the current URL should be used.
	 *
	 * @param string $url URL to which to post AJAX requests
	 * @return  void
	 */
	function setAjaxHandler($url) {
		$this->ajaxurl = $url;
	}

	/**
	 * Sets the keys that should be used to label the data returned from a submission of an Activetablefieldgroup. If not specified, will use the field names from the associated Datatable, or sequential index numbers if there are not enough field names.
	 *
	 * @param array $datakeys List of key names
	 * @return  void
	 */
	function setDataKeys($datakeys) {
		if (is_array($datakeys)) $this->datakeys = $datakeys;
	}

	/**
	 * Returns true if the current request is an AJAX request from this field group.
	 *
	 * If using the same script to do AJAX and process the form submission, this method can be used to distinguish between the two. Typically this should be used with getAjaxSubmission and generation of new data for the table.
	 * Example:
	 * <code>
	 * if ($grp->isAjax()) {
	 *   $data = $grp->getAjaxSubmission();
	 *
	 *   $tb->addRow(array("id"=>42, "client"=>"Andrew", "title"=>$data["title"],
	 *   "basecurrency"=>$data["basecurrency"], "dateopened"=>"Today"), 42);
	 *   exit("{result:'OK',row:'".rawurlencode($tb->generateRowHTML())."',key:42,
	 *   data:'1,2,3'}");
	 * }
	 * </code>
	 *
	 * @return boolean
	 */
	function isAjax() {
		return (isset($_REQUEST["ajxgrp"]) and $_REQUEST["ajxgrp"] == $this->groupname) ? 1 : 0;
	}

	/**
	 * Associate data with existing rows in the datatable.
	 *
	 * This does not populate the table with visible rows. It provides data to submit back to the server if the rows preloaded into the datatable with Datatable::addRow() or Datatable::addData() are still there when the form is submitted.
	 *
	 * @param array  $data        Associative array of data to associate with the table rows. Each key should match the row key of a row added to the associated datatable, and the value of each element can be either a string of comma-separated data, or an array of values.
	 * @param string $overridekey If set, rather than using the keys from the $data array as keys, instead use the values of the elment with this key within each row array.  Much the same as DataTable::addData.
	 * @return  void
	 */
	function addData($data, $overridekey=false) {
		foreach ($data as $key=>$data) $this->addRow($data, ($overridekey)?$data[$overridekey]:$key);
	}

	/**
	 * Associate data with an existing row in the datatable.
	 *
	 * This does not populate the table with visible rows. It provides data to submit back to the server if the rows preloaded into the datatable with Datatable::addRow() or Datatable::addData() are still there when the form is submitted.
	 *
	 * @param array  $data Data to associate with the row
	 * @param string $key  Row key of the row to associate with the data
	 * @return  void
	 */
	function addRow($data, $key) {
		$this->data[$key] = $data;
	}

	/**
	 * Fetch the data associated with all the rows in the DataTable when the Inputform was submitted
	 *
	 * Note that the data values returned from getSubmittedData are not necessarily the same as the data displayed in the table. When new rows are added by the user, an AJAX request is made with the entered values. The AJAX response contains both a new row to insert into the table, AND a string of data representing the row which should be submitted when the form is submitted. These are likely to be rawer values than the formatted-for-display content for the table. If you call setDataKeys() you can also change the keys, so that what is submitted is entirely different from what is displayed in the table.
	 *
	 * @return array Associative array of data from the table
	 */
	function getSubmittedData() {
		$ret = array();
		if (empty($_POST[$this->groupname])) return array();
		$datakeys = (is_array($this->datakeys)) ? $this->datakeys : array_keys($this->tblobj->fields);
		$serialdata = trim($_POST[$this->groupname]);
		$rows = explode("\n", $serialdata);
		foreach ($rows as $row) {
			$fields = explode(",", trim($row));
			$key = array_shift($fields);
			$ret[$key] = array();
			$i = 0;
			foreach ($fields as $val) {
				if (isset($datakeys[$i])) {
					$ret[$key][$datakeys[$i]] = urldecode($val);
				} else {
					$ret[$key][$i] = urldecode($val);
				}
				$i++;
			}
		}
		return $ret;
	}

	/**
	 * Returns the data submitted in an AJAX request
	 *
	 * Returns an associative array of data submitted by the user when adding a new row. Available for AJAX requests only.
	 *
	 * @return array Associative array of data from the table
	 */
	function getAjaxSubmission() {
		if (!$this->isAjax()) return false;
		$data = array();
		foreach ($_POST as $key=>$value) {
			if (isset($this->fields[$key])) {
				if ($this->fields[$key]["type"] != "select" or !empty($value) or is_numeric($value)) {
					$data[$key] = $value;
				} else {
					$data[$key] = null;
				}
			}
		}
		return $data;
	}


	/**
	 * Return an HTML representation of the field group
	 *
	 * This method is called by the Inputform when constructing the entire form.  It does not need to be called by your application.
	 *
	 * @param Inputform &$frmobj            Reference to the caller Inputform object
	 * @param boolean   $suppressvalidation Whether to prevent error messages from being included in the output.  Has no effect in the context of activetablefieldgroup (but is implemented in other field groups).
	 * @return  string                         The HTML output
	 */
	function output(&$frmobj, $suppressvalidation=false) {

		$tablehtml = $this->tblobj->getOutput();
		$ret = $tablehtml["content"];
		$ret .= '<table class="activetableform" name="'.$this->groupname.'" id="acttbl_'.$this->groupname.'_form" tableid="'.$this->tblobj->getName().'" formid="'.$frmobj->formname.'"';
		if ($this->ajaxurl) $ret .= ' ajaxurl="'.$this->ajaxurl.'"';
		$ret .= '>';

		$hidfields = "";
		$rowlabels = $rowfields = '<tr>';
		foreach ($this->fields as $name=>$field) {
			if (empty($field["type"])) $field["type"] = "text";
			if (empty($field["default"])) $field["default"] = "";
			$field["accesskey"] = $frmobj->registerField($name, $field);
			$field["prompt"] = (isset($field["prompt"])) ? $field["prompt"] : ((isset($field["label"])) ? $field["label"] : $name);
			if (isset($field["accesskey"])) $field["prompt"] = preg_replace("/(".$field["accesskey"].")/i", "<u>$1</u>", $field["prompt"], 1);
			$attribs = ($field["accesskey"]) ? ' accesskey="'.$field["accesskey"].'"' : '';
			$attribs .= (isset($field["length"])) ? ' maxlength="'.$field["length"].'"' : '';
			$attribs .= (isset($field["width"])) ? ' style="width: '.$field["width"].'px"' : '';
			$domid = "frm".$frmobj->formname."_".$this->groupname.'_'.$name;
			$domclass = "acttbl_".$this->groupname."_field";
			$reqclass = (isset($field["required"]) and $field["required"] == true) ? "reqfield" : "optfield";
			if ($field["type"] != "hidden") $rowlabels .= '<td class='.$reqclass.'><label for="'.$domid.'">'.$field["prompt"].':</label></td>';
			if ($field["type"] != "hidden") $rowfields .= '<td class="forminput">';
			switch($field["type"]) {
				case "hidden":
					$hidfields .= '<input type="hidden" class="'.$domclass.' '.$reqclass.'" value="'.$field["default"].'" name="'.$name.'" id="'.$domid.'" />';
					break;
				case "text":
				case "float":
				case "integer":
				case "percent":
				case "date":
				case "datetime":
				case "datetimeseconds":
				case "time":
				case "timeseconds":
				case "autocomplete":
				case "password":
				case "textarea":
				case "richtext":
					$rowfields .= '<input type="text" class="'.$domclass.'" id="'.$domid.'" name="'.$name.'" value="'.$field["default"].'"'.$attribs.' />';
					if ($field["type"] == "autocomplete") $rowfields .= '<script type="text/javascript">$(document).ready(function(){var acp'.$domid.' = $("#'.$domid.'").autocomplete("'.$field["autocompleteurl"].'", {autoFill:true, cacheLength:10, maxItemsToShow:10, matchSubset:false, smartSelectFirst:true});})</script>';
					break;
				case "select":
				case "enum":
				case "checklist":
				case "check":
				case "boolean":
					$rowfields .= '<select class="'.$domclass.'" id="'.$domid.'" name="'.$name.'"'.$attribs.'>';
					$rowfields .= '<option value=""></option>';
					if (!is_array($field["options"])) trigger_error("No options were supplied for the field: $name", E_USER_ERROR);
					foreach ($field["options"] as $key=>$option) {
						$rowfields .= '<option value="'.$key.'">'.$option.'</option>';
					}
					$rowfields .= '</select>';
					break;
				case "upload":
				case "imageupload":
					$rowfields .= '<input class="fupload '.$domclass.'" type="hidden" id="'.$domid.'" name="'.$name.'" value="'.$field["default"].'"';
					if (isset($field["uploaddest"])) $rowfields .= ' uploaddest="'.$field["uploaddest"].'"';
					if (isset($field["maxfilesize"])) $rowfields .= ' maxfilesize="'.$field["maxfilesize"].'"';
					$rowfields .= ' /><div class="fupload"><div class="uploadplaceholder">'.$field["default"].'</div></div>&nbsp;<input type="button" value="Browse" style="width: 60px" />';
					break;
			}
			if ($field["type"] != "hidden") $rowfields .= '</td>';
		}
		$rowlabels .= '<td></td></tr>';
		$rowfields .= '<td><input type="button" value="Add" id="acttbl_'.$this->groupname.'_btn" class="acttblbtn" /></td>';
		$rowfields .= '</tr>';
		$ret .= $rowlabels.$rowfields;
		$ret .= '</table>';
		$ret .= $hidfields;
		$ret .= '<script>activetabledata["'.$this->groupname.'"] = {';
		if (!empty($this->data)) {
			$recs = array();
			foreach ($this->data as $key=>$vals) {
				$vals = str_replace(array(",","\n","\r","\""), array("%2C","%0A","%0D","%22"), $vals);
				if (is_array($vals)) $vals = join(",", $vals);
				$recs[] = '"'.$key.'":"'.$vals.'"';
			}
			$ret .= join(",", $recs);
		}
		$ret .= '};</script>';
		$frmobj->registerField($this->groupname);
		$ret .= '<input type="hidden" name="'.$this->groupname.'" id="frm'.$frmobj->formname.'_'.$this->groupname.'" value="" />';
		if ($this->title) $ret = "<h4>".$this->title."</h4>".$ret;
		return $ret;
	}
}

/**
 * Allows addition of arbitrary HTML form fragments to an Inputform
 *
 * Note that the contents of custom field groups are not checked for name and ID conflicts with existing fields within the Inputform, so if you use customfieldgroup in conjunction with other field group types, be sure that you do not conflict over field names.
 *
 * @author Andrew Betts
 * @copyright Assanka Limited [All Rights Reserved]
 */
class customfieldgroup {

	var $html;
	var $title;

	/**
	 * Creates a customfieldgroup
	 *
	 * @param Inputform &$frmobj Reference to the Inputform object t which you wish to add the field group
	 * @return customfieldgroup
	 */
	function __construct(&$frmobj) {
		$frmobj->addGroup($this);
		$this->title = "";
		$this->html = "";
	}

	/**
	 * Sets the title of the field group
	 *
	 * If set, will display an H4 title bar on the field group.  Separates the field group from other content units on the page. May be set to false to omit the title (default if method is not called). If the field group is the first content unit on the page, it is customary to avoid having a title (although a page title can be inserted as an H2)
	 *
	 * @param string $title The title to display on the field group
	 * @return  void
	 */
	function setTitle($title) {
		$this->title = $title;
	}

	/**
	 * Add HTML content to the field group
	 *
	 * @param string $html HTML content to display within the field group.  Should contain the form elements that you wish to comproise the field group.
	 * @return  void
	 */
	function addHTML($html) {
		$this->html .= $html;
	}

	/**
	 * Return an HTML representation of the field group
	 *
	 * This method is called by the Inputform when constructing the entire form.  It does not need to be called by your application.
	 *
	 * @return string The HTML output
	 */
	function output() {

		// Output title if provided
		$ret = "";
		if ($this->title) {
			$ret .= "<h4>".$this->title."</h4>";
		}
		$ret .= $this->html;
		return $ret;
	}
}